* Copyright (c) 1994-2014 Synopsys, Inc.
* This parameter file and the associated documentation are proprietary
* to Synopsys, Inc.  This parameter file may only be used in accordance
* with the terms and conditions of a written license agreement with
* Synopsys, Inc.  All other use, reproduction, or distribution of this
* parameter file is strictly prohibited.


Material = "AlAs" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 10.06	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 10.06	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 2.90805	# [1]
	alpha	= 1.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 2.90805	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 1.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.16	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.909091	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.909091	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 3.5	# [eV]
	Eg0	= 2.23	# [eV]
	alpha	= 4.0000e-04	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

	gamma_1	= 3.45	# [1]
	gamma_2	= 0.68	# [1]
	gamma_3	= 1.29	# [1]
	so	= 0.28	# [eV]
	ep_te	= 21.1	# [eV]
	ep_tm	= 21.1	# [eV]
	cr	= 0.019	# [eV]
	A1	= -7.2400e+00	# [1]
	A2	= -5.1000e-01	# [1]
	A3	= 6.73	# [1]
	A4	= -3.3600e+00	# [1]
	A5	= -3.3500e+00	# [1]
	A6	= -4.7200e+00	# [1]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 2.9000e-15	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 2.47	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= -1.5000e+00	# [eV]
	c_11	= 12.5	# [1e-2 GPa]
	c_12	= 5.34	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
	Nc300	= 1.1100e+18	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
	Nv300	= 1.2400e+19	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.26	# [1]
	mh	= 0.5	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 2.5000e+03 ,	1.5000e+02	# [cm^2/(Vs)]
	Exponent	= 1 ,	2.1	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 2.5000e+03 ,	1.5000e+02	# [cm^2/(Vs)]
	Exponent	= 1 ,	2.1	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 2.5000e+03 ,	1.5000e+02	# [cm^2/Vs]
	Ar_alm  	= -1.0000e+00 ,	-2.1000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 2.5000e+03 ,	1.5000e+02	# [cm^2/Vs]
	Ar_alm  	= -1.0000e+00 ,	-2.1000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.1300e+07 ,	1.1300e+07	# [1]
	B_vsat	= 3.6000e+06 ,	3.6000e+06	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.1300e+07 ,	1.1300e+07	# [1]
	B_vsat	= 3.6000e+06 ,	3.6000e+06	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 10.06 ,	10.06	# [1]
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}


}

Material = "AlGaAs" {
*  Mole dependent material: AlGaAs (x=0) = GaAs
*  Mole dependent material: AlGaAs (x=1) = AlAs

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 13.18	# [1]
	epsilon(1)	= 10.06	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 13.18	# [1]
	epsilon(1)	= 10.06	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	refractiveindex(0)	= 3.5108	# [1]
	refractiveindex(1)	= 2.90805	# [1]
	alpha(0)	= 4.0000e-04	# [1/K]
	alpha(1)	= 1.0000e-04	# [1/K]
	CarrDepCoeff(0)	= 1	# [1]
	CarrDepCoeff(1)	= 1	# [1]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0(0)	= 3.5108	# [1]
	n_0(1)	= 2.90805	# [1]
	k_0(0)	= 0.0000e+00	# [1]
	k_0(1)	= 0.0000e+00	# [1]
	Cn_lambda(0)	= 0.0000e+00	# [um^-1]
	Cn_lambda(1)	= 0.0000e+00	# [um^-1]
	Dn_lambda(0)	= 0.0000e+00	# [um^-2]
	Dn_lambda(1)	= 0.0000e+00	# [um^-2]
	Ck_lambda(0)	= 0.0000e+00	# [um^-1]
	Ck_lambda(1)	= 0.0000e+00	# [um^-1]
	Dk_lambda(0)	= 0.0000e+00	# [um^-2]
	Dk_lambda(1)	= 0.0000e+00	# [um^-2]
	Cn_temp(0)	= 4.0000e-04	# [K^-1]
	Cn_temp(1)	= 1.0000e-04	# [K^-1]
	Cn_carr(0)	= 1	# [1]
	Cn_carr(1)	= 1	# [1]
	Cn_gain(0)	= 0.0000e+00	# [1]
	Cn_gain(1)	= 0.0000e+00	# [1]
	Npar(0)	= 1.0000e+18	# [cm^-3]
	Npar(1)	= 1.0000e+18	# [cm^-3]
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	Ck_carr(0)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Ck_carr(1)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Gamma_k_carr(0)	= 1,	1	#[1]
	Gamma_k_carr(1)	= 1,	1	#[1]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	cv(0)	= 1.6	# [J/(Kcm^3)]
	cv(1)	= 1.16	# [J/(Kcm^3)]
	cv_b(0)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_b(1)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_c(0)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_c(1)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_d(0)	= 0.0000e+00	# [J/(K^4*cm^3)]
	cv_d(1)	= 0.0000e+00	# [J/(K^4*cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 2.17391	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 1.1	# [(K cm)/W]
	B(1/kappa(1))	= -3.0000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 2.17391	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 1.1	# [(K cm)/W]
	B(1/kappa(1))	= -3.0000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter dEg0(OldSlotboom):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(OldSlotboom)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.45	# [1]
	dEg0(OldSlotboom)(1)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(1))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEg0(OldSlotboom)(2)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(2))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(2))	= 0.0000e+00	# [eV]

	* parameter dEg0(Slotboom):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(Slotboom)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.45	# [1]
	dEg0(Slotboom)(1)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(1))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEg0(Slotboom)(2)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(2))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(2))	= 0.0000e+00	# [eV]

	* parameter dEg0(delAlamo):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(delAlamo)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.45	# [1]
	dEg0(delAlamo)(1)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(1))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEg0(delAlamo)(2)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(2))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(2))	= 0.0000e+00	# [eV]

	* parameter dEg0(Bennett):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(Bennett)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.45	# [1]
	dEg0(Bennett)(1)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(1))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEg0(Bennett)(2)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(2))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(2))	= 0.0000e+00	# [eV]

	* parameter Eg0:
	Xmax(0)	= 0.0000e+00	# [1]
	Eg0(0)	= 1.42248	# [eV]
	Xmax(1)	= 0.45	# [1]
	Eg0(1)	= 1.98515	# [eV]
	B(Eg0(1))	= 0.0000e+00	# [eV]
	C(Eg0(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	Eg0(2)	= 2.11	# [eV]
	B(Eg0(2))	= 0.143	# [eV]
	C(Eg0(2))	= 0.0000e+00	# [eV]

	* parameter Bgn2Chi:
	Xmax(0)	= 0.0000e+00	# [1]
	Bgn2Chi(0)	= 0.5	# [1]
	Xmax(1)	= 0.45	# [1]
	Bgn2Chi(1)	= 0.5	# [1]
	B(Bgn2Chi(1))	= 0.0000e+00	# [1]
	C(Bgn2Chi(1))	= 0.0000e+00	# [1]
	Xmax(2)	= 1	# [1]
	Bgn2Chi(2)	= 0.5	# [1]
	B(Bgn2Chi(2))	= 0.0000e+00	# [1]
	C(Bgn2Chi(2))	= 0.0000e+00	# [1]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha(0)	= 5.4050e-04	# [eV/K]
	Xmax(1)	= 0.45	# [1]
	alpha(1)	= 4.7727e-04	# [eV/K]
	B(alpha(1))	= 0.0000e+00	# [eV/K]
	C(alpha(1))	= 0.0000e+00	# [eV/K]
	Xmax(2)	= 1	# [1]
	alpha(2)	= 4.0000e-04	# [eV/K]
	B(alpha(2))	= 0.0000e+00	# [eV/K]
	C(alpha(2))	= 0.0000e+00	# [eV/K]

	* parameter alpha2:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha2(0)	= 0.0000e+00	# [eV/K]
	Xmax(1)	= 0.45	# [1]
	alpha2(1)	= 0.0000e+00	# [eV/K]
	B(alpha2(1))	= 0.0000e+00	# [eV/K]
	C(alpha2(1))	= 0.0000e+00	# [eV/K]
	Xmax(2)	= 1	# [1]
	alpha2(2)	= 0.0000e+00	# [eV/K]
	B(alpha2(2))	= 0.0000e+00	# [eV/K]
	C(alpha2(2))	= 0.0000e+00	# [eV/K]

	* parameter beta:
	Xmax(0)	= 0.0000e+00	# [1]
	beta(0)	= 2.0400e+02	# [K]
	Xmax(1)	= 0.45	# [1]
	beta(1)	= 1.1220e+02	# [K]
	B(beta(1))	= 0.0000e+00	# [K]
	C(beta(1))	= 0.0000e+00	# [K]
	Xmax(2)	= 1	# [1]
	beta(2)	= 0.0000e+00	# [K]
	B(beta(2))	= 0.0000e+00	# [K]
	C(beta(2))	= 0.0000e+00	# [K]

	* parameter beta2:
	Xmax(0)	= 0.0000e+00	# [1]
	beta2(0)	= 0.0000e+00	# [K]
	Xmax(1)	= 0.45	# [1]
	beta2(1)	= 0.0000e+00	# [K]
	B(beta2(1))	= 0.0000e+00	# [K]
	C(beta2(1))	= 0.0000e+00	# [K]
	Xmax(2)	= 1	# [1]
	beta2(2)	= 0.0000e+00	# [K]
	B(beta2(2))	= 0.0000e+00	# [K]
	C(beta2(2))	= 0.0000e+00	# [K]

	* parameter Chi0:
	Xmax(0)	= 0.0000e+00	# [1]
	Chi0(0)	= 4.11826	# [eV]
	Xmax(1)	= 0.45	# [1]
	Chi0(1)	= 3.575	# [eV]
	B(Chi0(1))	= 0.0000e+00	# [eV]
	C(Chi0(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	Chi0(2)	= 3.56	# [eV]
	B(Chi0(2))	= 0.0000e+00	# [eV]
	C(Chi0(2))	= 0.0000e+00	# [eV]

	* parameter WorkFunction:
	Xmax(0)	= 0.0000e+00	# [1]
	WorkFunction(0)	= 4.25	# [eV]
	Xmax(1)	= 0.45	# [1]
	WorkFunction(1)	= 4.25	# [eV]
	B(WorkFunction(1))	= 0.0000e+00	# [eV]
	C(WorkFunction(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	WorkFunction(2)	= 4.25	# [eV]
	B(WorkFunction(2))	= 0.0000e+00	# [eV]
	C(WorkFunction(2))	= 0.0000e+00	# [eV]

	* parameter FermiEnergy:
	Xmax(0)	= 0.0000e+00	# [1]
	FermiEnergy(0)	= 11.7	# [eV]
	Xmax(1)	= 0.45	# [1]
	FermiEnergy(1)	= 11.7	# [eV]
	B(FermiEnergy(1))	= 0.0000e+00	# [eV]
	C(FermiEnergy(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	FermiEnergy(2)	= 11.7	# [eV]
	B(FermiEnergy(2))	= 0.0000e+00	# [eV]
	C(FermiEnergy(2))	= 0.0000e+00	# [eV]

	* parameter EgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	EgMin(0)	= -1.0000e+01	# [eV]
	Xmax(1)	= 0.45	# [1]
	EgMin(1)	= -1.0000e+01	# [eV]
	B(EgMin(1))	= 0.0000e+00	# [eV]
	C(EgMin(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	EgMin(2)	= -1.0000e+01	# [eV]
	B(EgMin(2))	= 0.0000e+00	# [eV]
	C(EgMin(2))	= 0.0000e+00	# [eV]

	* parameter dEgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	dEgMin(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.45	# [1]
	dEgMin(1)	= 0.0000e+00	# [eV]
	B(dEgMin(1))	= 0.0000e+00	# [eV]
	C(dEgMin(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEgMin(2)	= 0.0000e+00	# [eV]
	B(dEgMin(2))	= 0.0000e+00	# [eV]
	C(dEgMin(2))	= 0.0000e+00	# [eV]

}


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

JainRoulston
{ * deltaEg = A_i N^(1/3) + B_i N^(1/4) + C_i N^(1/2) + D_i N^(1/2)
  * where i is n for n-type or p for p-type
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A_n(0)	= 0.0000e+00	# [eV cm]
	A_n(1)	= 0.0000e+00	# [eV cm]
	B_n(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_n(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	A_p(0)	= 0.0000e+00	# [eV cm]
	A_p(1)	= 0.0000e+00	# [eV cm]
	B_p(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_p(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	fcaalpha_n(0)	= 4.0000e-18	# [cm^2]
	fcaalpha_n(1)	= 4.0000e-18	# [cm^2]
	fcaalpha_p(0)	= 8.0000e-18	# [cm^2]
	fcaalpha_p(1)	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	gamma_1(0)	= 6.85	# [1]
	gamma_1(1)	= 3.45	# [1]
	gamma_2(0)	= 2.1	# [1]
	gamma_2(1)	= 0.68	# [1]
	gamma_3(0)	= 2.9	# [1]
	gamma_3(1)	= 1.29	# [1]
	so(0)	= 0.34	# [eV]
	so(1)	= 0.28	# [eV]
	ep_te(0)	= 28.8	# [eV]
	ep_te(1)	= 21.1	# [eV]
	ep_tm(0)	= 28.8	# [eV]
	ep_tm(1)	= 21.1	# [eV]
	A1(0)	= 0.0000e+00	# [1]
	A1(1)	= 0.0000e+00	# [1]
	A2(0)	= 0.0000e+00	# [1]
	A2(1)	= 0.0000e+00	# [1]
	A3(0)	= 0.0000e+00	# [1]
	A3(1)	= 0.0000e+00	# [1]
	A4(0)	= 0.0000e+00	# [1]
	A4(1)	= 0.0000e+00	# [1]
	A5(0)	= 0.0000e+00	# [1]
	A5(1)	= 0.0000e+00	# [1]
	A6(0)	= 0.0000e+00	# [1]
	A6(1)	= 0.0000e+00	# [1]
	cr(0)	= 0.0000e+00	# [eV]
	cr(1)	= 0.0000e+00	# [eV]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a_nu(0)	= 1.16	# [eV]
	a_nu(1)	= 2.47	# [eV]
	a_c(0)	= -7.1700e+00	# [eV]
	a_c(1)	= -5.6400e+00	# [eV]
	b_shear(0)	= -1.7000e+00	# [eV]
	b_shear(1)	= -1.5000e+00	# [eV]
	C_11(0)	= 11.879	# [1e-2 GPa]
	C_11(1)	= 12.5	# [1e-2 GPa]
	C_12(0)	= 5.376	# [1e-2 GPa]
	C_12(1)	= 5.34	# [1e-2 GPa]
	eps(0)	= 0.0000e+00	# [1]
	eps(1)	= 0.0000e+00	# [1]
	a0(0)	= 5.6533e-10	# [m]
	a0(1)	= 5.6611e-10	# [m]
	alpha(0)	= 3.8800e-15	# [m/K]
	alpha(1)	= 2.9000e-15	# [m/K]
	D1(0)	= 0.0000e+00	# [eV]
	D1(1)	= 0.0000e+00	# [eV]
	D2(0)	= 0.0000e+00	# [eV]
	D2(1)	= 0.0000e+00	# [eV]
	D3(0)	= 0.0000e+00	# [eV]
	D3(1)	= 0.0000e+00	# [eV]
	D4(0)	= 0.0000e+00	# [eV]
	D4(1)	= 0.0000e+00	# [eV]
	C_13(0)	= 0.0000e+00	# [1e-2 GPa]
	C_13(1)	= 0.0000e+00	# [1e-2 GPa]
	C_33(0)	= 0.0000e+00	# [1e-2 GPa]
	C_33(1)	= 0.0000e+00	# [1e-2 GPa]
	c0(0)	= 0.0000e+00	# [cm]
	c0(1)	= 0.0000e+00	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.1905	# [1]
	a(1)	= 0.1905	# [1]
	ml(0)	= 0.9163	# [1]
	ml(1)	= 0.9163	# [1]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nc300(0)	= 4.4200e+17	# [cm-3]
	Nc300(1)	= 1.1100e+18	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.443587	# [1]
	a(1)	= 0.443587	# [1]
	b(0)	= 3.6095e-03	# [K^-1]
	b(1)	= 3.6095e-03	# [K^-1]
	c(0)	= 1.1735e-04	# [K^-2]
	c(1)	= 1.1735e-04	# [K^-2]
	d(0)	= 1.2632e-06	# [K^-3]
	d(1)	= 1.2632e-06	# [K^-3]
	e(0)	= 3.0256e-09	# [K^-4]
	e(1)	= 3.0256e-09	# [K^-4]
	f(0)	= 4.6834e-03	# [K^-1]
	f(1)	= 4.6834e-03	# [K^-1]
	g(0)	= 2.2869e-04	# [K^-2]
	g(1)	= 2.2869e-04	# [K^-2]
	h(0)	= 7.4693e-07	# [K^-3]
	h(1)	= 7.4693e-07	# [K^-3]
	i(0)	= 1.7275e-09	# [K^-4]
	i(1)	= 1.7275e-09	# [K^-4]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nv300(0)	= 8.4700e+18	# [cm-3]
	Nv300(1)	= 1.2400e+19	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A(0)	= 4.22	# [1]
	A(1)	= 4.22	# [1]
	B(0)	= 0.6084	# [1]
	B(1)	= 0.6084	# [1]
	C(0)	= 23.058	# [1]
	C(1)	= 23.058	# [1]
	ml(0)	= 0.074	# [1]
	ml(1)	= 0.26	# [1]
	mh(0)	= 0.62	# [1]
	mh(1)	= 0.5	# [1]
	me(0)	= 0.0000e+00	# [1]
	me(1)	= 0.0000e+00	# [1]
	eoffset(0)	= 0.0000e+00	# [eV]
	eoffset(1)	= 0.0000e+00	# [eV]
	hoffset(0)	= 0.0000e+00	# [eV]
	hoffset(1)	= 0.0000e+00	# [eV]
}


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1,	2.1	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 8.5000e+03,	4.0000e+02	#[cm^2/(Vs)]
	mumax(1)	= 2.5000e+03,	1.5000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1,	2.1	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 8.5000e+03,	4.0000e+02	#[cm^2/(Vs)]
	mumax(1)	= 2.5000e+03,	1.5000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	a(low)(0)	= 4.0000e+06,	1.3400e+06	#[1/cm]
	a(low)(1)	= 4.0000e+06,	1.3400e+06	#[1/cm]
	a(high)(0)	= 4.0000e+06,	1.3400e+06	#[1/cm]
	a(high)(1)	= 4.0000e+06,	1.3400e+06	#[1/cm]
	b(low)(0)	= 2.3000e+06,	2.0300e+06	#[V/cm]
	b(low)(1)	= 2.3000e+06,	2.0300e+06	#[V/cm]
	b(high)(0)	= 2.3000e+06,	2.0300e+06	#[V/cm]
	b(high)(1)	= 2.3000e+06,	2.0300e+06	#[V/cm]
	E0(0)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	E0(1)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	hbarOmega(0)	= 0.035,	0.035	#[eV]
	hbarOmega(1)	= 0.035,	0.035	#[eV]
	beta(low)(0)	= 0.565912,	0.499479	#[1]
	beta(low)(1)	= 0.565912,	0.499479	#[1]
	beta(high)(0)	= 0.565912,	0.499479	#[1]
	beta(high)(1)	= 0.565912,	0.499479	#[1]
	lambda(0)	= 3.5000e-07,	3.5000e-07	#[cm]
	lambda(1)	= 3.5000e-07,	3.5000e-07	#[cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	a(low)(0)	= 4.0000e+06,	1.3400e+06	#[1/cm]
	a(low)(1)	= 4.0000e+06,	1.3400e+06	#[1/cm]
	a(high)(0)	= 4.0000e+06,	1.3400e+06	#[1/cm]
	a(high)(1)	= 4.0000e+06,	1.3400e+06	#[1/cm]
	b(low)(0)	= 2.3000e+06,	2.0300e+06	#[V/cm]
	b(low)(1)	= 2.3000e+06,	2.0300e+06	#[V/cm]
	b(high)(0)	= 2.3000e+06,	2.0300e+06	#[V/cm]
	b(high)(1)	= 2.3000e+06,	2.0300e+06	#[V/cm]
	E0(0)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	E0(1)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	hbarOmega(0)	= 0.035,	0.035	#[eV]
	hbarOmega(1)	= 0.035,	0.035	#[eV]
	beta(low)(0)	= 0.565912,	0.499479	#[1]
	beta(low)(1)	= 0.565912,	0.499479	#[1]
	beta(high)(0)	= 0.565912,	0.499479	#[1]
	beta(high)(1)	= 0.565912,	0.499479	#[1]
	lambda(0)	= 3.5000e-07,	3.5000e-07	#[cm]
	lambda(1)	= 3.5000e-07,	3.5000e-07	#[cm]
}


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "AlGaN" {
*  Mole dependent material: AlGaN (x=0) = GaN
*  Mole dependent material: AlGaN (x=1) = AlN

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	gamma_1(0)	= 6.85	# [1]
	gamma_1(1)	= 6.85	# [1]
	gamma_2(0)	= 2.1	# [1]
	gamma_2(1)	= 2.1	# [1]
	gamma_3(0)	= 2.9	# [1]
	gamma_3(1)	= 2.9	# [1]
	so(0)	= 0.019	# [eV]
	so(1)	= 0.014	# [eV]
	ep_te(0)	= 15.6	# [eV]
	ep_te(1)	= 18.8	# [eV]
	ep_tm(0)	= 13.8	# [eV]
	ep_tm(1)	= 12.4	# [eV]
	A1(0)	= -3.9500e+00	# [1]
	A1(1)	= -7.2400e+00	# [1]
	A2(0)	= -2.7000e-01	# [1]
	A2(1)	= -5.1000e-01	# [1]
	A3(0)	= 3.68	# [1]
	A3(1)	= 6.73	# [1]
	A4(0)	= -1.8400e+00	# [1]
	A4(1)	= -3.3600e+00	# [1]
	A5(0)	= -1.9200e+00	# [1]
	A5(1)	= -3.3500e+00	# [1]
	A6(0)	= -2.9100e+00	# [1]
	A6(1)	= -4.7200e+00	# [1]
	cr(0)	= -1.6400e-01	# [eV]
	cr(1)	= 0.019	# [eV]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a_nu(0)	= 0.19	# [eV]
	a_nu(1)	= 0.19	# [eV]
	a_c(0)	= -4.0800e+00	# [eV]
	a_c(1)	= -4.0800e+00	# [eV]
	b_shear(0)	= 0.9163	# [eV]
	b_shear(1)	= 0.9163	# [eV]
	C_11(0)	= 11.879	# [1e-2 GPa]
	C_11(1)	= 11.879	# [1e-2 GPa]
	C_12(0)	= 5.376	# [1e-2 GPa]
	C_12(1)	= 5.376	# [1e-2 GPa]
	eps(0)	= 0.0000e+00	# [1]
	eps(1)	= 0.0000e+00	# [1]
	a0(0)	= 3.1120e-10	# [m]
	a0(1)	= 3.1890e-10	# [m]
	alpha(0)	= 0.0000e+00	# [m/K]
	alpha(1)	= 0.0000e+00	# [m/K]
	D1(0)	= -8.9000e-01	# [eV]
	D1(1)	= -8.9000e-01	# [eV]
	D2(0)	= 4.27	# [eV]
	D2(1)	= 4.27	# [eV]
	D3(0)	= 5.18	# [eV]
	D3(1)	= 5.18	# [eV]
	D4(0)	= -2.5900e+00	# [eV]
	D4(1)	= -2.5900e+00	# [eV]
	C_13(0)	= 1.27	# [1e-2 GPa]
	C_13(1)	= 1	# [1e-2 GPa]
	C_33(0)	= 3.82	# [1e-2 GPa]
	C_33(1)	= 3.92	# [1e-2 GPa]
	c0(0)	= 4.9820e-10	# [cm]
	c0(1)	= 5.1850e-10	# [cm]
}


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

TransferredElectronEffect2:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	* parameter mu1:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	mu1(0)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(1)	= 0.2,	0.2	#[1]
	mu1(1)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(1))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(1))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(2)	= 0.5,	0.5	#[1]
	mu1(2)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(2))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(2))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(3)	= 0.8,	0.8	#[1]
	mu1(3)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(3))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(3))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(4)	= 1,	1	#[1]
	mu1(4)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(4))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(4))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]

	* parameter E0:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	E0(0)	= 2.2089e+05,	4.0000e+03	#[V/cm]
	Xmax(1)	= 0.2,	0.2	#[1]
	E0(1)	= 2.4558e+05,	4.0000e+03	#[V/cm]
	B(E0(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(2)	= 0.5,	0.5	#[1]
	E0(2)	= 3.0455e+05,	4.0000e+03	#[V/cm]
	B(E0(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(3)	= 0.8,	0.8	#[1]
	E0(3)	= 3.8624e+05,	4.0000e+03	#[V/cm]
	B(E0(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(4)	= 1,	1	#[1]
	E0(4)	= 4.4703e+05,	4.0000e+03	#[V/cm]
	B(E0(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]

	* parameter E1:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	E1(0)	= 2.2089e+05,	4.0000e+03	#[V/cm]
	Xmax(1)	= 0.2,	0.2	#[1]
	E1(1)	= 2.4558e+05,	4.0000e+03	#[V/cm]
	B(E1(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(2)	= 0.5,	0.5	#[1]
	E1(2)	= 3.0455e+05,	4.0000e+03	#[V/cm]
	B(E1(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(3)	= 0.8,	0.8	#[1]
	E1(3)	= 3.8624e+05,	4.0000e+03	#[V/cm]
	B(E1(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(4)	= 1,	1	#[1]
	E1(4)	= 4.4703e+05,	4.0000e+03	#[V/cm]
	B(E1(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.7857,	0.0000e+00	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	alpha(1)	= 0.7897,	0.0000e+00	#[1]
	B(alpha(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	alpha(2)	= 0.808,	0.0000e+00	#[1]
	B(alpha(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	alpha(3)	= 0.8324,	0.0000e+00	#[1]
	B(alpha(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	alpha(4)	= 0.8554,	0.0000e+00	#[1]
	B(alpha(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(4))	= 0.0000e+00,	0.0000e+00	#[1]

	* parameter beta:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	beta(0)	= 7.2044,	4	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	beta(1)	= 7.8138,	4	#[1]
	B(beta(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	beta(2)	= 9.4438,	4	#[1]
	B(beta(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	beta(3)	= 12.5795,	4	#[1]
	B(beta(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	beta(4)	= 17.3681,	4	#[1]
	B(beta(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(4))	= 0.0000e+00,	0.0000e+00	#[1]

	* parameter gamma:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	gamma(0)	= 6.1973,	0.0000e+00	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	gamma(1)	= 6.9502,	0.0000e+00	#[1]
	B(gamma(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	gamma(2)	= 8.0022,	0.0000e+00	#[1]
	B(gamma(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	gamma(3)	= 8.6037,	0.0000e+00	#[1]
	B(gamma(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	gamma(4)	= 8.7253,	0.0000e+00	#[1]
	B(gamma(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(4))	= 0.0000e+00,	0.0000e+00	#[1]

}

TransferredElectronEffect2_aniso:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	* parameter mu1:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	mu1(0)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(1)	= 0.2,	0.2	#[1]
	mu1(1)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(1))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(1))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(2)	= 0.5,	0.5	#[1]
	mu1(2)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(2))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(2))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(3)	= 0.8,	0.8	#[1]
	mu1(3)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(3))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(3))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(4)	= 1,	1	#[1]
	mu1(4)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(4))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(4))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]

	* parameter E0:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	E0(0)	= 2.2089e+05,	4.0000e+03	#[V/cm]
	Xmax(1)	= 0.2,	0.2	#[1]
	E0(1)	= 2.4558e+05,	4.0000e+03	#[V/cm]
	B(E0(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(2)	= 0.5,	0.5	#[1]
	E0(2)	= 3.0455e+05,	4.0000e+03	#[V/cm]
	B(E0(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(3)	= 0.8,	0.8	#[1]
	E0(3)	= 3.8624e+05,	4.0000e+03	#[V/cm]
	B(E0(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(4)	= 1,	1	#[1]
	E0(4)	= 4.4703e+05,	4.0000e+03	#[V/cm]
	B(E0(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]

	* parameter E1:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	E1(0)	= 2.2089e+05,	4.0000e+03	#[V/cm]
	Xmax(1)	= 0.2,	0.2	#[1]
	E1(1)	= 2.4558e+05,	4.0000e+03	#[V/cm]
	B(E1(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(2)	= 0.5,	0.5	#[1]
	E1(2)	= 3.0455e+05,	4.0000e+03	#[V/cm]
	B(E1(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(3)	= 0.8,	0.8	#[1]
	E1(3)	= 3.8624e+05,	4.0000e+03	#[V/cm]
	B(E1(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(4)	= 1,	1	#[1]
	E1(4)	= 4.4703e+05,	4.0000e+03	#[V/cm]
	B(E1(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.7857,	0.0000e+00	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	alpha(1)	= 0.7897,	0.0000e+00	#[1]
	B(alpha(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	alpha(2)	= 0.808,	0.0000e+00	#[1]
	B(alpha(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	alpha(3)	= 0.8324,	0.0000e+00	#[1]
	B(alpha(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	alpha(4)	= 0.8554,	0.0000e+00	#[1]
	B(alpha(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(4))	= 0.0000e+00,	0.0000e+00	#[1]

	* parameter beta:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	beta(0)	= 7.2044,	4	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	beta(1)	= 7.8138,	4	#[1]
	B(beta(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	beta(2)	= 9.4438,	4	#[1]
	B(beta(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	beta(3)	= 12.5795,	4	#[1]
	B(beta(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	beta(4)	= 17.3681,	4	#[1]
	B(beta(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(4))	= 0.0000e+00,	0.0000e+00	#[1]

	* parameter gamma:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	gamma(0)	= 6.1973,	0.0000e+00	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	gamma(1)	= 6.9502,	0.0000e+00	#[1]
	B(gamma(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	gamma(2)	= 8.0022,	0.0000e+00	#[1]
	B(gamma(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	gamma(3)	= 8.6037,	0.0000e+00	#[1]
	B(gamma(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	gamma(4)	= 8.7253,	0.0000e+00	#[1]
	B(gamma(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(4))	= 0.0000e+00,	0.0000e+00	#[1]

}


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "AlGaP" {
*  Mole dependent material: AlGaP (x=0) = GaP
*  Mole dependent material: AlGaP (x=1) = AlP

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.33	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlP) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "AlInGaAs" {
*  Mole dependent material: AlInGaAs (x=0,y=0) = GaAs
*  Mole dependent material: AlInGaAs (x=1,y=0) = AlAs
*  Mole dependent material: AlInGaAs (x=0,y=1) = InAs

*  Epsilon{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Epsilon_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  refractiveindex{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.5108	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 4.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Kappa{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Kappa_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnergyRelaxationTime{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Bandgap{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  OldSlotboom { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Slotboom { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  delAlamo { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Bennett { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  JainRoulston { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  FreeCarrierAbsorption{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  BandstructureParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  QWstrain{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  eDOSMass{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  hDOSMass{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  SchroedingerParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  QuantumPotentialParameters { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ConstantMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ConstantMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  DopingDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  DopingDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnormalDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnormalDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ThinLayerMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ThinLayerMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  IALMob{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  IALMob_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EffectiveStressModel{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  NegInterfaceChargeMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  NegInterfaceChargeMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PosInterfaceChargeMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PosInterfaceChargeMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Coulomb2DMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Coulomb2DMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  HighFieldDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  HighFieldDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  SHEDistribution{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Radiative Recombination Model{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  MLDAQMModel { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  LatticeParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Piezoelectric_Polarization{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  StressMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaAs)(x,y) =
*          w0 * P(AlGaAs)(x0) +
*          w1 * P(InAlAs)(x1) +
*          w2 * P(InGaAs)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaAs side material
*      x1: projection of (x,y) onto InAlAs side material
*      x2: projection of (x,y) onto InGaAs side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


}

Material = "AlInGaN" {
*  Mole dependent material: AlInGaN (x=0,y=0) = GaN
*  Mole dependent material: AlInGaN (x=1,y=0) = AlN
*  Mole dependent material: AlInGaN (x=0,y=1) = InN

*  Epsilon{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Epsilon_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  refractiveindex{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Kappa{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Kappa_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnergyRelaxationTime{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Bandgap{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  OldSlotboom { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Slotboom { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  delAlamo { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Bennett { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  JainRoulston { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  FreeCarrierAbsorption{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  BandstructureParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  QWstrain{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  eDOSMass{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  hDOSMass{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  SchroedingerParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  QuantumPotentialParameters { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ConstantMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ConstantMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  DopingDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  DopingDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnormalDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnormalDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ThinLayerMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ThinLayerMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  IALMob{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  IALMob_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EffectiveStressModel{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  NegInterfaceChargeMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  NegInterfaceChargeMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PosInterfaceChargeMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PosInterfaceChargeMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Coulomb2DMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Coulomb2DMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  HighFieldDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  HighFieldDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  SHEDistribution{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Radiative Recombination Model{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  MLDAQMModel { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  LatticeParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Piezoelectric_Polarization{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  StressMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaN)(x,y) =
*          w0 * P(AlGaN)(x0) +
*          w1 * P(AlInN)(x1) +
*          w2 * P(InGaN)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaN side material
*      x1: projection of (x,y) onto AlInN side material
*      x2: projection of (x,y) onto InGaN side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


}

Material = "AlInGaP" {
*  Mole dependent material: AlInGaP (x=0,y=0) = GaP
*  Mole dependent material: AlInGaP (x=1,y=0) = AlP
*  Mole dependent material: AlInGaP (x=0,y=1) = InP

*  Epsilon{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Epsilon_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  refractiveindex{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.33	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Kappa{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Kappa_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnergyRelaxationTime{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Bandgap{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  OldSlotboom { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Slotboom { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  delAlamo { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Bennett { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  JainRoulston { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  FreeCarrierAbsorption{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  BandstructureParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  QWstrain{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  eDOSMass{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  hDOSMass{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  SchroedingerParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  QuantumPotentialParameters { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ConstantMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ConstantMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  DopingDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  DopingDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnormalDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EnormalDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ThinLayerMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  ThinLayerMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  IALMob{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  IALMob_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  EffectiveStressModel{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  NegInterfaceChargeMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  NegInterfaceChargeMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PosInterfaceChargeMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  PosInterfaceChargeMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Coulomb2DMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Coulomb2DMobility_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  HighFieldDependence{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  HighFieldDependence_aniso{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  SHEDistribution{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Radiative Recombination Model{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  MLDAQMModel { ... } 
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  LatticeParameters{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  Piezoelectric_Polarization{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


*  StressMobility{...}
*  The following interpolation between the side materials is used
*  to compute the value of a parameter P:
*      P(AlInGaP)(x,y) =
*          w0 * P(AlGaP)(x0) +
*          w1 * P(AlInP)(x1) +
*          w2 * P(GaInP)(x2)
*  where:
*      x0: projection of (x,y) onto AlGaP side material
*      x1: projection of (x,y) onto AlInP side material
*      x2: projection of (x,y) onto GaInP side material
*  The weights w0, w1, w2 are nonnegative, and w0+w1+w2=1.


}

Material = "AlInN" {
*  Mole dependent material: AlInN (x=0) = AlN
*  Mole dependent material: AlInN (x=1) = InN

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(AlN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "AlInP" {
*  Mole dependent material: AlInP (x=0) = AlP
*  Mole dependent material: AlInP (x=1) = InP

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InP) + (1-x) * P(AlP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "AlN" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 10.7	# [1]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

	gamma_1	= 6.85	# [1]
	gamma_2	= 2.1	# [1]
	gamma_3	= 2.9	# [1]
	so	= 0.019	# [eV]
	ep_te	= 15.6	# [eV]
	ep_tm	= 13.8	# [eV]
	cr	= -1.6400e-01	# [eV]
	A1	= -3.9500e+00	# [1]
	A2	= -2.7000e-01	# [1]
	A3	= 3.68	# [1]
	A4	= -1.8400e+00	# [1]
	A5	= -1.9200e+00	# [1]
	A6	= -2.9100e+00	# [1]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1120e-10	# [cm]
	alpha	= 0.0000e+00	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 0.19	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= 0.9163	# [eV]
	c_11	= 11.879	# [1e-2 GPa]
	c_12	= 5.376	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1.27	# [1e-2 GPa]
	c_33	= 3.82	# [1e-2 GPa]
	c0	= 4.9820e-10	# [cm]
}

TransferredElectronEffect2:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	mu1	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	E0	= 4.4703e+05 ,	4.0000e+03	# [V/cm]
	E1	= 4.4703e+05 ,	4.0000e+03	# [V/cm]
	alpha	= 0.8554 ,	0.0000e+00	# [1]
	beta	= 17.3681 ,	4	# [1]
	gamma	= 8.7253 ,	0.0000e+00	# [1]
}

TransferredElectronEffect2_aniso:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	mu1	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	E0	= 4.4703e+05 ,	4.0000e+03	# [V/cm]
	E1	= 4.4703e+05 ,	4.0000e+03	# [V/cm]
	alpha	= 0.8554 ,	0.0000e+00	# [1]
	beta	= 17.3681 ,	4	# [1]
	gamma	= 8.7253 ,	0.0000e+00	# [1]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 9 ,	9	# [1]
}

Piezoelectric_Polarization
{ * The 'strain' model computes the polarization vector as follows:
  * 
  *   [P_x]   [psp_x                                     ]
  *   [P_y] = [psp_y                                     ]
  *   [P_z]   [psp_z + 2*d31*strain*(c11+c12-2*c13^2/c33)] (Formula 1)
  *   [P_z]   [psp_z + 2*strain*(e31 - e33*c13/c33)      ] (Formula 2)
  * 
  *   strain = (1-relax)*(a0-a)/a
  * 
  * The 'stress' model computes the polarization vector as follows:
  * 
  *   [P_x]   [psp_x]   [d11 d12 d13 d14 d15 d16]   [stress_XX]
  *   [P_y] = [psp_y] + [d21 d22 d23 d24 d25 d26] * [stress_YY]
  *   [P_z]   [psp_z]   [d31 d32 d33 d34 d35 d36]   [stress_ZZ]
  *                                                 [stress_YZ]
  *                                                 [stress_XZ]
  *                                                 [stress_XY]
  * 
  * The Poisson equation is:
  * 
  *   div(eps*grad(phi)) = -ro + activation*div(P),
  *   where P = (P_x,P_y,P_z) - polarization vector
  * 
  * Parameters:
  * 
  *   activation: non negative real calibration parameter
  *               to scale the polarization charge [1], 
  *               this value can be set in a 'Physics' section of input file 
  * 
  *   [psp_x]: spontaneous polarization vector,
  *   [psp_y]  defined in crystal system [C/cm^2]
  *   [psp_z]
  * 
  *   c11, c12, c13, c33: stiffness constants,
  *                       defined in crystal system [Pa]
  * 
  *   e31, e33: strain-charge piezoelectric coefficients,
  *             defined in crystal system [C/cm^2]
  * 
  *   a0: strained lattice constant [Angstrem]
  *   a: unstrained lattice constant [Angstrem]
  *   relax: relaxation parameter [1]
  * 
  *   d11 ... d36: piezoelectric coefficients,
  *                defined in crystal system [cm/V]
  * 
  * Fields:
  * 
  *   [stress_XX]: stress tensor,
  *   [stress_YY]  defined in stress system [Pa]
  *   [stress_ZZ]
  *   [stress_YZ]
  *   [stress_XZ]
  *   [stress_XY]
  * 
  *   [P_x]: polarization vector,
  *   [P_y]  defined in simulation system [C/cm^2]
  *   [P_z]
  * 
  * Coordinate systems:
  * 
  *   The simulation system is defined relative to the crystal
  *   system.  For example:
  * 
  *     LatticeParameters {
  *       X = (1, 0,  0)
  *       Y = (0, 0, -1)
  *     }
  * 
  *   The stress coordinate system is defined relative to the simulation
  *   system.  For example:
  * 
  *     Physics {
  *       Piezo (
  *         OriKddX = (-0.96  0.28  0)
  *         OriKddY = ( 0.28  0.96  0)
  *         Stress = (1e9  2e9  3e9  4e9  5e9  6e9)  # [Pa]
  *       )
  *     }
  * 
  *   To compute the polarization vector, the stress tensor is first
  *   transformed from the stress system to the crystal system.  Then
  *   the polarization vector is evaluated according to the 'strain' or
  *   'stress' model above.  Finally, the polarization vector is transformed
  *   from the crystal system to the simulation system.
  * 
  * piezoelectric coefficients:
	d11	= 0.0000e+00	# [cm/V]
	d12	= 0.0000e+00	# [cm/V]
	d13	= 0.0000e+00	# [cm/V]
	d14	= 0.0000e+00	# [cm/V]
	d15	= -4.0000e-10	# [cm/V]
	d16	= 0.0000e+00	# [cm/V]
	d21	= 0.0000e+00	# [cm/V]
	d22	= 0.0000e+00	# [cm/V]
	d23	= 0.0000e+00	# [cm/V]
	d24	= -4.0000e-10	# [cm/V]
	d25	= 0.0000e+00	# [cm/V]
	d26	= 0.0000e+00	# [cm/V]
	d31	= -1.9000e-10	# [cm/V]
	d32	= -1.9000e-10	# [cm/V]
	d33	= 4.8000e-10	# [cm/V]
	d34	= 0.0000e+00	# [cm/V]
	d35	= 0.0000e+00	# [cm/V]
	d36	= 0.0000e+00	# [cm/V]
  * 
  * spontaneous polarization:
	psp_x	= 0.0000e+00	# [C/cm^2]
	psp_y	= 0.0000e+00	# [C/cm^2]
	psp_z	= -8.1000e-06	# [C/cm^2]
  * 
	Formula	= 1	# [1]
  * 
  * stiffness constants:
	c11	= 3.9600e+11	# [Pa]
	c12	= 1.3700e+11	# [Pa]
	c13	= 1.0800e+11	# [Pa]
	c33	= 3.7300e+11	# [Pa]
  * 
  * piezoelectric coefficients:
	e31	= -5.0000e-05	# [C/cm^2]
	e33	= 1.7900e-04	# [C/cm^2]
  * 
  * strain parameters:
	a0	= 3.189	# [Angstrem]
	a	= 3.112	# [Angstrem]
	relax	= 0.1	# [1]
}


}

Material = "AlP" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "Aluminum" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 0.0000e+00	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.01653	1.01	0.024;
          0.01676	1.01	0.0242;
          0.01698	1.02	0.0191;
          0.01722	1.02	3.4600e-03;
          0.01746	1.01	3.4600e-03;
          0.01771	1.01	3.5200e-03;
          0.01908	0.995	4.1700e-03;
          0.02066	0.987	4.4100e-03;
          0.02254	0.979	5.0800e-03;
          0.0248	0.969	5.8700e-03;
          0.02755	0.957	6.8200e-03;
          0.031	0.94	8.1600e-03;
          0.03263	0.931	8.7100e-03;
          0.03444	0.921	9.3200e-03;
          0.03647	0.909	0.0102;
          0.03757	0.902	0.0107;
          0.03875	0.894	0.0111;
          0.04	0.885	0.0116;
          0.04133	0.876	0.0125;
          0.04275	0.865	0.0135;
          0.04428	0.854	0.0145;
          0.04592	0.841	0.0155;
          0.04769	0.826	0.0165;
          0.04959	0.809	0.0177;
          0.05166	0.789	0.019;
          0.05391	0.766	0.0205;
          0.05636	0.74	0.0222;
          0.05904	0.707	0.0242;
          0.06199	0.688	0.0268;
          0.06358	0.646	0.0284;
          0.06526	0.62	0.0302;
          0.06702	0.591	0.0324;
          0.06888	0.558	0.0348;
          0.07085	0.52	0.0381;
          0.07293	0.474	0.0423;
          0.07514	0.419	0.0487;
          0.07749	0.351	0.0595;
          0.07999	0.258	0.0777;
          0.08266	0.125	0.153;
          0.08551	0.0616	0.301;
          0.08856	0.0481	0.416;
          0.09184	0.0409	0.517;
          0.09537	0.0376	0.609;
          0.09919	0.0344	0.7;
          0.1033	0.0328	0.791;
          0.1078	0.0331	0.883;
          0.1127	0.0356	0.978;
          0.1181	0.0396	1.08;
          0.124	0.0442	1.18;
          0.1305	0.0495	1.29;
          0.1378	0.0557	1.4;
          0.1417	0.0592	1.46;
          0.1459	0.063	1.53;
          0.1503	0.0671	1.59;
          0.155	0.0716	1.66;
          0.16	0.0765	1.74;
          0.1653	0.082	1.81;
          0.171	0.088	1.9;
          0.1771	0.0946	1.98;
          0.1837	0.102	2.07;
          0.1907	0.11	2.17;
          0.1984	0.119	2.28;
          0.2066	0.13	2.39;
          0.2156	0.141	2.51;
          0.2254	0.155	2.64;
          0.2362	0.172	2.79;
          0.248	0.19	2.94;
          0.261	0.209	3.11;
          0.2755	0.233	3.3;
          0.2917	0.261	3.51;
          0.3	0.276	3.61;
          0.31	0.294	3.74;
          0.3179	0.31	3.84;
          0.3263	0.326	3.95;
          0.3351	0.344	4.06;
          0.3444	0.364	4.17;
          0.35	0.375	4.24;
          0.3542	0.385	4.3;
          0.3647	0.407	4.43;
          0.3757	0.432	4.56;
          0.3875	0.46	4.71;
          0.4	0.49	4.86;
          0.4133	0.523	5.02;
          0.4275	0.558	5.2;
          0.4428	0.598	5.38;
          0.45	0.618	5.47;
          0.4592	0.644	5.58;
          0.4769	0.695	5.8;
          0.4959	0.755	6.03;
          0.5	0.769	6.08;
          0.5061	0.789	6.15;
          0.5166	0.826	6.28;
          0.5276	0.867	6.42;
          0.5391	0.912	6.55;
          0.55	0.958	6.69;
          0.551	0.963	6.7;
          0.5636	1.02	6.85;
          0.5767	1.08	7;
          0.5904	1.15	7.15;
          0.6	1.2	7.26;
          0.6048	1.22	7.31;
          0.6199	1.3	7.48;
          0.6358	1.39	7.65;
          0.65	1.47	7.79;
          0.6526	1.49	7.82;
          0.6702	1.6	8.01;
          0.6888	1.74	8.21;
          0.7	1.83	8.31;
          0.7085	1.91	8.39;
          0.7293	2.14	8.57;
          0.75	2.4	8.62;
          0.7514	2.41	8.62;
          0.7749	2.63	8.6;
          0.7999	2.8	8.45;
          0.825	2.75	8.31;
          0.8266	2.74	8.31;
          0.85	2.61	8.22;
          0.8551	2.58	8.21;
          0.875	2.38	8.18;
          0.8856	2.24	8.21;
          0.9	2.06	8.3;
          0.9184	1.86	8.44;
          0.925	1.77	8.49;
          0.95	1.49	8.88;
          0.9537	1.47	8.95;
          0.9919	1.37	9.49;
          1	1.35	9.58;
          1.033	1.26	10;
          1.078	1.21	10.6;
          1.127	1.2	11.2;
          1.181	1.21	11.8;
          1.2	1.21	12;
          1.24	1.21	12.5;
          1.305	1.23	13.2;
          1.378	1.26	14;
          1.459	1.33	14.9;
          1.5	1.38	15.4;
          1.55	1.44	16;
          1.653	1.59	17.1;
          1.771	1.77	18.3;
          1.907	1.99	19.8;
          2	2.15	20.7;
          2.065	2.27	21.4;
          2.254	2.62	23.3;
          2.48	3.07	25.6;
          2.755	3.68	28.3;
          3	4.24	30.6;
          3.1	4.45	31.5;
          3.306	4.88	33.4;
          3.542	5.44	35.6;
          3.815	6	38.1;
          4	6.43	39.8;
          4.133	6.76	41;
          4.509	7.61	44.3;
          4.959	8.59	48.2;
          5	8.67	48.6;
          5.51	9.85	53.2;
          6	11.1	57.6;
          6.199	11.7	59.4;
          6.526	12.7	62.2;
          6.888	13.7	65.2;
          7	14	66.2;
          7.293	14.9	68.8;
          7.749	16.5	72.7;
          8	17.5	74.9;
          8.266	18.6	77;
          8.856	20.9	81.5;
          9	21.5	82.6;
          9.537	23.5	86.5;
          10	25.3	89.8;
          10.33	26.6	92.2;
          11	29.2	96.6;
          11.27	30.2	98.4;
          12	33	1.0300e+02;
          12.4	34.5	1.0600e+02;
          13	36.6	1.0900e+02;
          13.05	36.8	1.1000e+02;
          13.78	39.7	1.1400e+02;
          14	40.5	1.1600e+02;
          14.59	42.8	1.1900e+02;
          15.5	46	1.2400e+02;
          16	47.7	1.2700e+02;
          16.53	49.7	1.2900e+02;
          17.71	53.8	1.3600e+02;
          18	54.7	1.3700e+02;
          19.07	57.6	1.4300e+02;
          20	60.7	1.4700e+02;
          20.66	62.9	1.5100e+02;
          22	66.9	1.5700e+02;
          22.54	68.3	1.6000e+02;
          24	72.2	1.6800e+02;
          24.8	75	1.7200e+02;
          26	79.1	1.7800e+02;
          27.55	84.7	1.8600e+02;
          28	86.3	1.8900e+02;
          30.01	94.2	1.9900e+02;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 2.33	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 2.38	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 2.38	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 4.1	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 2.4500e-06	# [ohm*cm]
	TempCoef	= 4.5000e-03	# [1/K]
}


}

Material = "Anyinsulator" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "Anysemiconductor" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.26	# [1]
	mh	= 0.5	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}


}

Material = "BN" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "BSG" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.97	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1.97	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.67	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "CdTe" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 10.6	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 10.6	# [1]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 4.28	# [eV]
	Eg0	= 1.6	# [eV]
	alpha	= 0.0000e+00	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 3.0000e+02	# [K]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.096	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 0.43	# [1]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.0000e+03 ,	80	# [cm^2/(Vs)]
	Exponent	= 1.7 ,	1.67	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.0000e+03 ,	80	# [cm^2/(Vs)]
	Exponent	= 1.7 ,	1.67	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 10.6 ,	10.6	# [1]
}

Absorption
{ * Formula = 1:
  * A = A1*exp((phE-E1)/E2),     for phE < E1 
  *   = A1 + A2*((phE-E1)/E2)^P, for phE >= E1 
  * Formula = 2:
  * A = A0*exp((phE-phE0)*ST),              for phE < phE0 
  *   = AT*(2*ST*(phE-E0-(LN-0.5)/ST))^0.5, for phE >= phE0 
  * where 
  *      phE is a photon energy, 
  *      LN = log(AT/A0), 
  *      ST = S/(T+T0), T is a temperature, 
  *      phE0 = E0 + LN/ST. 

	Formula	= 2	# [1]
  * Formula = 2:
	AT	= 5.1000e+03	# [cm-1]
	A0	= 1.2107e+15	# [cm-1]
	S	= 6.5340e+04	# [K/eV]
	E0	= 1.4956	# [eV]
	T0	= 81.9	# [K]
}


}

Material = "Ceramic" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 4.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 4.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 2.21	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 2.21	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 2.78	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.167	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.167	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "Cobalt" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 5.6000e-06	# [ohm*cm]
	TempCoef	= 6.5800e-03	# [1/K]
}


}

Material = "CobaltSilicide" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "Copper" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 0.0000e+00	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 3.42	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 3.85	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 3.85	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 4.7	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 1.5600e-06	# [ohm*cm]
	TempCoef	= 4.3000e-03	# [1/K]
}


}

Material = "GaAs" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 13.18	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 13.18	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 3.5108	# [1]
	alpha	= 4.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.5108	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 4.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.6	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.46	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.46	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 4.07	# [eV]
	Bgn2Chi	= 0.5	# [1]
	Eg0	= 1.519	# [eV]
	alpha	= 5.4050e-04	# [eV K^-1]
	beta	= 2.0400e+02	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

JainRoulston
{ * deltaEg = A_i N^(1/3) + B_i N^(1/4) + C_i N^(1/2) + D_i N^(1/2)
  * where i is n for n-type or p for p-type
	A_n	= 1.6500e-08	# [eV cm]
	A_p	= 9.7700e-09	# [eV cm]
	B_n	= 2.3800e-07	# [eV cm^(3/4)]
	B_p	= 3.8700e-07	# [eV cm^(3/4)]
	C_n	= 1.8300e-11	# [eV cm^(3/2)]
	C_p	= 3.4100e-12	# [eV cm^(3/2)]
	D_n	= 7.2500e-11	# [eV cm^(3/2)]
	D_p	= 4.8400e-13	# [eV cm^(3/2)]
}

TableBGN
{ * In the band-gap narrowing table, a list of concentrations
  * and the bandgap narrowing for them can be specified.
  * The first possibility is to specify total concentrations (the sum
  * of acceptor and donor concentration) and the band gap narrowing,
  * and then the table entries have the form:
  *   Total       Nt, deltaEg   # [ cm-3, eV ]
  * The second possibility is to specify the band gap narrowing for
  * acceptors and donors separately (This must not be combined with
  * specification of total concentrations).  The bandgap narrowing
  * then will be the sum of both contributions; if no acceptor or donor
  * entry exists, the respective bandgap narrowing contribution is 0.
  * The entries take the form:
  *   Donor       Nd, deltaEg   # [ cm-3, eV ]
  *   Acceptor    Na, deltaEg   # [ cm-3, eV ]
  * For each of the two possibilities, any number of table entries might
  * be given in any order.  For concentrations which are below (above)
  * the smallest (largest) concentration specified in the appropriate
  * table, the bandgap narrowing associated to the smallest (largest)
  * entry is assumed.  For concentration which fall in between table
  * entries, the bandgap narrowing is assumed to be linear in the
  * logarithm of the respective concentration and is interpolated
  * accordingly.
  Donor     1.0000e+16,   0.0000e+00   # [ cm-3, eV ]
  Donor     1.4100e+17,   0.0176   # [ cm-3, eV ]
  Donor     1.8900e+17,   0.0145   # [ cm-3, eV ]
  Donor     7.2000e+17,   0.0137   # [ cm-3, eV ]
  Donor     1.3900e+18,   6.6000e-03   # [ cm-3, eV ]
  Donor     2.0300e+18,   -1.6000e-03   # [ cm-3, eV ]
  Donor     4.2000e+18,   -2.5100e-02   # [ cm-3, eV ]
  Acceptor  1.0000e+17,   0.0000e+00   # [ cm-3, eV ]
  Acceptor  1.4000e+18,   0.0303   # [ cm-3, eV ]
  Acceptor  2.6000e+18,   0.0324   # [ cm-3, eV ]
  Acceptor  3.1000e+18,   0.036   # [ cm-3, eV ]
  Acceptor  4.6000e+18,   0.0453   # [ cm-3, eV ]
  Acceptor  1.0000e+19,   0.0507   # [ cm-3, eV ]
  Acceptor  2.2000e+19,   0.0525   # [ cm-3, eV ]
  Acceptor  2.6000e+19,   0.0498   # [ cm-3, eV ]
  Acceptor  4.1000e+19,   0.0477   # [ cm-3, eV ]
  Acceptor  4.3000e+19,   0.0444   # [ cm-3, eV ]
  Acceptor  6.0000e+19,   0.0476   # [ cm-3, eV ]
  Acceptor  7.5900e+19,   0.0394   # [ cm-3, eV ]
  Acceptor  9.7300e+19,   0.0362   # [ cm-3, eV ]
  Acceptor  1.2800e+20,   0.0302   # [ cm-3, eV ]
  Acceptor  1.3500e+20,   0.03   # [ cm-3, eV ]
  Acceptor  1.3900e+20,   0.0299   # [ cm-3, eV ]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

	gamma_1	= 6.85	# [1]
	gamma_2	= 2.1	# [1]
	gamma_3	= 2.9	# [1]
	so	= 0.34	# [eV]
	ep_te	= 28.8	# [eV]
	ep_tm	= 28.8	# [eV]
	cr	= 0.019	# [eV]
	A1	= -7.2400e+00	# [1]
	A2	= -5.1000e-01	# [1]
	A3	= 6.73	# [1]
	A4	= -3.3600e+00	# [1]
	A5	= -3.3500e+00	# [1]
	A6	= -4.7200e+00	# [1]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 3.8800e-15	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 1.16	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= -1.7000e+00	# [eV]
	c_11	= 11.879	# [1e-2 GPa]
	c_12	= 5.376	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
	Nc300	= 4.4200e+17	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
	Nv300	= 8.4700e+18	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.074	# [1]
	mh	= 0.62	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 8.5000e+03 ,	4.0000e+02	# [cm^2/(Vs)]
	Exponent	= 1 ,	2.1	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 8.5000e+03 ,	4.0000e+02	# [cm^2/(Vs)]
	Exponent	= 1 ,	2.1	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 2.1360e+03 ,	21.48	# [cm^2/Vs]
	Ar_alm  	= -7.4570e-01 ,	-1.1240e+00	# [1]
	Ar_mud  	= 6.3310e+03 ,	3.3120e+02	# [cm^2/Vs]
	Ar_ald  	= -2.6870e+00 ,	-2.3660e+00	# [1]
	Ar_N0   	= 7.3450e+16 ,	5.1360e+17	# [cm^(-3)]
	Ar_alN  	= 3.535 ,	3.69	# [1]
	Ar_a    	= 0.6273 ,	0.8057	# [1]
	Ar_ala  	= -1.4410e-01 ,	0.0000e+00	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 2.1360e+03 ,	21.48	# [cm^2/Vs]
	Ar_alm  	= -7.4570e-01 ,	-1.1240e+00	# [1]
	Ar_mud  	= 6.3310e+03 ,	3.3120e+02	# [cm^2/Vs]
	Ar_ald  	= -2.6870e+00 ,	-2.3660e+00	# [1]
	Ar_N0   	= 7.3450e+16 ,	5.1360e+17	# [cm^(-3)]
	Ar_alN  	= 3.535 ,	3.69	# [1]
	Ar_a    	= 0.6273 ,	0.8057	# [1]
	Ar_ala  	= -1.4410e-01 ,	0.0000e+00	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.1300e+07 ,	1.1300e+07	# [1]
	B_vsat	= 3.6000e+06 ,	3.6000e+06	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.1300e+07 ,	1.1300e+07	# [1]
	B_vsat	= 3.6000e+06 ,	3.6000e+06	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 13.18 ,	13.18	# [1]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 4.0000e+06 ,	1.3400e+06	# [1/cm]
	a(high)	= 4.0000e+06 ,	1.3400e+06	# [1/cm]
	b(low)	= 2.3000e+06 ,	2.0300e+06	# [V/cm]
	b(high)	= 2.3000e+06 ,	2.0300e+06	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 0.035 ,	0.035	# [eV]
	beta(low)	= 0.565912 ,	0.499479	# [1]
	beta(high)	= 0.565912 ,	0.499479	# [1]
	lambda	= 3.5000e-07 ,	3.5000e-07	# [cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 4.0000e+06 ,	1.3400e+06	# [1/cm]
	a(high)	= 4.0000e+06 ,	1.3400e+06	# [1/cm]
	b(low)	= 2.3000e+06 ,	2.0300e+06	# [V/cm]
	b(high)	= 2.3000e+06 ,	2.0300e+06	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 0.035 ,	0.035	# [eV]
	beta(low)	= 0.565912 ,	0.499479	# [1]
	beta(high)	= 0.565912 ,	0.499479	# [1]
	lambda	= 3.5000e-07 ,	3.5000e-07	# [cm]
}


BarrierTunneling  
{ * Non Local Barrier Tunneling 
  * G(r) = g*A*T/kB*F(r)*Pt(r)*ln[(1+exp((E(r)-Es)/kB/T))/(1+exp((E(r)-Em)/kB/T))]
  * where: 
  *     Pt(r) is WKB approximation for the tunneling probability 
  *     g = As/A, As is the Richardson constant for carriers in semiconductor
  *     A is the Richardson constant for free electrons 
  *     F(r) is the electric field 
  *     E(r) is carrier energy 
  *     Es is carrier quasi fermi energy in semiconductor
  *     Em is carrier fermi energy in metal 
  *     alpha is the prefactor for quantum potential correction 
  *     eoffset and hoffset are lists of band offsets
	g	= 0.068 ,	0.62	# [1]
	mt	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	eoffset = () # eV
	hoffset = () # eV
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 2.0000e-10	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}

MultiValley
{ * Arbitrary number of electron and hole valleys can be defined. 
  * Electron density is written as: n=Nc*sum{d_i*F1/2((Ef-Ec-dEc_i)/kT)}, 
  * where dEc_i is energy shift, d_i is DOS factor (defined by valley masses 
  * and degeneracy) of valley i. To specify one valley the energy shift 
  * in respect to band edge, degeneracy, non parabolicity, effective masses, 
  * and valley orientation should be defined. The interface quantization mass
  * (for MLDA model) will be compute automatically (using valley inverse mass 
  * tensor and interface orientation). If the quantization mass is specified, 
  * then it'll be independent of the interface orientation.
	eValley"Gamma"(m=0.065 energy=0.0000e+00 alpha=0.61 degeneracy=1 xid=-1.1000e+01) 
	eValley"L1"(1,1,1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L2"(-1.0000e+00,1,1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L3"(1,-1.0000e+00,1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L4"(1,1,-1.0000e+00)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"X1"(1,0.0000e+00,0.0000e+00)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	eValley"X2"(0.0000e+00,1,0.0000e+00)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	eValley"X3"(0.0000e+00,0.0000e+00,1)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	hValley"LH"(m=0.026 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(m=0.41 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
}

LatticeParameters
{ * Crystal system, elasticity, and deformation potential are defined.
  * X and Y vectors define the simulation coordinate system relative to the
  * crystal orientation system. Also there is an option to represent the crystal
  * system relative to the simulation one. In this case a keyword CrystalAxis 
  * has to be in this section and X and Y vectors will represent [100] and [010]
  * axis of the crystal system in the simulation one.
  * Additional notes: 1 Pa = 10 dyn/cm^2; tensile stress/strain is positive. 
  *  
  * S[i][j] - elasticity modulus; i,j = 1,2,...6 and j>=i.
  * CrystalSystem is symmetry, used ONLY to define the elasticity matrics.
  *   Cubic (CrystalSystem=0): S[1][1],S[1][2],S[4][4]
  *   Hexagonal (CrystalSystem=1): S[1][1],S[1][2],S[1][3],S[3][3],S[4][4]
  * 
	X	= (1, 0.0000e+00, 0.0000e+00) #[1]
	Y	= (0.0000e+00, 1, 0.0000e+00) #[1]
	S[1][1]	= 1.2	# [1e-12 cm^2/din]
	S[1][2]	= -3.6000e-01	# [1e-12 cm^2/din]
	S[4][4]	= 1.7	# [1e-12 cm^2/din]
	CrystalSystem	= 0	# [1]

  * Deformation potentials of 2 k.p model for electron delta-valleys 
	xis	= 0.0000e+00	# [eV]
	dbs	= 0.0000e+00	# [eV]
	xiu	= 9.3	# [eV]
	xid	= 1.1	# [eV]
	Mkp	= 1	# [1]

  * Deformation potentials of 6 k.p model for hole bands
	adp	= -8.5000e-01	# [eV]
	bdp	= -1.8500e+00	# [eV]
	ddp	= -5.1000e+00	# [eV]
	dso	= 0.347	# [eV]

  * Luttinger parameters
	gamma_1	= 7.02	# [1]
	gamma_2	= 2.27	# [1]
	gamma_3	= 2.99	# [1]

  * Deformation potentials and energy (in reference to delta-valley) for L-valleys 
	xiu_l	= 14.1	# [eV]
	xid_l	= -2.0000e+00	# [eV]
	e_l	= -1.9000e-01	# [eV]

  * Deformation potentials and energy (in reference to delta-valley) for Gamma-valley 
	xid_gamma	= -1.1000e+01	# [eV]
	e_gamma	= -4.8000e-01	# [eV]
}

StressMobility
{ * Stress-induced electron channel mobility model.
  * The model is based on 2 band k.p theory for electron bands and 
  * intervalley/intravelly scattering model with acoustic and optical phonons.
	Ephonon	= 0.03	# [eV]
	beta	= 1.22	# [1]
	beta_mlda	= (1.5, 1.5, 1.5) #[1]
	Nref	= 3.0000e+19	# [cm^-3]
	alpha	= 0.65	# [1]
	Dop	= 5.6000e+08	# [eV/cm]
	Dac_cl	= 1.2000e-05	# [eVs/cm]
  * 
  * Stress-induced change of delta2 electron mass proposed by TU Vienna.
  * The model is based on 2 band k.p theory for electron bands,
  * k.p parameters of the model are defined in LatticeParameters section. 
  * me_l0 and me_t0 are unstressed longitudinal and transverse effective masses:
	me_l0	= 1.714	# [1]
	me_t0	= 0.26	# [1]
  * 
  * Relaxed effective masses of electrons in L-valleys:
	me_l0_l	= 1.521	# [1]
	me_t0_l	= 0.129	# [1]
  * 
  * Relaxed effective mass of electrons in Gamma-valley:
	me0_gamma	= 0.065	# [1]
  * 
  * Stress-induced hole channel mobility model.
  * The model is based on 6 band k.p hole bands and MLDA channel quantization,
  * k.p parameters of the model are defined in LatticeParameters section. 
	Ephonon_h	= 0.03	# [eV]
	Dop_h	= 6.0000e+08	# [eV/cm]
	Dac_cl_h	= 1.0000e-05	# [eVs/cm]
	beta_h	= 1.0000e+10	# [1]
	beta_mlda_h	= (3, 1.5, 2.5) #[1]
	Nref_h	= 3.0000e+19	# [cm^-3]
	alpha_h	= 0.85	# [1]
  * 
  * Stress-induced hole mobility model is proposed by Intel:
  * the hole band structure in 100 plane is described by two ellipsoids directed in 
  * 110 and -110 directions, the multiplication factor of hole mobility in 110 direction
  * is the following:
  *             fh_110 = (f_110/mh_l0+f_'110/mh_t'110)/(0.5/mh_l0+0.5/mh_t0),
  * where:
  *   f_110 = 1/(1+exp(delta/kT), f_'110 = 1/(1+exp(-delta/kT) - occupation of
  *           the ellipsoids if just two (ne) considered in the hole band
  *   mh_l0 is the hole longitudinal mass in the ellipsoid at no stress
  *   mh_t0 is the hole transverse mass in the ellipsoid at no stress
  *   delta is stress-induced energy split between the ellipsoids
  * 
  *   delta = d1*s
  *   mh_t110 = mh_t0/(1-st1*s+st2*s^2+bt1*b+bt2*b^2)
  *   mh_t'110 = mh_t0/(1+st1*s+st2*s^2+bt1*b+bt2*b^2)
  *      (s is shear and b is biaxial components of the stress)
  * 
  * Modification of the Intel model:
  *   1) considered three 100 plans (6 ellipsoids)
  *   2) ne is number of ellipsoids in the occupation functions fh*
  *   3) considered mass in 100 direction: mh_t100 = mh_t0/(1+btt*b)
	mh_l0	= 0.48	# [1]
	mh_t0	= 0.15	# [1]
	d1	= -6.0000e-11	# [eV/Pa]
	st1	= -9.4426e-10	# [1/Pa]
	st2	= 4.3066e-19	# [1/Pa^2]
	bt1	= -1.0086e-10	# [1/Pa]
	bt2	= 6.5886e-21	# [1/Pa^2]
	btt	= 1.2000e-10	# [1/Pa]
	ne	= 2	# [1]
}


}

Material = "GaAsP" {
*  Mole dependent material: GaAsP (x=0) = GaP
*  Mole dependent material: GaAsP (x=1) = GaAs

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.33	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

JainRoulston
{ * deltaEg = A_i N^(1/3) + B_i N^(1/4) + C_i N^(1/2) + D_i N^(1/2)
  * where i is n for n-type or p for p-type
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A_n(0)	= 0.0000e+00	# [eV cm]
	A_n(1)	= 0.0000e+00	# [eV cm]
	B_n(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_n(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	A_p(0)	= 0.0000e+00	# [eV cm]
	A_p(1)	= 0.0000e+00	# [eV cm]
	B_p(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_p(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
}


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(GaP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "GaAsSb" {
*  Mole dependent material: GaAsSb (x=0) = GaAs
*  Mole dependent material: GaAsSb (x=1) = GaSb

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.5108	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 4.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(GaAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "GaInP" {
*  Mole dependent material: GaInP (x=0) = InP
*  Mole dependent material: GaInP (x=1) = GaP

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.22	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaP) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "GaInSb" {
*  Mole dependent material: GaInSb (x=0) = InSb
*  Mole dependent material: GaInSb (x=1) = GaSb

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaSb) + (1-x) * P(InSb)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "GaN" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 9.5	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 10.4	# [1]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

	gamma_1	= 6.85	# [1]
	gamma_2	= 2.1	# [1]
	gamma_3	= 2.9	# [1]
	so	= 0.014	# [eV]
	ep_te	= 18.8	# [eV]
	ep_tm	= 12.4	# [eV]
	cr	= 0.019	# [eV]
	A1	= -7.2400e+00	# [1]
	A2	= -5.1000e-01	# [1]
	A3	= 6.73	# [1]
	A4	= -3.3600e+00	# [1]
	A5	= -3.3500e+00	# [1]
	A6	= -4.7200e+00	# [1]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 0.0000e+00	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 0.19	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= 0.9163	# [eV]
	c_11	= 11.879	# [1e-2 GPa]
	c_12	= 5.376	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

TransferredElectronEffect2:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	mu1	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	E0	= 2.2089e+05 ,	4.0000e+03	# [V/cm]
	E1	= 2.2089e+05 ,	4.0000e+03	# [V/cm]
	alpha	= 0.7857 ,	0.0000e+00	# [1]
	beta	= 7.2044 ,	4	# [1]
	gamma	= 6.1973 ,	0.0000e+00	# [1]
}

TransferredElectronEffect2_aniso:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	mu1	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	E0	= 2.2089e+05 ,	4.0000e+03	# [V/cm]
	E1	= 2.2089e+05 ,	4.0000e+03	# [V/cm]
	alpha	= 0.7857 ,	0.0000e+00	# [1]
	beta	= 7.2044 ,	4	# [1]
	gamma	= 6.1973 ,	0.0000e+00	# [1]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 9.5 ,	9.5	# [1]
}

Piezoelectric_Polarization
{ * The 'strain' model computes the polarization vector as follows:
  * 
  *   [P_x]   [psp_x                                     ]
  *   [P_y] = [psp_y                                     ]
  *   [P_z]   [psp_z + 2*d31*strain*(c11+c12-2*c13^2/c33)] (Formula 1)
  *   [P_z]   [psp_z + 2*strain*(e31 - e33*c13/c33)      ] (Formula 2)
  * 
  *   strain = (1-relax)*(a0-a)/a
  * 
  * The 'stress' model computes the polarization vector as follows:
  * 
  *   [P_x]   [psp_x]   [d11 d12 d13 d14 d15 d16]   [stress_XX]
  *   [P_y] = [psp_y] + [d21 d22 d23 d24 d25 d26] * [stress_YY]
  *   [P_z]   [psp_z]   [d31 d32 d33 d34 d35 d36]   [stress_ZZ]
  *                                                 [stress_YZ]
  *                                                 [stress_XZ]
  *                                                 [stress_XY]
  * 
  * The Poisson equation is:
  * 
  *   div(eps*grad(phi)) = -ro + activation*div(P),
  *   where P = (P_x,P_y,P_z) - polarization vector
  * 
  * Parameters:
  * 
  *   activation: non negative real calibration parameter
  *               to scale the polarization charge [1], 
  *               this value can be set in a 'Physics' section of input file 
  * 
  *   [psp_x]: spontaneous polarization vector,
  *   [psp_y]  defined in crystal system [C/cm^2]
  *   [psp_z]
  * 
  *   c11, c12, c13, c33: stiffness constants,
  *                       defined in crystal system [Pa]
  * 
  *   e31, e33: strain-charge piezoelectric coefficients,
  *             defined in crystal system [C/cm^2]
  * 
  *   a0: strained lattice constant [Angstrem]
  *   a: unstrained lattice constant [Angstrem]
  *   relax: relaxation parameter [1]
  * 
  *   d11 ... d36: piezoelectric coefficients,
  *                defined in crystal system [cm/V]
  * 
  * Fields:
  * 
  *   [stress_XX]: stress tensor,
  *   [stress_YY]  defined in stress system [Pa]
  *   [stress_ZZ]
  *   [stress_YZ]
  *   [stress_XZ]
  *   [stress_XY]
  * 
  *   [P_x]: polarization vector,
  *   [P_y]  defined in simulation system [C/cm^2]
  *   [P_z]
  * 
  * Coordinate systems:
  * 
  *   The simulation system is defined relative to the crystal
  *   system.  For example:
  * 
  *     LatticeParameters {
  *       X = (1, 0,  0)
  *       Y = (0, 0, -1)
  *     }
  * 
  *   The stress coordinate system is defined relative to the simulation
  *   system.  For example:
  * 
  *     Physics {
  *       Piezo (
  *         OriKddX = (-0.96  0.28  0)
  *         OriKddY = ( 0.28  0.96  0)
  *         Stress = (1e9  2e9  3e9  4e9  5e9  6e9)  # [Pa]
  *       )
  *     }
  * 
  *   To compute the polarization vector, the stress tensor is first
  *   transformed from the stress system to the crystal system.  Then
  *   the polarization vector is evaluated according to the 'strain' or
  *   'stress' model above.  Finally, the polarization vector is transformed
  *   from the crystal system to the simulation system.
  * 
  * piezoelectric coefficients:
	d11	= 0.0000e+00	# [cm/V]
	d12	= 0.0000e+00	# [cm/V]
	d13	= 0.0000e+00	# [cm/V]
	d14	= 0.0000e+00	# [cm/V]
	d15	= -2.9000e-10	# [cm/V]
	d16	= 0.0000e+00	# [cm/V]
	d21	= 0.0000e+00	# [cm/V]
	d22	= 0.0000e+00	# [cm/V]
	d23	= 0.0000e+00	# [cm/V]
	d24	= -2.9000e-10	# [cm/V]
	d25	= 0.0000e+00	# [cm/V]
	d26	= 0.0000e+00	# [cm/V]
	d31	= -1.4000e-10	# [cm/V]
	d32	= -1.4000e-10	# [cm/V]
	d33	= 2.5000e-10	# [cm/V]
	d34	= 0.0000e+00	# [cm/V]
	d35	= 0.0000e+00	# [cm/V]
	d36	= 0.0000e+00	# [cm/V]
  * 
  * spontaneous polarization:
	psp_x	= 0.0000e+00	# [C/cm^2]
	psp_y	= 0.0000e+00	# [C/cm^2]
	psp_z	= -2.9000e-06	# [C/cm^2]
  * 
	Formula	= 1	# [1]
  * 
  * stiffness constants:
	c11	= 3.9000e+11	# [Pa]
	c12	= 1.4500e+11	# [Pa]
	c13	= 1.0600e+11	# [Pa]
	c33	= 3.9800e+11	# [Pa]
  * 
  * piezoelectric coefficients:
	e31	= -3.5000e-05	# [C/cm^2]
	e33	= 1.2700e-04	# [C/cm^2]
  * 
  * strain parameters:
	a0	= 3.189	# [Angstrem]
	a	= 3.189	# [Angstrem]
	relax	= 0.1	# [1]
}


}

Material = "GaP" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 10.2	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 10.2	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 3.33	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.33	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 4	# [eV]
	Eg0	= 2.4	# [eV]
	alpha	= 5.4000e-04	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

	gamma_1	= 4.05	# [1]
	gamma_2	= 0.49	# [1]
	gamma_3	= 1.25	# [1]
	so	= 0.08	# [eV]
	ep_te	= 31.4	# [eV]
	ep_tm	= 31.4	# [eV]
	cr	= 0.019	# [eV]
	A1	= -7.2400e+00	# [1]
	A2	= -5.1000e-01	# [1]
	A3	= 6.73	# [1]
	A4	= -3.3600e+00	# [1]
	A5	= -3.3500e+00	# [1]
	A6	= -4.7200e+00	# [1]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 2.9200e-15	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 1.7	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= -1.8000e+00	# [eV]
	c_11	= 14.05	# [1e-2 GPa]
	c_12	= 6.203	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
	Nc300	= 1.7800e+18	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
	Nv300	= 1.9200e+19	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.14	# [1]
	mh	= 0.79	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.1000e+02 ,	75	# [cm^2/(Vs)]
	Exponent	= 1.5 ,	1.5	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.1000e+02 ,	75	# [cm^2/(Vs)]
	Exponent	= 1.5 ,	1.5	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 1.1000e+02 ,	75	# [cm^2/Vs]
	Ar_alm  	= -1.5000e+00 ,	-1.5000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 1.1000e+02 ,	75	# [cm^2/Vs]
	Ar_alm  	= -1.5000e+00 ,	-1.5000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.0000e+07 ,	1.0000e+07	# [1]
	B_vsat	= 0.0000e+00 ,	0.0000e+00	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.0000e+07 ,	1.0000e+07	# [1]
	B_vsat	= 0.0000e+00 ,	0.0000e+00	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 10.2 ,	10.2	# [1]
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}


}

Material = "Gas" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 1	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 1	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1	# [1]
	alpha	= 0.0000e+00	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 0.0000e+00	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.0000e-10	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.0000e-10	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 0.0000e+00	# [eV]
	Eg0	= 20	# [eV]
	alpha	= 0.0000e+00	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 1	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}

Absorption
{ * Formula = 1:
  * A = A1*exp((phE-E1)/E2),     for phE < E1 
  *   = A1 + A2*((phE-E1)/E2)^P, for phE >= E1 
  * Formula = 2:
  * A = A0*exp((phE-phE0)*ST),              for phE < phE0 
  *   = AT*(2*ST*(phE-E0-(LN-0.5)/ST))^0.5, for phE >= phE0 
  * where 
  *      phE is a photon energy, 
  *      LN = log(AT/A0), 
  *      ST = S/(T+T0), T is a temperature, 
  *      phE0 = E0 + LN/ST. 

	Formula	= 1	# [1]
  * Formula = 1:
	A1	= 0.0000e+00	# [cm-1]
	A2	= 0.0000e+00	# [cm-1]
	E1	= 0.0000e+00	# [eV]
	E2	= 1	# [eV]
	P	= 0.0000e+00	# [1]
}


}

Material = "GaSb" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "GatePolySilicon" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 11.7	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 11.7	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 3.45	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.45	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 3.7100e-18 ,	3.3300e-18	# [cm^2]
	Gamma_k_carr	= 3 ,	3	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.2101	1.0922	2.8831;
          0.2119	1.1009	2.90361;
          0.2138	1.1184	2.9315;
          0.2156	1.14237	2.96529;
          0.2175	1.1705	3.0035;
          0.2194	1.19797	3.04419;
          0.2214	1.2299	3.0872;
          0.2234	1.2698	3.13376;
          0.2254	1.3177	3.1778;
          0.2275	1.3785	3.21564;
          0.2296	1.4411	3.2413;
          0.2317	1.49894	3.2415;
          0.2339	1.5433	3.2345;
          0.2362	1.55796	3.23247;
          0.2384	1.5588	3.2404;
          0.2407	1.55514	3.26932;
          0.2431	1.5504	3.3133;
          0.2455	1.55126	3.3704;
          0.248	1.5572	3.4397;
          0.2505	1.56976	3.51967;
          0.253	1.5894	3.6102;
          0.2556	1.61655	3.70929;
          0.2583	1.6528	3.8211;
          0.261	1.6961	3.94773;
          0.2638	1.7578	4.0934;
          0.2666	1.84299	4.26904;
          0.2695	1.9684	4.4566;
          0.2725	2.15662	4.64815;
          0.2755	2.3952	4.8243;
          0.2786	2.67333	4.96418;
          0.2818	3.0086	5.0643;
          0.285	3.4429	5.14668;
          0.2883	3.8925	5.1139;
          0.2917	4.30741	4.81355;
          0.2952	4.6283	4.4327;
          0.2988	4.7398	4.11512;
          0.3024	4.7601	3.8384;
          0.3061	4.77064	3.63769;
          0.31	4.7663	3.4841;
          0.3139	4.76873	3.36293;
          0.3179	4.779	3.2667;
          0.322	4.80814	3.18317;
          0.3263	4.8479	3.1119;
          0.3306	4.89223	3.04714;
          0.3351	4.9456	2.9925;
          0.3397	5.00374	2.94735;
          0.3444	5.0868	2.9186;
          0.3493	5.19221	2.93819;
          0.3542	5.3839	2.9304;
          0.3594	5.80733	2.86335;
          0.3647	6.2153	2.6374;
          0.3701	6.38979	2.02886;
          0.3757	6.3887	1.378;
          0.3815	6.14004	0.998007;
          0.3875	5.8155	0.7465;
          0.3936	5.58197	0.598994;
          0.3999	5.3818	0.515;
          0.4065	5.21597	0.44355;
          0.4133	5.0755	0.3916;
          0.4203	4.95259	0.349431;
          0.4275	4.8447	0.3161;
          0.435	4.74682	0.287837;
          0.4428	4.6586	0.2634;
          0.4509	4.57823	0.240775;
          0.4592	4.505	0.2185;
          0.4679	4.43795	0.192556;
          0.4769	4.376	0.1686;
          0.4862	4.31774	0.15245;
          0.4959	4.2632	0.1396;
          0.5061	4.212	0.127413;
          0.5166	4.1639	0.1161;
          0.5276	4.11859	0.105156;
          0.5391	4.0759	0.0941;
          0.551	4.03563	0.081281;
          0.5636	3.9975	0.0697;
          0.5767	3.96109	0.063163;
          0.5904	3.9266	0.0576;
          0.6048	3.89436	0.049456;
          0.6199	3.8636	0.041;
          0.6358	3.83326	0.033381;
          0.6525	3.8045	0.0264;
          0.6702	3.77842	0.020056;
          0.6888	3.7542	0.0149;
          0.7085	3.73137	0.011813;
          0.7293	3.71	9.8000e-03;
          0.7514	3.69049	8.1750e-03;
          0.7749	3.6714	6.9000e-03;
          0.7999	3.65111	5.6310e-03;
          0.8266	3.6305	4.6000e-03;
          0.8551	3.60901	4.0130e-03;
          0.8856	3.5894	3.6000e-03;
          0.9184	3.57576	3.1440e-03;
          0.9537	3.5636	2.7000e-03;
          0.9919	3.54898	2.1940e-03;
          1.033	3.5344	1.8000e-03;
          1.078	3.52153	1.8000e-03;
          1.127	3.5089	1.8000e-03;
          1.181	3.49585	1.5750e-03;
          1.24	3.4817	9.0000e-04;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.63	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.5	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.5	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 4.25	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}


OldSlotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
	Ebgn	= 9.0000e-03	# [eV]
	Nref	= 1.0000e+17	# [cm^(-3)]
	C	= 0.5	# [1]
}


Slotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
	Ebgn	= 6.9200e-03	# [eV]
	Nref	= 1.3000e+17	# [cm^(-3)]
	C	= 0.5	# [1]
}

delAlamo
{ * deltaEg = dEg0 + Ebgn  ln(N/Nref) 
  * dEg0 is defined in BandGap section 
	Ebgn	= 0.0187	# [eV]
	Nref	= 7.0000e+17	# [cm^(-3)]
}

Bennett
{ * deltaEg = dEg0 + Ebgn (ln(N/Nref))^2
  * dEg0 is defined in BandGap section 
	Ebgn	= 6.8400e-03	# [eV]
	Nref	= 3.1620e+18	# [cm^(-3)]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 0.0000e+00	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 0.19	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= 0.9163	# [eV]
	c_11	= 11.879	# [1e-2 GPa]
	c_12	= 5.376	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.1905	# [1]
	ml	= 0.9163	# [1]
	mm	= 0.0000e+00	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0.443587	# [1]
	b	= 0.003609528	# [K^-1]
	c	= 0.0001173515	# [K^-2]
	d	= 1.263218e-06	# [K^-3]
	e	= 3.025581e-09	# [K^-4]
	f	= 0.004683382	# [K^-1]
	g	= 0.0002286895	# [K^-2]
	h	= 7.469271e-07	# [K^-3]
	i	= 1.727481e-09	# [K^-4]
	mm	= 0	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 1 ,	1	# [1]
  * Formula(hole) 1 parameters:
	A	= 4.22	# [1]
	B	= 0.6084	# [1]
	C	= 23.058	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 3.6 ,	5.6	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 1 ,	1	# [1]
	eta	= 1 ,	1	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.4170e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.5 ,	2.2	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.4170e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.5 ,	2.2	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 1 ,	1	# [1]
  * If formula=1, model suggested by Masetti et al. is used:
  * mu_dop = mumin1 exp(-Pc/N) + (mu_const - mumin2)/(1+(N/Cr)^alpha)
  *                             - mu1/(1+(Cs/N)^beta)
  * with mu_const from ConstantMobility
	mumin1	= 52.2 ,	44.9	# [cm^2/Vs]
	mumin2	= 52.2 ,	0.0000e+00	# [cm^2/Vs]
	mu1	= 43.4 ,	29	# [cm^2/Vs]
	Pc	= 0.0000e+00 ,	9.2300e+16	# [cm^3]
	Cr	= 9.6800e+16 ,	2.2300e+17	# [cm^3]
	Cs	= 3.4300e+20 ,	6.1000e+20	# [cm^3]
	alpha	= 0.68 ,	0.719	# [1]
	beta	= 2 ,	2	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 1 ,	1	# [1]
  * If formula=1, model suggested by Masetti et al. is used:
  * mu_dop = mumin1 exp(-Pc/N) + (mu_const - mumin2)/(1+(N/Cr)^alpha)
  *                             - mu1/(1+(Cs/N)^beta)
  * with mu_const from ConstantMobility
	mumin1	= 52.2 ,	44.9	# [cm^2/Vs]
	mumin2	= 52.2 ,	0.0000e+00	# [cm^2/Vs]
	mu1	= 43.4 ,	29	# [cm^2/Vs]
	Pc	= 0.0000e+00 ,	9.2300e+16	# [cm^3]
	Cr	= 9.6800e+16 ,	2.2300e+17	# [cm^3]
	Cs	= 3.4300e+20 ,	6.1000e+20	# [cm^3]
	alpha	= 0.68 ,	0.719	# [1]
	beta	= 2 ,	2	# [1]
}

ThinLayerMobility:
{ * Mobility model for thin layers with geometric
  * quantization.  See the manual for details.
	beta	= 4 ,	4	# [1]
	zeta	= 2.88 ,	1.05	# [1]
	p1	= 0.55 ,	0.0000e+00	# [1]
	p2	= 4.0000e+02 ,	0.66	# [1]
	p3	= 1.44 ,	1	# [1]
	mz1	= 0.916 ,	0.29	# [m0]
	mz2	= 0.19 ,	0.25	# [m0]
	wt01	= 3.0000e-06 ,	0.0000e+00	# [um]
	wt02	= 3.5000e-07 ,	0.0000e+00	# [um]
	muac01	= 3.1500e+02 ,	30.2	# [cm^2/(Vs)]
	muac02	= 6.4 ,	69	# [cm^2/(Vs)]
	mutf0	= 0.15 ,	0.28	# [cm^2/(Vs)]
	musp0	= 1.1450e-08 ,	1.6000e-10	# [cm^2/(Vs)]
	tsp0	= 1.0000e-04 ,	1.0000e-04	# [um]
	ftf0	= 6.2500e+03 ,	1.0000e+100	# [V/cm]
	tmin	= 2.0000e-03 ,	2.0000e-03	# [um]
	eta1	= 6 ,	6	# [1]
	eta2	= 1 ,	1	# [1]
	mutfh0	= 1.0000e+06 ,	1.0000e+06	# [cm^2/(Vs)]
	ftfh0	= 1.0000e+100 ,	1.0000e+100	# [V/cm]
	a_bp	= 1 ,	1	# [1]
	a_sp	= 1 ,	1	# [1]
	a_tf	= 1 ,	1	# [1]
}

ThinLayerMobility_aniso:
{ * Mobility model for thin layers with geometric
  * quantization.  See the manual for details.
	beta	= 4 ,	4	# [1]
	zeta	= 2.88 ,	1.05	# [1]
	p1	= 0.55 ,	0.0000e+00	# [1]
	p2	= 4.0000e+02 ,	0.66	# [1]
	p3	= 1.44 ,	1	# [1]
	mz1	= 0.916 ,	0.29	# [m0]
	mz2	= 0.19 ,	0.25	# [m0]
	wt01	= 3.0000e-06 ,	0.0000e+00	# [um]
	wt02	= 3.5000e-07 ,	0.0000e+00	# [um]
	muac01	= 3.1500e+02 ,	30.2	# [cm^2/(Vs)]
	muac02	= 6.4 ,	69	# [cm^2/(Vs)]
	mutf0	= 0.15 ,	0.28	# [cm^2/(Vs)]
	musp0	= 1.1450e-08 ,	1.6000e-10	# [cm^2/(Vs)]
	tsp0	= 1.0000e-04 ,	1.0000e-04	# [um]
	ftf0	= 6.2500e+03 ,	1.0000e+100	# [V/cm]
	tmin	= 2.0000e-03 ,	2.0000e-03	# [um]
	eta1	= 6 ,	6	# [1]
	eta2	= 1 ,	1	# [1]
	mutfh0	= 1.0000e+06 ,	1.0000e+06	# [cm^2/(Vs)]
	ftfh0	= 1.0000e+100 ,	1.0000e+100	# [V/cm]
	a_bp	= 1 ,	1	# [1]
	a_sp	= 1 ,	1	# [1]
	a_tf	= 1 ,	1	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 1.109 ,	1.213	# [1]
	betaexp	= 0.66 ,	0.17	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 1.0700e+07 ,	8.3700e+06	# [1]
	vsatexp	= 0.87 ,	0.52	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 1.109 ,	1.213	# [1]
	betaexp	= 0.66 ,	0.17	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 1.0700e+07 ,	8.3700e+06	# [1]
	vsatexp	= 0.87 ,	0.52	# [1]
}

UniBoDopingDependence:
{
  * Baccarani model (University of Bologna) is used:
  * Constant mobility model is defined here as well:
  * mu_const = mumax (T/T0)^(-Exponent+Exponent2*(T/T0))
  * mu_dop = mu_0(Na,Nd,T/T0)                                               
  *         + (mu_const - mu_0)/(1 + (Nd/Cr)^alpha + (Na/Cr2)^beta)         
  *         - mu_1(Na,Nd,T/T0)/(1+(Nd/Cs + Na/Cs2)^(-2))                    
  * with mu_const from above
  * mu_0 = (mumin1 (T/T0)^(-mumin1_exp) Nd + mumin2 (T/T0)^(-mumin2_exp)Na)/(Nd+Na)
  * mu_1 = (mu1 (T/T0)^(-mu1_exp) Nd + mu2 (T/T0)^(-mu2_exp) Na)/(Nd+Na)
  * Cr=Cr (T/T0)^Cr_exp
  * Cr2=Cr2 (T/T0)^Cr2_exp
  * Cs=Cs (T/T0)^Cs_exp
	mumax	= 1.4410e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.45 ,	2.16	# [1]
	Exponent2	= -1.1000e-01 ,	0.0000e+00	# [1]
	mumin1	= 55 ,	90	# [cm^2/Vs]
	mumin2	= 1.3200e+02 ,	44	# [cm^2/Vs]
	mumin1_exp	= 0.6 ,	1.3	# [1]
	mumin2_exp	= 1.3 ,	0.7	# [1]
	mu1	= 42.4 ,	28.2	# [cm^2/Vs]
	mu2	= 73.5 ,	28.2	# [cm^2/Vs]
	mu1_exp	= 0.5 ,	2	# [1]
	mu2_exp	= 1.25 ,	0.8	# [1]
	Pc	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	Cr	= 8.9000e+16 ,	1.3000e+18	# [cm^3]
	Cr2	= 1.2200e+17 ,	2.4500e+17	# [cm^3]
	Cs	= 2.9000e+20 ,	1.1000e+18	# [cm^3]
	Cs2	= 7.0000e+20 ,	6.1000e+20	# [cm^3]
	Cr_exp	= 3.65 ,	2.2	# [1]
	Cr2_exp	= 2.65 ,	3.1	# [1]
	Cs_exp	= 0.0000e+00 ,	6.2	# [1]
	alpha	= 0.68 ,	0.77	# [1]
	beta	= 0.72 ,	0.719	# [1]
}

UniBoDopingDependence_aniso:
{
  * Baccarani model (University of Bologna) is used:
  * Constant mobility model is defined here as well:
  * mu_const = mumax (T/T0)^(-Exponent+Exponent2*(T/T0))
  * mu_dop = mu_0(Na,Nd,T/T0)                                               
  *         + (mu_const - mu_0)/(1 + (Nd/Cr)^alpha + (Na/Cr2)^beta)         
  *         - mu_1(Na,Nd,T/T0)/(1+(Nd/Cs + Na/Cs2)^(-2))                    
  * with mu_const from above
  * mu_0 = (mumin1 (T/T0)^(-mumin1_exp) Nd + mumin2 (T/T0)^(-mumin2_exp)Na)/(Nd+Na)
  * mu_1 = (mu1 (T/T0)^(-mu1_exp) Nd + mu2 (T/T0)^(-mu2_exp) Na)/(Nd+Na)
  * Cr=Cr (T/T0)^Cr_exp
  * Cr2=Cr2 (T/T0)^Cr2_exp
  * Cs=Cs (T/T0)^Cs_exp
	mumax	= 1.4410e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.45 ,	2.16	# [1]
	Exponent2	= -1.1000e-01 ,	0.0000e+00	# [1]
	mumin1	= 55 ,	90	# [cm^2/Vs]
	mumin2	= 1.3200e+02 ,	44	# [cm^2/Vs]
	mumin1_exp	= 0.6 ,	1.3	# [1]
	mumin2_exp	= 1.3 ,	0.7	# [1]
	mu1	= 42.4 ,	28.2	# [cm^2/Vs]
	mu2	= 73.5 ,	28.2	# [cm^2/Vs]
	mu1_exp	= 0.5 ,	2	# [1]
	mu2_exp	= 1.25 ,	0.8	# [1]
	Pc	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	Cr	= 8.9000e+16 ,	1.3000e+18	# [cm^3]
	Cr2	= 1.2200e+17 ,	2.4500e+17	# [cm^3]
	Cs	= 2.9000e+20 ,	1.1000e+18	# [cm^3]
	Cs2	= 7.0000e+20 ,	6.1000e+20	# [cm^3]
	Cr_exp	= 3.65 ,	2.2	# [1]
	Cr2_exp	= 2.65 ,	3.1	# [1]
	Cs_exp	= 0.0000e+00 ,	6.2	# [1]
	alpha	= 0.68 ,	0.77	# [1]
	beta	= 0.72 ,	0.719	# [1]
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}

Absorption
{ * Formula = 1:
  * A = A1*exp((phE-E1)/E2),     for phE < E1 
  *   = A1 + A2*((phE-E1)/E2)^P, for phE >= E1 
  * Formula = 2:
  * A = A0*exp((phE-phE0)*ST),              for phE < phE0 
  *   = AT*(2*ST*(phE-E0-(LN-0.5)/ST))^0.5, for phE >= phE0 
  * where 
  *      phE is a photon energy, 
  *      LN = log(AT/A0), 
  *      ST = S/(T+T0), T is a temperature, 
  *      phE0 = E0 + LN/ST. 

	Formula	= 1	# [1]
  * Formula = 1:
	A1	= 1.0000e+04	# [cm-1]
	A2	= 100	# [cm-1]
	E1	= 1.12	# [eV]
	E2	= 0.025	# [eV]
	P	= 0.5	# [1]
}


}

Material = "Germanium" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 15.8	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 15.8	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.216	1.273	2.874;
          0.217	1.28619	2.86826;
          0.218	1.30387	2.86251;
          0.219	1.32635	2.85677;
          0.22	1.34662	2.85135;
          0.221	1.35618	2.84753;
          0.222	1.363	2.845;
          0.223	1.36801	2.84333;
          0.224	1.37299	2.842;
          0.225	1.37791	2.842;
          0.226	1.38162	2.84362;
          0.227	1.38443	2.84643;
          0.228	1.38679	2.84926;
          0.229	1.38442	2.85222;
          0.23	1.38207	2.85756;
          0.232	1.37742	2.87539;
          0.233	1.37419	2.88636;
          0.234	1.37087	2.89803;
          0.236	1.36714	2.92865;
          0.237	1.36557	2.94548;
          0.238	1.36447	2.96471;
          0.239	1.36441	2.9812;
          0.241	1.36585	3.01001;
          0.242	1.36766	3.03797;
          0.243	1.36978	3.06964;
          0.244	1.37371	3.09554;
          0.246	1.382	3.14599;
          0.248	1.39424	3.19789;
          0.251	1.41717	3.28258;
          0.253	1.43475	3.34115;
          0.256	1.46815	3.43388;
          0.257	1.48094	3.46636;
          0.258	1.49406	3.49915;
          0.259	1.50827	3.53361;
          0.261	1.53763	3.60395;
          0.262	1.55373	3.64042;
          0.263	1.57169	3.6786;
          0.264	1.59036	3.71755;
          0.267	1.65456	3.84331;
          0.268	1.67981	3.88885;
          0.269	1.70606	3.93533;
          0.27	1.73567	3.98463;
          0.273	1.8359	4.14212;
          0.274	1.8816	4.20305;
          0.275	1.92856	4.26484;
          0.276	1.98816	4.32869;
          0.279	2.20813	4.5269;
          0.28	2.3124	4.58054;
          0.281	2.42664	4.63017;
          0.282	2.54518	4.66811;
          0.285	2.94717	4.65578;
          0.286	3.07437	4.6353;
          0.288	3.30015	4.52542;
          0.289	3.38606	4.45813;
          0.292	3.60296	4.23755;
          0.293	3.65651	4.16545;
          0.295	3.73694	4.02325;
          0.296	3.76219	3.96172;
          0.299	3.82671	3.78431;
          0.3	3.84271	3.73066;
          0.302	3.86461	3.63346;
          0.303	3.8726	3.59024;
          0.306	3.89064	3.47134;
          0.307	3.89632	3.43247;
          0.309	3.90218	3.3673;
          0.31	3.90509	3.33494;
          0.314	3.91441	3.22731;
          0.315	3.9164	3.20188;
          0.317	3.91887	3.15726;
          0.318	3.92018	3.1351;
          0.322	3.92824	3.05215;
          0.323	3.93022	3.03224;
          0.326	3.93552	2.98987;
          0.327	3.9378	2.97532;
          0.331	3.94774	2.91648;
          0.332	3.95023	2.90269;
          0.335	3.95777	2.86419;
          0.336	3.96063	2.85248;
          0.34	3.97222	2.80614;
          0.341	3.97512	2.79494;
          0.344	3.98384	2.76323;
          0.345	3.98705	2.75315;
          0.35	4.00419	2.70432;
          0.351	4.00786	2.69534;
          0.354	4.0191	2.6691;
          0.355	4.02344	2.66061;
          0.36	4.0461	2.61853;
          0.361	4.05101	2.61007;
          0.364	4.06658	2.5846;
          0.365	4.07187	2.57578;
          0.371	4.10485	2.51899;
          0.372	4.10986	2.50857;
          0.375	4.12453	2.47657;
          0.376	4.12892	2.46579;
          0.382	4.14789	2.39938;
          0.383	4.15049	2.38838;
          0.387	4.15634	2.3449;
          0.388	4.1567	2.33421;
          0.394	4.15346	2.271;
          0.395	4.15266	2.26065;
          0.399	4.14324	2.22375;
          0.4	4.14078	2.21467;
          0.407	4.11063	2.16944;
          0.408	4.10628	2.16345;
          0.413	4.08329	2.14598;
          0.414	4.07944	2.14415;
          0.421	4.05454	2.13585;
          0.422	4.05126	2.13525;
          0.427	4.03837	2.13954;
          0.428	4.03664	2.14114;
          0.436	4.03044	2.16063;
          0.437	4.03035	2.16333;
          0.442	4.03436	2.17856;
          0.443	4.03547	2.1817;
          0.452	4.05682	2.21326;
          0.453	4.0598	2.21688;
          0.459	4.08128	2.23925;
          0.46	4.08591	2.24314;
          0.469	4.12989	2.2785;
          0.47	4.13536	2.28241;
          0.476	4.17439	2.30566;
          0.477	4.18106	2.30954;
          0.488	4.26602	2.35251;
          0.489	4.27516	2.35647;
          0.495	4.33124	2.38028;
          0.496	4.34074	2.38423;
          0.508	4.48046	2.42851;
          0.509	4.49512	2.43167;
          0.516	4.60092	2.45316;
          0.517	4.61823	2.45437;
          0.529	4.86554	2.43534;
          0.53	4.88597	2.43207;
          0.539	5.0608	2.31878;
          0.54	5.07084	2.30546;
          0.553	5.19328	2.13169;
          0.554	5.20222	2.12123;
          0.563	5.27823	2.05326;
          0.564	5.29047	2.04555;
          0.579	5.54773	1.92689;
          0.58	5.56516	1.90732;
          0.59	5.74095	1.64453;
          0.591	5.75432	1.6173;
          0.604	5.89155	1.25496;
          0.605	5.88711	1.22708;
          0.607	5.75758	1.17134;
          0.608	5.70569	1.14582;
          0.619	5.59709	0.949441;
          0.62	5.58756	0.931642;
          0.635	5.50452	0.67402;
          0.636	5.49868	0.658683;
          0.652	5.38393	0.543933;
          0.653	5.37565	0.539936;
          0.67	5.21178	0.53754;
          0.671	5.19702	0.537399;
          0.673	5.16517	0.537117;
          0.674	5.15102	0.536573;
          0.688	5.07155	0.501979;
          0.689	5.06622	0.499414;
          0.708	4.99188	0.443418;
          0.709	4.9863	0.440471;
          0.712	4.96494	0.431629;
          0.713	4.95929	0.429226;
          0.729	4.89822	0.401551;
          0.73	4.89493	0.400055;
          0.756	4.816	0.364002;
          0.775	4.76274	0.344905;
          0.805	4.68424	0.316088;
          0.806	4.68269	0.315239;
          0.826	4.65381	0.298471;
          0.827	4.65231	0.297876;
          0.885	4.56095	0.28145;
          0.886	4.55962	0.281166;
          1.033	4.42019	0.239535;
          1.034	4.4197	0.239251;
          1.2	4.35682	0.192239;
          1.24	4.32495	0.18091;
          1.377	4.28517	0.142111;
          1.378	4.28417	0.141827;
          1.4	4.2384	0.135597;
          1.501	4.20515	0.106993;
          1.502	4.20482	0.106709;
          1.503	4.20449	0.106426;
          1.507	4.20317	0.105293;
          1.508	4.20284	0.10501;
          1.511	4.20186	0.10416;
          1.512	4.20153	0.103877;
          1.516	4.20021	0.102744;
          1.517	4.19988	0.102461;
          1.521	4.19856	0.101328;
          1.522	4.19823	0.101045;
          1.526	4.19692	0.099912;
          1.527	4.19659	0.099629;
          1.533	4.19461	0.09793;
          1.534	4.19428	0.097647;
          1.544	4.19099	0.094814;
          1.545	4.19066	0.094531;
          1.554	4.1877	0.091982;
          1.565	4.18408	0.088867;
          1.575	4.18078	0.086035;
          1.576	4.18045	0.085752;
          1.586	4.17716	0.08292;
          1.587	4.17683	0.082637;
          1.597	4.17354	0.079804;
          1.6	4.17262	0.078955;
          1.608	4.17262	0.076689;
          1.617	4.17262	0.07414;
          1.618	4.17262	0.073857;
          1.628	4.17262	0.071025;
          1.629	4.17262	0.070742;
          1.631	4.17262	0.070175;
          1.638	4.17101	0.068193;
          1.639	4.17077	0.06791;
          1.649	4.16834	0.065077;
          1.65	4.16809	0.064794;
          1.671	4.16299	0.058847;
          1.682	4.16032	0.055732;
          1.691	4.15813	0.053183;
          1.692	4.15789	0.0529;
          1.703	4.15521	0.049784;
          1.712	4.15303	0.047235;
          1.723	4.15035	0.04412;
          1.724	4.15011	0.043837;
          1.735	4.14744	0.040722;
          1.744	4.14525	0.038173;
          1.755	4.14258	0.035057;
          1.756	4.14233	0.034774;
          1.765	4.14015	0.032225;
          1.776	4.13747	0.02911;
          1.798	4.13213	0.022879;
          1.8	4.13164	0.022313;
          1.808	4.13218	0.020047;
          1.828	4.13352	0.014383;
          1.839	4.13426	0.011268;
          1.85	4.135	8.1520e-03;
          1.879	4.13153	6.6842e-05;
          1.88	4.13141	6.5826e-05;
          1.938	4.12407	7.6692e-06;
          1.939	4.12394	7.6146e-06;
          2.066	4.10808	6.8001e-07;
          2.066	4.10808	6.8001e-07;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.66667	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.66667	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 3.95988	# [eV]
	Eg0	= 0.744	# [eV]
	alpha	= 4.7700e-04	# [eV K^-1]
	beta	= 2.3500e+02	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

JainRoulston
{ * deltaEg = A_i N^(1/3) + B_i N^(1/4) + C_i N^(1/2) + D_i N^(1/2)
  * where i is n for n-type or p for p-type
	A_n	= 7.3000e-09	# [eV cm]
	A_p	= 8.2100e-09	# [eV cm]
	B_n	= 2.5700e-07	# [eV cm^(3/4)]
	B_p	= 2.9100e-07	# [eV cm^(3/4)]
	C_n	= 2.2900e-12	# [eV cm^(3/2)]
	C_p	= 3.5800e-12	# [eV cm^(3/2)]
	D_n	= 2.0300e-12	# [eV cm^(3/2)]
	D_p	= 2.1900e-12	# [eV cm^(3/2)]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.55	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 0.382	# [1]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 3.9000e+03 ,	1.9000e+03	# [cm^2/(Vs)]
	Exponent	= 1.6 ,	2.3	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 3.9000e+03 ,	1.9000e+03	# [cm^2/(Vs)]
	Exponent	= 1.6 ,	2.3	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 3.9000e+03 ,	1.9000e+03	# [cm^2/Vs]
	Ar_alm  	= -1.6000e+00 ,	-2.3000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 3.9000e+03 ,	1.9000e+03	# [cm^2/Vs]
	Ar_alm  	= -1.6000e+00 ,	-2.3000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 1.109 ,	1.213	# [1]
	betaexp	= 0.66 ,	0.17	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 7.4300e+06 ,	7.4300e+06	# [1]
	vsatexp	= 0.87 ,	0.52	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 1.109 ,	1.213	# [1]
	betaexp	= 0.66 ,	0.17	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 7.4300e+06 ,	7.4300e+06	# [1]
	vsatexp	= 0.87 ,	0.52	# [1]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 15.8 ,	15.8	# [1]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 8.5500e+06 ,	2.8000e+06	# [1/cm]
	a(high)	= 8.5500e+06 ,	2.8000e+06	# [1/cm]
	b(low)	= 1.4200e+06 ,	1.0000e+06	# [V/cm]
	b(high)	= 1.4200e+06 ,	1.0000e+06	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 0.037 ,	0.037	# [eV]
	beta(low)	= 1.39057 ,	0.979274	# [1]
	beta(high)	= 1.39057 ,	0.979274	# [1]
	lambda	= 6.5000e-07 ,	6.5000e-07	# [cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 8.5500e+06 ,	2.8000e+06	# [1/cm]
	a(high)	= 8.5500e+06 ,	2.8000e+06	# [1/cm]
	b(low)	= 1.4200e+06 ,	1.0000e+06	# [V/cm]
	b(high)	= 1.4200e+06 ,	1.0000e+06	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 0.037 ,	0.037	# [eV]
	beta(low)	= 1.39057 ,	0.979274	# [1]
	beta(high)	= 1.39057 ,	0.979274	# [1]
	lambda	= 6.5000e-07 ,	6.5000e-07	# [cm]
}

Band2BandTunneling 
{ * See Sentaurus Device manual `Band-To-Band Tunneling' 
	A	= 8.9770e+20	# [1/cm/sec/V^2]
	B	= 2.1466e+07	# [V/cm/eV^1.5]
	hbarOmega	= 0.0186	# [eV]

  * Traditional models for the following keywords in input file:
  * Band2Band(E1)  : A1*E*exp(-B1/E)
  * Band2Band(E1_5): A1_5*E^1.5*exp(-B1_5/E)
  * Band2Band(E2)  : A2*E^2*exp(-B2/E)
	A1	= 1.1000e+27	# [1/cm^2/sec/V]
	B1	= 2.1300e+07	# [V/cm]
	A1_5	= 1.9000e+24	# [1/cm^1.5/sec/V^1.5]
	B1_5	= 2.1900e+07	# [V/cm]
	A2	= 3.5000e+21	# [1/cm/sec/V^2]
	B2	= 2.2500e+07	# [V/cm]

  * Hurkx model for the following keywords in input file:
  * Band2Band(Hurkx)  : -Agen*D*(E/E0)^Pgen*exp(-Bgen*(Eg/Eg300)^1.5/E) if D < 0
  *                     -Arec*D*(E/E0)^Prec*exp(-Brec*(Eg/Eg300)^1.5/E) if D > 0
  *                     D = (n*p-ni^2)/(n+ni)/(p+ni)*(1-|alpha|)+alpha, E0 = 1 V/cm
  *                     So, if alpha = 0, it's original Hurkx model,
  *                         if alpha = -1, it's only generation,
  *                         if alpha = +1, it's only recombination.
	Agen	= 3.5000e+21	# [1/cm^3/sec]
	Bgen	= 2.2500e+07	# [V/cm]
	Pgen	= 2	# [1]
	Arec	= 3.5000e+21	# [1/cm^3/sec]
	Brec	= 2.2500e+07	# [V/cm]
	Prec	= 2	# [1]
	alpha	= 0.0000e+00	# [1]

  * nonlocal B2B models for the following keywords in command file:
  * Band2Band(Model=NonlocalPath) : Nonlocal B2B tunneling with transition process using the tunneling path
  * For the nonlocal B2B process:
  * Apath : Prefactor Ad or Ap in the uniform field limit for the direct or indirect tunneling
  * Bpath : Exponent  Bd or Bp in the uniform field limit for the direct or indirect tunneling
  * Cpath : Factor g*Dop^2/rho for indirect tunneling
  * Dpath : The conduction band offset D
  * Ppath : The phonon energy P
  *         Note that the indirect tunneling process is assumed if P>0, and the direct tunneling process is assumed if P=0
  * Rpath : The ratio mv/mc. If Rpathi=0, it is automatically determined by
  *         mv/mc = (1 + 2*mr)/(1 - 2*mr)
  *         where mr=mc*mv/(mc+mv) is the reduced mass
  * g     : Degeneracy factor
  * m_c   : Effective mass in the conduction band
  * m_v   : Effective mass in the valence band
  * In the uniform field limit, the generation rate can be expressed by
  * G = A * (F/F0)^2   * Exp(-B/F) for   direct tunneling
  *   = A * (F/F0)^2.5 * Exp(-B/F) for indirect tunneling
  * where
  * Ad = g * mr^0.5 * (qF0)^2 / (36 * pi * h_bar^2 *E_T^0.5)
  * Ap = g *(mc*mv)^1.5 * (1+2*N) * (qF0)^2.5 * Dop^2 / (2^7.75 * pi^2.5 * h_bar^2.5 * mr^1.25 * E_T^1.75 * rho * P)
  * Bd = pi    * mr^0.5 * E_T^1.5 / (2 * h_bar * q)
  * Bp = 2^2.5 * mr^0.5 * E_T^1.5 / (3 * h_bar * q)
  * F0 = 1 V/cm, qF0 = 1 eV/cm, E_T = E_G + D
  * For the paramter set (APath, Bpath, Dpath, Ppath, Rpath), the microscopic parameters such as mr, mc, and mv for the nonlocal B2B model are extracted internally.   * For the parameter set (Cpath, g, m_c, m_v), the microscopic parameters are used directly for the tunneling rate computation.
	Apath	= 9.1000e+16	# [1/cm^3/sec]
	Bpath	= 4.9000e+06	# [V/cm]
	Cpath	= 0.0000e+00	# [J^2*cm/kg]
	Dpath	= 0.0000e+00	# [eV]
	Ppath	= 0.037	# [eV]
	Rpath	= 0.0000e+00	# [1]
	m_c	= 0.0000e+00	# [m0]
	m_v	= 0.0000e+00	# [m0]
	degeneracy	= 0.0000e+00	# [1]
	QuantumPotentialFactor	= 0.0000e+00 ,	0.0000e+00	# [1]
	MaxTunnelLength	= 1.0000e-05	# [cm]

  * min length to interfaces (for traditional & Hurkx models):
	dDist	= 0.0000e+00	# [cm]
  * min potential difference on length dPot/E (for traditional & Hurkx models):
	dPot	= 0.0000e+00	# [V]
  * numeric smoothing
	MinField	= 0.0000e+00	# [V/cm]
	MinGradQF	= 0.0000e+00	# [eV/cm]
	DenCorRef	= 0.0000e+00 ,	0.0000e+00	# [cm^-3]
}


BarrierTunneling  
{ * Non Local Barrier Tunneling 
  * G(r) = g*A*T/kB*F(r)*Pt(r)*ln[(1+exp((E(r)-Es)/kB/T))/(1+exp((E(r)-Em)/kB/T))]
  * where: 
  *     Pt(r) is WKB approximation for the tunneling probability 
  *     g = As/A, As is the Richardson constant for carriers in semiconductor
  *     A is the Richardson constant for free electrons 
  *     F(r) is the electric field 
  *     E(r) is carrier energy 
  *     Es is carrier quasi fermi energy in semiconductor
  *     Em is carrier fermi energy in metal 
  *     alpha is the prefactor for quantum potential correction 
  *     eoffset and hoffset are lists of band offsets
	g	= 1.19 ,	0.34	# [1]
	mt	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	eoffset = () # eV
	hoffset = () # eV
}

MultiValley
{ * Arbitrary number of electron and hole valleys can be defined. 
  * Electron density is written as: n=Nc*sum{d_i*F1/2((Ef-Ec-dEc_i)/kT)}, 
  * where dEc_i is energy shift, d_i is DOS factor (defined by valley masses 
  * and degeneracy) of valley i. To specify one valley the energy shift 
  * in respect to band edge, degeneracy, non parabolicity, effective masses, 
  * and valley orientation should be defined. The interface quantization mass
  * (for MLDA model) will be compute automatically (using valley inverse mass 
  * tensor and interface orientation). If the quantization mass is specified, 
  * then it'll be independent of the interface orientation.
  * NOTE: Only L valleys are listed below for electrons.
  *       User should include other relevant valleys in highly degenerated case if needed.
	eValley"L1"(1,1,1)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L2"(-1.0000e+00,1,1)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L3"(1,-1.0000e+00,1)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L4"(1,1,-1.0000e+00)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	hValley"LH"(m=0.044 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(m=0.28 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
}

LatticeParameters
{ * Crystal system, elasticity, and deformation potential are defined.
  * X and Y vectors define the simulation coordinate system relative to the
  * crystal orientation system. Also there is an option to represent the crystal
  * system relative to the simulation one. In this case a keyword CrystalAxis 
  * has to be in this section and X and Y vectors will represent [100] and [010]
  * axis of the crystal system in the simulation one.
  * Additional notes: 1 Pa = 10 dyn/cm^2; tensile stress/strain is positive. 
  *  
  * S[i][j] - elasticity modulus; i,j = 1,2,...6 and j>=i.
  * CrystalSystem is symmetry, used ONLY to define the elasticity matrics.
  *   Cubic (CrystalSystem=0): S[1][1],S[1][2],S[4][4]
  *   Hexagonal (CrystalSystem=1): S[1][1],S[1][2],S[1][3],S[3][3],S[4][4]
  * 
	X	= (1, 0.0000e+00, 0.0000e+00) #[1]
	Y	= (0.0000e+00, 1, 0.0000e+00) #[1]
	S[1][1]	= 0.97	# [1e-12 cm^2/din]
	S[1][2]	= -2.5000e-01	# [1e-12 cm^2/din]
	S[4][4]	= 1.48	# [1e-12 cm^2/din]
	CrystalSystem	= 0	# [1]

  * Deformation potentials of 2 k.p model for electron delta-valleys 
	xis	= 8.07	# [eV]
	dbs	= 0.9	# [eV]
	xiu	= 9.42	# [eV]
	xid	= -5.9000e-01	# [eV]
	Mkp	= 1	# [1]

  * Deformation potentials of 6 k.p model for hole bands
	adp	= 2	# [eV]
	bdp	= -2.1600e+00	# [eV]
	ddp	= -6.0600e+00	# [eV]
	dso	= 0.289	# [eV]

  * Luttinger parameters
	gamma_1	= 9.56	# [1]
	gamma_2	= 2.77	# [1]
	gamma_3	= 3.91	# [1]

  * Deformation potentials and energy (in reference to delta-valley) for L-valleys 
	xiu_l	= 11.5	# [eV]
	xid_l	= -6.5800e+00	# [eV]
	e_l	= -1.9000e-01	# [eV]

  * Deformation potentials and energy (in reference to delta-valley) for Gamma-valley 
	xid_gamma	= -7.0000e+00	# [eV]
	e_gamma	= -4.0000e-02	# [eV]
}

StressMobility
{ * Stress-induced electron channel mobility model.
  * The model is based on 2 band k.p theory for electron bands and 
  * intervalley/intravelly scattering model with acoustic and optical phonons.
	Ephonon	= 0.03	# [eV]
	beta	= 1.22	# [1]
	beta_mlda	= (1.5, 1.2, 1.5) #[1]
	Nref	= 3.0000e+19	# [cm^-3]
	alpha	= 0.65	# [1]
	Dop	= 1.2000e+09	# [eV/cm]
	Dac_cl	= 1.6700e-05	# [eVs/cm]
  * 
  * Stress-induced change of delta2 electron mass proposed by TU Vienna.
  * The model is based on 2 band k.p theory for electron bands,
  * k.p parameters of the model are defined in LatticeParameters section. 
  * me_l0 and me_t0 are unstressed longitudinal and transverse effective masses:
	me_l0	= 0.915	# [1]
	me_t0	= 0.201	# [1]
  * 
  * Relaxed effective masses of electrons in L-valleys:
	me_l0_l	= 1.768	# [1]
	me_t0_l	= 0.0967	# [1]
  * 
  * Relaxed effective mass of electrons in Gamma-valley:
	me0_gamma	= 0.05	# [1]
  * 
  * Stress-induced hole channel mobility model.
  * The model is based on 6 band k.p hole bands and MLDA channel quantization,
  * k.p parameters of the model are defined in LatticeParameters section. 
	Ephonon_h	= 0.037	# [eV]
	Dop_h	= 6.0600e+08	# [eV/cm]
	Dac_cl_h	= 9.9600e-06	# [eVs/cm]
	beta_h	= 1.0000e+10	# [1]
	beta_mlda_h	= (3, 0.75, 2.5) #[1]
	Nref_h	= 3.0000e+19	# [cm^-3]
	alpha_h	= 0.85	# [1]
  * 
  * Stress-induced hole mobility model is proposed by Intel:
  * the hole band structure in 100 plane is described by two ellipsoids directed in 
  * 110 and -110 directions, the multiplication factor of hole mobility in 110 direction
  * is the following:
  *             fh_110 = (f_110/mh_l0+f_'110/mh_t'110)/(0.5/mh_l0+0.5/mh_t0),
  * where:
  *   f_110 = 1/(1+exp(delta/kT), f_'110 = 1/(1+exp(-delta/kT) - occupation of
  *           the ellipsoids if just two (ne) considered in the hole band
  *   mh_l0 is the hole longitudinal mass in the ellipsoid at no stress
  *   mh_t0 is the hole transverse mass in the ellipsoid at no stress
  *   delta is stress-induced energy split between the ellipsoids
  * 
  *   delta = d1*s
  *   mh_t110 = mh_t0/(1-st1*s+st2*s^2+bt1*b+bt2*b^2)
  *   mh_t'110 = mh_t0/(1+st1*s+st2*s^2+bt1*b+bt2*b^2)
  *      (s is shear and b is biaxial components of the stress)
  * 
  * Modification of the Intel model:
  *   1) considered three 100 plans (6 ellipsoids)
  *   2) ne is number of ellipsoids in the occupation functions fh*
  *   3) considered mass in 100 direction: mh_t100 = mh_t0/(1+btt*b)
	mh_l0	= 0.48	# [1]
	mh_t0	= 0.15	# [1]
	d1	= -6.0000e-11	# [eV/Pa]
	st1	= -9.4426e-10	# [1/Pa]
	st2	= 4.3066e-19	# [1/Pa^2]
	bt1	= -1.0086e-10	# [1/Pa]
	bt2	= 6.5886e-21	# [1/Pa^2]
	btt	= 1.2000e-10	# [1/Pa]
	ne	= 2	# [1]
}


}

Material = "Gold" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 0.0000e+00	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.048	0.846	0.565;
          0.05	0.85	0.645;
          0.052	0.872	0.74;
          0.054	0.915	0.825;
          0.056	0.985	0.848;
          0.058	1.055	0.842;
          0.06	1.113	0.813;
          0.062	1.146	0.77;
          0.064	1.157	0.73;
          0.066	1.14	0.7;
          0.068	1.107	0.687;
          0.07	1.075	0.678;
          0.072	1.05	0.685;
          0.074	1.038	0.697;
          0.076	1.03	0.713;
          0.078	1.028	0.73;
          0.08	1.029	0.745;
          0.082	1.033	0.759;
          0.084	1.041	0.77;
          0.086	1.053	0.78;
          0.088	1.07	0.789;
          0.09	1.09	0.798;
          0.092	1.11	0.806;
          0.094	1.133	0.812;
          0.096	1.159	0.819;
          0.098	1.18	0.826;
          0.1	1.2	0.836;
          0.102	1.21	0.848;
          0.104	1.215	0.86;
          0.106	1.217	0.87;
          0.108	1.218	0.885;
          0.11	1.222	0.9;
          0.112	1.225	0.914;
          0.114	1.232	0.927;
          0.116	1.242	0.935;
          0.118	1.25	0.95;
          0.12	1.26	0.962;
          0.122	1.27	0.975;
          0.124	1.28	0.987;
          0.126	1.29	1;
          0.128	1.3	1.012;
          0.13	1.308	1.02;
          0.132	1.318	1.032;
          0.134	1.328	1.045;
          0.136	1.338	1.053;
          0.138	1.35	1.063;
          0.14	1.36	1.072;
          0.15	1.419	1.102;
          0.16	1.483	1.106;
          0.17	1.519	1.07;
          0.175	1.5	1.07;
          0.18	1.47	1.085;
          0.185	1.442	1.107;
          0.19	1.427	1.135;
          0.195	1.424	1.17;
          0.2	1.427	1.215;
          0.2066	1.422	1.306;
          0.2101	1.43	1.334;
          0.2138	1.432	1.364;
          0.2175	1.438	1.388;
          0.2214	1.442	1.418;
          0.2254	1.452	1.442;
          0.2296	1.454	1.478;
          0.2339	1.462	1.51;
          0.2384	1.47	1.55;
          0.2431	1.478	1.59;
          0.248	1.484	1.636;
          0.253	1.49	1.698;
          0.2583	1.504	1.748;
          0.2638	1.546	1.784;
          0.2695	1.598	1.822;
          0.2755	1.648	1.852;
          0.2818	1.69	1.882;
          0.2883	1.742	1.9;
          0.2952	1.776	1.918;
          0.3024	1.812	1.92;
          0.31	1.83	1.916;
          0.3179	1.84	1.904;
          0.3263	1.824	1.878;
          0.3351	1.798	1.86;
          0.3444	1.766	1.846;
          0.3542	1.74	1.848;
          0.3647	1.716	1.862;
          0.3757	1.696	1.906;
          0.3875	1.674	1.936;
          0.4	1.658	1.956;
          0.4133	1.636	1.958;
          0.4275	1.616	1.94;
          0.4428	1.562	1.904;
          0.4592	1.426	1.846;
          0.4769	1.242	1.796;
          0.4959	0.916	1.84;
          0.5166	0.608	2.12;
          0.5391	0.402	2.54;
          0.5636	0.306	2.88;
          0.6526	0.166	3.15;
          0.6888	0.16	3.8;
          0.7293	0.164	4.35;
          0.7749	0.174	4.86;
          0.8266	0.188	5.39;
          0.8856	0.21	5.88;
          0.9537	0.236	6.47;
          1.033	0.272	7.07;
          1.127	0.312	7.93;
          1.265	0.389	8.09;
          1.291	0.403	8.25;
          1.319	0.419	8.42;
          1.384	0.436	8.59;
          1.378	0.454	8.77;
          1.409	0.473	8.96;
          1.442	0.493	9.15;
          1.476	0.515	9.36;
          1.512	0.537	9.58;
          1.55	0.559	9.81;
          1.59	0.583	10.1;
          1.631	0.609	10.3;
          1.675	0.636	10.6;
          1.722	0.665	10.9;
          1.771	0.696	11.2;
          1.823	0.73	11.5;
          1.879	0.767	11.9;
          1.937	0.807	12.2;
          2	0.85	12.6;
          2.066	0.896	13;
          2.138	0.947	13.4;
          2.214	1.002	13.9;
          2.296	1.063	14.4;
          2.384	1.13	14.9;
          2.48	1.205	15.5;
          2.583	1.287	16.1;
          2.695	1.379	16.8;
          2.818	1.482	17.5;
          2.952	1.598	18.3;
          3.1	1.728	19.2;
          3.179	1.8	19.7;
          3.263	1.876	20.2;
          3.351	1.958	20.7;
          3.444	2.046	21.3;
          3.542	2.141	21.9;
          3.647	2.242	22.5;
          3.757	2.352	23.1;
          3.875	2.471	23.9;
          4	2.6	24.6;
          4.133	2.749	25.4;
          4.275	2.912	26.3;
          4.428	3.091	27.2;
          4.592	3.289	28.2;
          4.769	3.507	29.3;
          4.959	3.748	30.5;
          5.166	4.007	31.7;
          5.391	4.292	32.9;
          5.636	4.611	34.3;
          5.904	4.971	35.9;
          6.199	5.423	37.5;
          6.358	5.684	38.3;
          6.526	5.966	39.1;
          6.888	6.598	41;
          7.085	6.937	42;
          7.293	7.282	43;
          7.514	7.655	44.1;
          7.749	8.06	45.2;
          7.999	8.5	46.4;
          8.266	9.016	47.6;
          8.551	9.582	48.8;
          8.856	10.21	50.2;
          9.184	10.84	51.6;
          9.537	11.51	53.1;
          9.919	12.24	54.7;
          10.001	12.4	55;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 2.49	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 3.1	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 3.1	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 5	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 2.0400e-06	# [ohm*cm]
	TempCoef	= 4.0000e-03	# [1/K]
}


}

Material = "HfO2" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 22	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 22	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.95	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1.95	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 2.76	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.023	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.023	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 2.05	# [eV]
	Eg0	= 5.9	# [eV]
	alpha	= 0.0000e+00	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "HgCdTe" {
*  Mole dependent material: HgCdTe (x=0) = HgTe
*  Mole dependent material: HgCdTe (x=1) = CdTe

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

Absorption
{ * Formula = 1:
  * A = A1*exp((phE-E1)/E2),     for phE < E1 
  *   = A1 + A2*((phE-E1)/E2)^P, for phE >= E1 
  * Formula = 2:
  * A = A0*exp((phE-phE0)*ST),              for phE < phE0 
  *   = AT*(2*ST*(phE-E0-(LN-0.5)/ST))^0.5, for phE >= phE0 
  * where 
  *      phE is a photon energy, 
  *      LN = log(AT/A0), 
  *      ST = S/(T+T0), T is a temperature, 
  *      phE0 = E0 + LN/ST. 

	Formula	= 2	# [1]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A1(0)	= 1.0000e+04	# [cm-1]
	A1(1)	= 1.0000e+04	# [cm-1]
	A2(0)	= 100	# [cm-1]
	A2(1)	= 100	# [cm-1]
	E1(0)	= 1.12	# [eV]
	E1(1)	= 1.12	# [eV]
	E2(0)	= 0.025	# [eV]
	E2(1)	= 0.025	# [eV]
	P(0)	= 0.5	# [1]
	P(1)	= 0.5	# [1]
	AT(0)	= 100	# [cm-1]
	AT(1)	= 5.1000e+03	# [cm-1]
	A0(0)	= 6.3171e-09	# [cm-1]
	A0(1)	= 1.2107e+15	# [cm-1]
	S(0)	= 3.2670e+04	# [K/eV]
	S(1)	= 6.5340e+04	# [K/eV]
	E0(0)	= -3.4240e-01	# [eV]
	E0(1)	= 1.4956	# [eV]
	T0(0)	= 81.9	# [K]
	T0(1)	= 81.9	# [K]
}


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(CdTe) + (1-x) * P(HgTe)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "HgTe" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 20	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 20	# [1]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 5.79	# [eV]
	Eg0	= -3.0000e-01	# [eV]
	alpha	= 0.0000e+00	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 3.0000e+02	# [K]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.029	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 0.43	# [1]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 3.0000e+04 ,	1.0000e+03	# [cm^2/(Vs)]
	Exponent	= 0.73 ,	1	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 3.0000e+04 ,	1.0000e+03	# [cm^2/(Vs)]
	Exponent	= 0.73 ,	1	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 20 ,	20	# [1]
}

Absorption
{ * Formula = 1:
  * A = A1*exp((phE-E1)/E2),     for phE < E1 
  *   = A1 + A2*((phE-E1)/E2)^P, for phE >= E1 
  * Formula = 2:
  * A = A0*exp((phE-phE0)*ST),              for phE < phE0 
  *   = AT*(2*ST*(phE-E0-(LN-0.5)/ST))^0.5, for phE >= phE0 
  * where 
  *      phE is a photon energy, 
  *      LN = log(AT/A0), 
  *      ST = S/(T+T0), T is a temperature, 
  *      phE0 = E0 + LN/ST. 

	Formula	= 2	# [1]
  * Formula = 2:
	AT	= 100	# [cm-1]
	A0	= 6.3171e-09	# [cm-1]
	S	= 3.2670e+04	# [K/eV]
	E0	= -3.4240e-01	# [eV]
	T0	= 81.9	# [K]
}


}

Material = "InAlAs" {
*  Mole dependent material: InAlAs (x=0) = InAs
*  Mole dependent material: InAlAs (x=1) = AlAs

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 14.55	# [1]
	epsilon(1)	= 10.06	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 14.55	# [1]
	epsilon(1)	= 10.06	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	refractiveindex(0)	= 3.892	# [1]
	refractiveindex(1)	= 2.90805	# [1]
	alpha(0)	= 2.0000e-04	# [1/K]
	alpha(1)	= 2.0000e-04	# [1/K]
	CarrDepCoeff(0)	= 1	# [1]
	CarrDepCoeff(1)	= 1	# [1]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0(0)	= 3.892	# [1]
	n_0(1)	= 2.90805	# [1]
	k_0(0)	= 0.0000e+00	# [1]
	k_0(1)	= 0.0000e+00	# [1]
	Cn_lambda(0)	= 0.0000e+00	# [um^-1]
	Cn_lambda(1)	= 0.0000e+00	# [um^-1]
	Dn_lambda(0)	= 0.0000e+00	# [um^-2]
	Dn_lambda(1)	= 0.0000e+00	# [um^-2]
	Ck_lambda(0)	= 0.0000e+00	# [um^-1]
	Ck_lambda(1)	= 0.0000e+00	# [um^-1]
	Dk_lambda(0)	= 0.0000e+00	# [um^-2]
	Dk_lambda(1)	= 0.0000e+00	# [um^-2]
	Cn_temp(0)	= 2.0000e-04	# [K^-1]
	Cn_temp(1)	= 2.0000e-04	# [K^-1]
	Cn_carr(0)	= 1	# [1]
	Cn_carr(1)	= 1	# [1]
	Cn_gain(0)	= 0.0000e+00	# [1]
	Cn_gain(1)	= 0.0000e+00	# [1]
	Npar(0)	= 1.0000e+18	# [cm^-3]
	Npar(1)	= 1.0000e+18	# [cm^-3]
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	Ck_carr(0)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Ck_carr(1)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Gamma_k_carr(0)	= 1,	1	#[1]
	Gamma_k_carr(1)	= 1,	1	#[1]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	cv(0)	= 1.6	# [J/(Kcm^3)]
	cv(1)	= 1.16	# [J/(Kcm^3)]
	cv_b(0)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_b(1)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_c(0)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_c(1)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_d(0)	= 0.0000e+00	# [J/(K^4*cm^3)]
	cv_d(1)	= 0.0000e+00	# [J/(K^4*cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 3.7	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 1.1	# [(K cm)/W]
	B(1/kappa(1))	= -2.0000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 3.7	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 1.1	# [(K cm)/W]
	B(1/kappa(1))	= -2.0000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter dEg0(OldSlotboom):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(OldSlotboom)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.56	# [1]
	dEg0(OldSlotboom)(1)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(1))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEg0(OldSlotboom)(2)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(2))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(2))	= 0.0000e+00	# [eV]

	* parameter dEg0(Slotboom):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(Slotboom)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.56	# [1]
	dEg0(Slotboom)(1)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(1))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEg0(Slotboom)(2)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(2))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(2))	= 0.0000e+00	# [eV]

	* parameter dEg0(delAlamo):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(delAlamo)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.56	# [1]
	dEg0(delAlamo)(1)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(1))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEg0(delAlamo)(2)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(2))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(2))	= 0.0000e+00	# [eV]

	* parameter dEg0(Bennett):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(Bennett)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.56	# [1]
	dEg0(Bennett)(1)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(1))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEg0(Bennett)(2)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(2))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(2))	= 0.0000e+00	# [eV]

	* parameter Eg0:
	Xmax(0)	= 0.0000e+00	# [1]
	Eg0(0)	= 0.355482	# [eV]
	Xmax(1)	= 0.56	# [1]
	Eg0(1)	= 1.63792	# [eV]
	B(Eg0(1))	= -7.0000e-01	# [eV]
	C(Eg0(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	Eg0(2)	= 2.11	# [eV]
	B(Eg0(2))	= -7.0000e-01	# [eV]
	C(Eg0(2))	= 0.0000e+00	# [eV]

	* parameter Bgn2Chi:
	Xmax(0)	= 0.0000e+00	# [1]
	Bgn2Chi(0)	= 0.5	# [1]
	Xmax(1)	= 0.56	# [1]
	Bgn2Chi(1)	= 0.5	# [1]
	B(Bgn2Chi(1))	= 0.0000e+00	# [1]
	C(Bgn2Chi(1))	= 0.0000e+00	# [1]
	Xmax(2)	= 1	# [1]
	Bgn2Chi(2)	= 0.5	# [1]
	B(Bgn2Chi(2))	= 0.0000e+00	# [1]
	C(Bgn2Chi(2))	= 0.0000e+00	# [1]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha(0)	= 3.3500e-04	# [eV/K]
	Xmax(1)	= 0.56	# [1]
	alpha(1)	= 3.7140e-04	# [eV/K]
	B(alpha(1))	= 0.0000e+00	# [eV/K]
	C(alpha(1))	= 0.0000e+00	# [eV/K]
	Xmax(2)	= 1	# [1]
	alpha(2)	= 4.0000e-04	# [eV/K]
	B(alpha(2))	= 0.0000e+00	# [eV/K]
	C(alpha(2))	= 0.0000e+00	# [eV/K]

	* parameter alpha2:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha2(0)	= 0.0000e+00	# [eV/K]
	Xmax(1)	= 0.56	# [1]
	alpha2(1)	= 0.0000e+00	# [eV/K]
	B(alpha2(1))	= 0.0000e+00	# [eV/K]
	C(alpha2(1))	= 0.0000e+00	# [eV/K]
	Xmax(2)	= 1	# [1]
	alpha2(2)	= 0.0000e+00	# [eV/K]
	B(alpha2(2))	= 0.0000e+00	# [eV/K]
	C(alpha2(2))	= 0.0000e+00	# [eV/K]

	* parameter beta:
	Xmax(0)	= 0.0000e+00	# [1]
	beta(0)	= 2.4800e+02	# [K]
	Xmax(1)	= 0.56	# [1]
	beta(1)	= 1.0912e+02	# [K]
	B(beta(1))	= 0.0000e+00	# [K]
	C(beta(1))	= 0.0000e+00	# [K]
	Xmax(2)	= 1	# [1]
	beta(2)	= 0.0000e+00	# [K]
	B(beta(2))	= 0.0000e+00	# [K]
	C(beta(2))	= 0.0000e+00	# [K]

	* parameter beta2:
	Xmax(0)	= 0.0000e+00	# [1]
	beta2(0)	= 0.0000e+00	# [K]
	Xmax(1)	= 0.56	# [1]
	beta2(1)	= 0.0000e+00	# [K]
	B(beta2(1))	= 0.0000e+00	# [K]
	C(beta2(1))	= 0.0000e+00	# [K]
	Xmax(2)	= 1	# [1]
	beta2(2)	= 0.0000e+00	# [K]
	B(beta2(2))	= 0.0000e+00	# [K]
	C(beta2(2))	= 0.0000e+00	# [K]

	* parameter Chi0:
	Xmax(0)	= 0.0000e+00	# [1]
	Chi0(0)	= 4.92751	# [eV]
	Xmax(1)	= 0.56	# [1]
	Chi0(1)	= 4.1617	# [eV]
	B(Chi0(1))	= 0.0000e+00	# [eV]
	C(Chi0(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	Chi0(2)	= 3.56	# [eV]
	B(Chi0(2))	= 0.0000e+00	# [eV]
	C(Chi0(2))	= 0.0000e+00	# [eV]

	* parameter WorkFunction:
	Xmax(0)	= 0.0000e+00	# [1]
	WorkFunction(0)	= 4.25	# [eV]
	Xmax(1)	= 0.56	# [1]
	WorkFunction(1)	= 4.25	# [eV]
	B(WorkFunction(1))	= 0.0000e+00	# [eV]
	C(WorkFunction(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	WorkFunction(2)	= 4.25	# [eV]
	B(WorkFunction(2))	= 0.0000e+00	# [eV]
	C(WorkFunction(2))	= 0.0000e+00	# [eV]

	* parameter FermiEnergy:
	Xmax(0)	= 0.0000e+00	# [1]
	FermiEnergy(0)	= 11.7	# [eV]
	Xmax(1)	= 0.56	# [1]
	FermiEnergy(1)	= 11.7	# [eV]
	B(FermiEnergy(1))	= 0.0000e+00	# [eV]
	C(FermiEnergy(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	FermiEnergy(2)	= 11.7	# [eV]
	B(FermiEnergy(2))	= 0.0000e+00	# [eV]
	C(FermiEnergy(2))	= 0.0000e+00	# [eV]

	* parameter EgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	EgMin(0)	= -1.0000e+01	# [eV]
	Xmax(1)	= 0.56	# [1]
	EgMin(1)	= -1.0000e+01	# [eV]
	B(EgMin(1))	= 0.0000e+00	# [eV]
	C(EgMin(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	EgMin(2)	= -1.0000e+01	# [eV]
	B(EgMin(2))	= 0.0000e+00	# [eV]
	C(EgMin(2))	= 0.0000e+00	# [eV]

	* parameter dEgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	dEgMin(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.56	# [1]
	dEgMin(1)	= 0.0000e+00	# [eV]
	B(dEgMin(1))	= 0.0000e+00	# [eV]
	C(dEgMin(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEgMin(2)	= 0.0000e+00	# [eV]
	B(dEgMin(2))	= 0.0000e+00	# [eV]
	C(dEgMin(2))	= 0.0000e+00	# [eV]

}


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	fcaalpha_n(0)	= 4.0000e-18	# [cm^2]
	fcaalpha_n(1)	= 4.0000e-18	# [cm^2]
	fcaalpha_p(0)	= 8.0000e-18	# [cm^2]
	fcaalpha_p(1)	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	gamma_1(0)	= 20.4	# [1]
	gamma_1(1)	= 3.45	# [1]
	gamma_2(0)	= 8.3	# [1]
	gamma_2(1)	= 0.68	# [1]
	gamma_3(0)	= 9.1	# [1]
	gamma_3(1)	= 1.29	# [1]
	so(0)	= 0.38	# [eV]
	so(1)	= 0.28	# [eV]
	ep_te(0)	= 21.5	# [eV]
	ep_te(1)	= 21.1	# [eV]
	ep_tm(0)	= 21.5	# [eV]
	ep_tm(1)	= 21.1	# [eV]
	A1(0)	= 0.0000e+00	# [1]
	A1(1)	= 0.0000e+00	# [1]
	A2(0)	= 0.0000e+00	# [1]
	A2(1)	= 0.0000e+00	# [1]
	A3(0)	= 0.0000e+00	# [1]
	A3(1)	= 0.0000e+00	# [1]
	A4(0)	= 0.0000e+00	# [1]
	A4(1)	= 0.0000e+00	# [1]
	A5(0)	= 0.0000e+00	# [1]
	A5(1)	= 0.0000e+00	# [1]
	A6(0)	= 0.0000e+00	# [1]
	A6(1)	= 0.0000e+00	# [1]
	cr(0)	= 0.0000e+00	# [eV]
	cr(1)	= 0.0000e+00	# [eV]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a_nu(0)	= 1	# [eV]
	a_nu(1)	= 2.47	# [eV]
	a_c(0)	= -5.0800e+00	# [eV]
	a_c(1)	= -5.6400e+00	# [eV]
	b_shear(0)	= -1.8000e+00	# [eV]
	b_shear(1)	= -1.5000e+00	# [eV]
	C_11(0)	= 8.329	# [1e-2 GPa]
	C_11(1)	= 5.34	# [1e-2 GPa]
	C_12(0)	= 4.526	# [1e-2 GPa]
	C_12(1)	= 12.5	# [1e-2 GPa]
	eps(0)	= 0.0000e+00	# [1]
	eps(1)	= 0.0000e+00	# [1]
	a0(0)	= 6.0583e-10	# [m]
	a0(1)	= 5.6611e-10	# [m]
	alpha(0)	= 2.7400e-15	# [m/K]
	alpha(1)	= 2.9000e-15	# [m/K]
	D1(0)	= 0.0000e+00	# [eV]
	D1(1)	= 0.0000e+00	# [eV]
	D2(0)	= 0.0000e+00	# [eV]
	D2(1)	= 0.0000e+00	# [eV]
	D3(0)	= 0.0000e+00	# [eV]
	D3(1)	= 0.0000e+00	# [eV]
	D4(0)	= 0.0000e+00	# [eV]
	D4(1)	= 0.0000e+00	# [eV]
	C_13(0)	= 0.0000e+00	# [1e-2 GPa]
	C_13(1)	= 0.0000e+00	# [1e-2 GPa]
	C_33(0)	= 0.0000e+00	# [1e-2 GPa]
	C_33(1)	= 0.0000e+00	# [1e-2 GPa]
	c0(0)	= 0.0000e+00	# [cm]
	c0(1)	= 0.0000e+00	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.1905	# [1]
	a(1)	= 0.1905	# [1]
	ml(0)	= 0.9163	# [1]
	ml(1)	= 0.9163	# [1]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nc300(0)	= 8.7200e+16	# [cm-3]
	Nc300(1)	= 1.1100e+18	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.443587	# [1]
	a(1)	= 0.443587	# [1]
	b(0)	= 3.6095e-03	# [K^-1]
	b(1)	= 3.6095e-03	# [K^-1]
	c(0)	= 1.1735e-04	# [K^-2]
	c(1)	= 1.1735e-04	# [K^-2]
	d(0)	= 1.2632e-06	# [K^-3]
	d(1)	= 1.2632e-06	# [K^-3]
	e(0)	= 3.0256e-09	# [K^-4]
	e(1)	= 3.0256e-09	# [K^-4]
	f(0)	= 4.6834e-03	# [K^-1]
	f(1)	= 4.6834e-03	# [K^-1]
	g(0)	= 2.2869e-04	# [K^-2]
	g(1)	= 2.2869e-04	# [K^-2]
	h(0)	= 7.4693e-07	# [K^-3]
	h(1)	= 7.4693e-07	# [K^-3]
	i(0)	= 1.7275e-09	# [K^-4]
	i(1)	= 1.7275e-09	# [K^-4]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nv300(0)	= 6.6600e+18	# [cm-3]
	Nv300(1)	= 1.2400e+19	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A(0)	= 4.22	# [1]
	A(1)	= 4.22	# [1]
	B(0)	= 0.6084	# [1]
	B(1)	= 0.6084	# [1]
	C(0)	= 23.058	# [1]
	C(1)	= 23.058	# [1]
	ml(0)	= 0.024	# [1]
	ml(1)	= 0.26	# [1]
	mh(0)	= 0.41	# [1]
	mh(1)	= 0.5	# [1]
	me(0)	= 0.0000e+00	# [1]
	me(1)	= 0.0000e+00	# [1]
	eoffset(0)	= 0.0000e+00	# [eV]
	eoffset(1)	= 0.0000e+00	# [eV]
	hoffset(0)	= 0.0000e+00	# [eV]
	hoffset(1)	= 0.0000e+00	# [eV]
}


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1.5,	1.5	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 2.2600e+04,	2.5000e+02	#[cm^2/(Vs)]
	mumax(1)	= 2.5000e+03,	1.5000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1.5,	1.5	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 2.2600e+04,	2.5000e+02	#[cm^2/(Vs)]
	mumax(1)	= 2.5000e+03,	1.5000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	a(low)(0)	= 8.6000e+06,	2.3000e+07	#[1/cm]
	a(low)(1)	= 8.6000e+06,	2.3000e+07	#[1/cm]
	a(high)(0)	= 8.6000e+06,	2.3000e+07	#[1/cm]
	a(high)(1)	= 8.6000e+06,	2.3000e+07	#[1/cm]
	b(low)(0)	= 3.5000e+06,	6.4000e+05	#[V/cm]
	b(low)(1)	= 3.5000e+06,	6.4000e+05	#[V/cm]
	b(high)(0)	= 3.5000e+06,	6.4000e+05	#[V/cm]
	b(high)(1)	= 3.5000e+06,	6.4000e+05	#[V/cm]
	E0(0)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	E0(1)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	hbarOmega(0)	= 1.0000e+03,	1.0000e+03	#[eV]
	hbarOmega(1)	= 1.0000e+03,	1.0000e+03	#[eV]
	beta(low)(0)	= 6.20285,	1.13424	#[1]
	beta(low)(1)	= 6.20285,	1.13424	#[1]
	beta(high)(0)	= 6.20285,	1.13424	#[1]
	beta(high)(1)	= 6.20285,	1.13424	#[1]
	lambda(0)	= 6.3000e-07,	6.3000e-07	#[cm]
	lambda(1)	= 6.3000e-07,	6.3000e-07	#[cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	a(low)(0)	= 8.6000e+06,	2.3000e+07	#[1/cm]
	a(low)(1)	= 8.6000e+06,	2.3000e+07	#[1/cm]
	a(high)(0)	= 8.6000e+06,	2.3000e+07	#[1/cm]
	a(high)(1)	= 8.6000e+06,	2.3000e+07	#[1/cm]
	b(low)(0)	= 3.5000e+06,	6.4000e+05	#[V/cm]
	b(low)(1)	= 3.5000e+06,	6.4000e+05	#[V/cm]
	b(high)(0)	= 3.5000e+06,	6.4000e+05	#[V/cm]
	b(high)(1)	= 3.5000e+06,	6.4000e+05	#[V/cm]
	E0(0)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	E0(1)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	hbarOmega(0)	= 1.0000e+03,	1.0000e+03	#[eV]
	hbarOmega(1)	= 1.0000e+03,	1.0000e+03	#[eV]
	beta(low)(0)	= 6.20285,	1.13424	#[1]
	beta(low)(1)	= 6.20285,	1.13424	#[1]
	beta(high)(0)	= 6.20285,	1.13424	#[1]
	beta(high)(1)	= 6.20285,	1.13424	#[1]
	lambda(0)	= 6.3000e-07,	6.3000e-07	#[cm]
	lambda(1)	= 6.3000e-07,	6.3000e-07	#[cm]
}


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "InAs" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 14.55	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 14.55	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 3.892	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.892	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.6	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 4.9	# [eV]
	Eg0	= 0.4105	# [eV]
	alpha	= 3.3500e-04	# [eV K^-1]
	beta	= 2.4800e+02	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

	gamma_1	= 20.4	# [1]
	gamma_2	= 8.3	# [1]
	gamma_3	= 9.1	# [1]
	so	= 0.38	# [eV]
	ep_te	= 21.5	# [eV]
	ep_tm	= 21.5	# [eV]
	cr	= 0.019	# [eV]
	A1	= -7.2400e+00	# [1]
	A2	= -5.1000e-01	# [1]
	A3	= 6.73	# [1]
	A4	= -3.3600e+00	# [1]
	A5	= -3.3500e+00	# [1]
	A6	= -4.7200e+00	# [1]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 2.7400e-15	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 1	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= -1.8000e+00	# [eV]
	c_11	= 8.329	# [1e-2 GPa]
	c_12	= 4.526	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
	Nc300	= 8.7200e+16	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
	Nv300	= 6.6600e+18	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.024	# [1]
	mh	= 0.41	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 2.2600e+04 ,	2.5000e+02	# [cm^2/(Vs)]
	Exponent	= 1.5 ,	1.5	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 2.2600e+04 ,	2.5000e+02	# [cm^2/(Vs)]
	Exponent	= 1.5 ,	1.5	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 2.2600e+04 ,	2.5000e+02	# [cm^2/Vs]
	Ar_alm  	= -1.5000e+00 ,	-1.5000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 2.2600e+04 ,	2.5000e+02	# [cm^2/Vs]
	Ar_alm  	= -1.5000e+00 ,	-1.5000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.0000e+07 ,	1.0000e+07	# [1]
	B_vsat	= 0.0000e+00 ,	0.0000e+00	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.0000e+07 ,	1.0000e+07	# [1]
	B_vsat	= 0.0000e+00 ,	0.0000e+00	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 14.55 ,	14.55	# [1]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 8.6000e+06 ,	2.3000e+07	# [1/cm]
	a(high)	= 8.6000e+06 ,	2.3000e+07	# [1/cm]
	b(low)	= 3.5000e+06 ,	6.4000e+05	# [V/cm]
	b(high)	= 3.5000e+06 ,	6.4000e+05	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 1.0000e+03 ,	1.0000e+03	# [eV]
	beta(low)	= 6.20285 ,	1.13424	# [1]
	beta(high)	= 6.20285 ,	1.13424	# [1]
	lambda	= 6.3000e-07 ,	6.3000e-07	# [cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 8.6000e+06 ,	2.3000e+07	# [1/cm]
	a(high)	= 8.6000e+06 ,	2.3000e+07	# [1/cm]
	b(low)	= 3.5000e+06 ,	6.4000e+05	# [V/cm]
	b(high)	= 3.5000e+06 ,	6.4000e+05	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 1.0000e+03 ,	1.0000e+03	# [eV]
	beta(low)	= 6.20285 ,	1.13424	# [1]
	beta(high)	= 6.20285 ,	1.13424	# [1]
	lambda	= 6.3000e-07 ,	6.3000e-07	# [cm]
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}

MultiValley
{ * Arbitrary number of electron and hole valleys can be defined. 
  * Electron density is written as: n=Nc*sum{d_i*F1/2((Ef-Ec-dEc_i)/kT)}, 
  * where dEc_i is energy shift, d_i is DOS factor (defined by valley masses 
  * and degeneracy) of valley i. To specify one valley the energy shift 
  * in respect to band edge, degeneracy, non parabolicity, effective masses, 
  * and valley orientation should be defined. The interface quantization mass
  * (for MLDA model) will be compute automatically (using valley inverse mass 
  * tensor and interface orientation). If the quantization mass is specified, 
  * then it'll be independent of the interface orientation.
	eValley"Gamma"(m=0.0244 energy=0.0000e+00 alpha=1.39 degeneracy=1 xid=-1.0200e+01) 
	eValley"L1"(1,1,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L2"(-1.0000e+00,1,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L3"(1,-1.0000e+00,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L4"(1,1,-1.0000e+00)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"X1"(1,0.0000e+00,0.0000e+00)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 degeneracy=1 xiu=4.5 xid=1.6) 
	eValley"X2"(0.0000e+00,1,0.0000e+00)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 degeneracy=1 xiu=4.5 xid=1.6) 
	eValley"X3"(0.0000e+00,0.0000e+00,1)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 degeneracy=1 xiu=4.5 xid=1.6) 
	hValley"LH"(m=0.082 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(m=0.51 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
}

LatticeParameters
{ * Crystal system, elasticity, and deformation potential are defined.
  * X and Y vectors define the simulation coordinate system relative to the
  * crystal orientation system. Also there is an option to represent the crystal
  * system relative to the simulation one. In this case a keyword CrystalAxis 
  * has to be in this section and X and Y vectors will represent [100] and [010]
  * axis of the crystal system in the simulation one.
  * Additional notes: 1 Pa = 10 dyn/cm^2; tensile stress/strain is positive. 
  *  
  * S[i][j] - elasticity modulus; i,j = 1,2,...6 and j>=i.
  * CrystalSystem is symmetry, used ONLY to define the elasticity matrics.
  *   Cubic (CrystalSystem=0): S[1][1],S[1][2],S[4][4]
  *   Hexagonal (CrystalSystem=1): S[1][1],S[1][2],S[1][3],S[3][3],S[4][4]
  * 
	X	= (1, 0.0000e+00, 0.0000e+00) #[1]
	Y	= (0.0000e+00, 1, 0.0000e+00) #[1]
	S[1][1]	= 1.9	# [1e-12 cm^2/din]
	S[1][2]	= -6.9000e-01	# [1e-12 cm^2/din]
	S[4][4]	= 2.5	# [1e-12 cm^2/din]
	CrystalSystem	= 0	# [1]

  * Deformation potentials of 2 k.p model for electron delta-valleys 
	xis	= 0.0000e+00	# [eV]
	dbs	= 0.0000e+00	# [eV]
	xiu	= 4.5	# [eV]
	xid	= 1.6	# [eV]
	Mkp	= 1	# [1]

  * Deformation potentials of 6 k.p model for hole bands
	adp	= 1	# [eV]
	bdp	= -1.8000e+00	# [eV]
	ddp	= -3.6000e+00	# [eV]
	dso	= 0.394	# [eV]

  * Luttinger parameters
	gamma_1	= 14.46	# [1]
	gamma_2	= 5.74	# [1]
	gamma_3	= 6.59	# [1]

  * Deformation potentials and energy (in reference to delta-valley) for L-valleys 
	xiu_l	= 9.5	# [eV]
	xid_l	= -2.0000e+00	# [eV]
	e_l	= -3.0000e-01	# [eV]

  * Deformation potentials and energy (in reference to delta-valley) for Gamma-valley 
	xid_gamma	= -1.0200e+01	# [eV]
	e_gamma	= -1.0100e+00	# [eV]
}

StressMobility
{ * Stress-induced electron channel mobility model.
  * The model is based on 2 band k.p theory for electron bands and 
  * intervalley/intravelly scattering model with acoustic and optical phonons.
	Ephonon	= 0.03	# [eV]
	beta	= 1.22	# [1]
	beta_mlda	= (1.5, 1.5, 1.5) #[1]
	Nref	= 3.0000e+19	# [cm^-3]
	alpha	= 0.65	# [1]
	Dop	= 6.0000e+08	# [eV/cm]
	Dac_cl	= 1.6000e-05	# [eVs/cm]
  * 
  * Stress-induced change of delta2 electron mass proposed by TU Vienna.
  * The model is based on 2 band k.p theory for electron bands,
  * k.p parameters of the model are defined in LatticeParameters section. 
  * me_l0 and me_t0 are unstressed longitudinal and transverse effective masses:
	me_l0	= 3.75	# [1]
	me_t0	= 0.363	# [1]
  * 
  * Relaxed effective masses of electrons in L-valleys:
	me_l0_l	= 1.634	# [1]
	me_t0_l	= 0.108	# [1]
  * 
  * Relaxed effective mass of electrons in Gamma-valley:
	me0_gamma	= 0.0244	# [1]
  * 
  * Stress-induced hole channel mobility model.
  * The model is based on 6 band k.p hole bands and MLDA channel quantization,
  * k.p parameters of the model are defined in LatticeParameters section. 
	Ephonon_h	= 0.03	# [eV]
	Dop_h	= 6.0000e+08	# [eV/cm]
	Dac_cl_h	= 1.0000e-05	# [eVs/cm]
	beta_h	= 1.0000e+10	# [1]
	beta_mlda_h	= (3, 1.5, 2.5) #[1]
	Nref_h	= 3.0000e+19	# [cm^-3]
	alpha_h	= 0.85	# [1]
  * 
  * Stress-induced hole mobility model is proposed by Intel:
  * the hole band structure in 100 plane is described by two ellipsoids directed in 
  * 110 and -110 directions, the multiplication factor of hole mobility in 110 direction
  * is the following:
  *             fh_110 = (f_110/mh_l0+f_'110/mh_t'110)/(0.5/mh_l0+0.5/mh_t0),
  * where:
  *   f_110 = 1/(1+exp(delta/kT), f_'110 = 1/(1+exp(-delta/kT) - occupation of
  *           the ellipsoids if just two (ne) considered in the hole band
  *   mh_l0 is the hole longitudinal mass in the ellipsoid at no stress
  *   mh_t0 is the hole transverse mass in the ellipsoid at no stress
  *   delta is stress-induced energy split between the ellipsoids
  * 
  *   delta = d1*s
  *   mh_t110 = mh_t0/(1-st1*s+st2*s^2+bt1*b+bt2*b^2)
  *   mh_t'110 = mh_t0/(1+st1*s+st2*s^2+bt1*b+bt2*b^2)
  *      (s is shear and b is biaxial components of the stress)
  * 
  * Modification of the Intel model:
  *   1) considered three 100 plans (6 ellipsoids)
  *   2) ne is number of ellipsoids in the occupation functions fh*
  *   3) considered mass in 100 direction: mh_t100 = mh_t0/(1+btt*b)
	mh_l0	= 0.48	# [1]
	mh_t0	= 0.15	# [1]
	d1	= -6.0000e-11	# [eV/Pa]
	st1	= -9.4426e-10	# [1/Pa]
	st2	= 4.3066e-19	# [1/Pa^2]
	bt1	= -1.0086e-10	# [1/Pa]
	bt2	= 6.5886e-21	# [1/Pa^2]
	btt	= 1.2000e-10	# [1/Pa]
	ne	= 2	# [1]
}


}

Material = "InAsP" {
*  Mole dependent material: InAsP (x=0) = InP
*  Mole dependent material: InAsP (x=1) = InAs

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.22	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InAs) + (1-x) * P(InP)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "InAsSb" {
*  Mole dependent material: InAsSb (x=0) = InAs
*  Mole dependent material: InAsSb (x=1) = InSb

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.892	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InSb) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "InGaAs" {
*  Mole dependent material: InGaAs (x=0) = InAs
*  Mole dependent material: InGaAs (x=1) = GaAs

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 14.55	# [1]
	epsilon(1)	= 13.18	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 14.55	# [1]
	epsilon(1)	= 13.18	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	refractiveindex(0)	= 3.892	# [1]
	refractiveindex(1)	= 3.5108	# [1]
	alpha(0)	= 2.0000e-04	# [1/K]
	alpha(1)	= 4.0000e-04	# [1/K]
	CarrDepCoeff(0)	= 1	# [1]
	CarrDepCoeff(1)	= 1	# [1]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0(0)	= 3.892	# [1]
	n_0(1)	= 3.5108	# [1]
	k_0(0)	= 0.0000e+00	# [1]
	k_0(1)	= 0.0000e+00	# [1]
	Cn_lambda(0)	= 0.0000e+00	# [um^-1]
	Cn_lambda(1)	= 0.0000e+00	# [um^-1]
	Dn_lambda(0)	= 0.0000e+00	# [um^-2]
	Dn_lambda(1)	= 0.0000e+00	# [um^-2]
	Ck_lambda(0)	= 0.0000e+00	# [um^-1]
	Ck_lambda(1)	= 0.0000e+00	# [um^-1]
	Dk_lambda(0)	= 0.0000e+00	# [um^-2]
	Dk_lambda(1)	= 0.0000e+00	# [um^-2]
	Cn_temp(0)	= 2.0000e-04	# [K^-1]
	Cn_temp(1)	= 4.0000e-04	# [K^-1]
	Cn_carr(0)	= 1	# [1]
	Cn_carr(1)	= 1	# [1]
	Cn_gain(0)	= 0.0000e+00	# [1]
	Cn_gain(1)	= 0.0000e+00	# [1]
	Npar(0)	= 1.0000e+18	# [cm^-3]
	Npar(1)	= 1.0000e+18	# [cm^-3]
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	Ck_carr(0)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Ck_carr(1)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Gamma_k_carr(0)	= 1,	1	#[1]
	Gamma_k_carr(1)	= 1,	1	#[1]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	cv(0)	= 1.6	# [J/(Kcm^3)]
	cv(1)	= 1.6	# [J/(Kcm^3)]
	cv_b(0)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_b(1)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_c(0)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_c(1)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_d(0)	= 0.0000e+00	# [J/(K^4*cm^3)]
	cv_d(1)	= 0.0000e+00	# [J/(K^4*cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 3.7	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 2.17391	# [(K cm)/W]
	B(1/kappa(1))	= -2.3000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 3.7	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 2.17391	# [(K cm)/W]
	B(1/kappa(1))	= -2.3000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter dEg0(OldSlotboom):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(OldSlotboom)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 1	# [1]
	dEg0(OldSlotboom)(1)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(1))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(1))	= 0.0000e+00	# [eV]

	* parameter dEg0(Slotboom):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(Slotboom)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 1	# [1]
	dEg0(Slotboom)(1)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(1))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(1))	= 0.0000e+00	# [eV]

	* parameter dEg0(delAlamo):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(delAlamo)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 1	# [1]
	dEg0(delAlamo)(1)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(1))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(1))	= 0.0000e+00	# [eV]

	* parameter dEg0(Bennett):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(Bennett)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 1	# [1]
	dEg0(Bennett)(1)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(1))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(1))	= 0.0000e+00	# [eV]

	* parameter Eg0:
	Xmax(0)	= 0.0000e+00	# [1]
	Eg0(0)	= 0.355482	# [eV]
	Xmax(1)	= 1	# [1]
	Eg0(1)	= 1.42248	# [eV]
	B(Eg0(1))	= 0.555	# [eV]
	C(Eg0(1))	= 0.0000e+00	# [eV]

	* parameter Bgn2Chi:
	Xmax(0)	= 0.0000e+00	# [1]
	Bgn2Chi(0)	= 0.5	# [1]
	Xmax(1)	= 1	# [1]
	Bgn2Chi(1)	= 0.5	# [1]
	B(Bgn2Chi(1))	= 0.0000e+00	# [1]
	C(Bgn2Chi(1))	= 0.0000e+00	# [1]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha(0)	= 3.3500e-04	# [eV/K]
	Xmax(1)	= 1	# [1]
	alpha(1)	= 5.4050e-04	# [eV/K]
	B(alpha(1))	= 0.0000e+00	# [eV/K]
	C(alpha(1))	= 0.0000e+00	# [eV/K]

	* parameter alpha2:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha2(0)	= 0.0000e+00	# [eV/K]
	Xmax(1)	= 1	# [1]
	alpha2(1)	= 0.0000e+00	# [eV/K]
	B(alpha2(1))	= 0.0000e+00	# [eV/K]
	C(alpha2(1))	= 0.0000e+00	# [eV/K]

	* parameter beta:
	Xmax(0)	= 0.0000e+00	# [1]
	beta(0)	= 2.4800e+02	# [K]
	Xmax(1)	= 1	# [1]
	beta(1)	= 2.0400e+02	# [K]
	B(beta(1))	= 0.0000e+00	# [K]
	C(beta(1))	= 0.0000e+00	# [K]

	* parameter beta2:
	Xmax(0)	= 0.0000e+00	# [1]
	beta2(0)	= 0.0000e+00	# [K]
	Xmax(1)	= 1	# [1]
	beta2(1)	= 0.0000e+00	# [K]
	B(beta2(1))	= 0.0000e+00	# [K]
	C(beta2(1))	= 0.0000e+00	# [K]

	* parameter Chi0:
	Xmax(0)	= 0.0000e+00	# [1]
	Chi0(0)	= 4.92751	# [eV]
	Xmax(1)	= 1	# [1]
	Chi0(1)	= 4.11826	# [eV]
	B(Chi0(1))	= 0.0000e+00	# [eV]
	C(Chi0(1))	= 0.0000e+00	# [eV]

	* parameter WorkFunction:
	Xmax(0)	= 0.0000e+00	# [1]
	WorkFunction(0)	= 4.25	# [eV]
	Xmax(1)	= 1	# [1]
	WorkFunction(1)	= 4.25	# [eV]
	B(WorkFunction(1))	= 0.0000e+00	# [eV]
	C(WorkFunction(1))	= 0.0000e+00	# [eV]

	* parameter FermiEnergy:
	Xmax(0)	= 0.0000e+00	# [1]
	FermiEnergy(0)	= 11.7	# [eV]
	Xmax(1)	= 1	# [1]
	FermiEnergy(1)	= 11.7	# [eV]
	B(FermiEnergy(1))	= 0.0000e+00	# [eV]
	C(FermiEnergy(1))	= 0.0000e+00	# [eV]

	* parameter EgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	EgMin(0)	= -1.0000e+01	# [eV]
	Xmax(1)	= 1	# [1]
	EgMin(1)	= -1.0000e+01	# [eV]
	B(EgMin(1))	= 0.0000e+00	# [eV]
	C(EgMin(1))	= 0.0000e+00	# [eV]

	* parameter dEgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	dEgMin(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 1	# [1]
	dEgMin(1)	= 0.0000e+00	# [eV]
	B(dEgMin(1))	= 0.0000e+00	# [eV]
	C(dEgMin(1))	= 0.0000e+00	# [eV]

}


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

JainRoulston
{ * deltaEg = A_i N^(1/3) + B_i N^(1/4) + C_i N^(1/2) + D_i N^(1/2)
  * where i is n for n-type or p for p-type
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A_n(0)	= 0.0000e+00	# [eV cm]
	A_n(1)	= 0.0000e+00	# [eV cm]
	B_n(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_n(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	A_p(0)	= 0.0000e+00	# [eV cm]
	A_p(1)	= 0.0000e+00	# [eV cm]
	B_p(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_p(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	fcaalpha_n(0)	= 4.0000e-18	# [cm^2]
	fcaalpha_n(1)	= 4.0000e-18	# [cm^2]
	fcaalpha_p(0)	= 8.0000e-18	# [cm^2]
	fcaalpha_p(1)	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	gamma_1(0)	= 20.4	# [1]
	gamma_1(1)	= 6.85	# [1]
	gamma_2(0)	= 8.3	# [1]
	gamma_2(1)	= 2.1	# [1]
	gamma_3(0)	= 9.1	# [1]
	gamma_3(1)	= 2.9	# [1]
	so(0)	= 0.38	# [eV]
	so(1)	= 0.34	# [eV]
	ep_te(0)	= 21.5	# [eV]
	ep_te(1)	= 28.8	# [eV]
	ep_tm(0)	= 21.5	# [eV]
	ep_tm(1)	= 28.8	# [eV]
	A1(0)	= 0.0000e+00	# [1]
	A1(1)	= 0.0000e+00	# [1]
	A2(0)	= 0.0000e+00	# [1]
	A2(1)	= 0.0000e+00	# [1]
	A3(0)	= 0.0000e+00	# [1]
	A3(1)	= 0.0000e+00	# [1]
	A4(0)	= 0.0000e+00	# [1]
	A4(1)	= 0.0000e+00	# [1]
	A5(0)	= 0.0000e+00	# [1]
	A5(1)	= 0.0000e+00	# [1]
	A6(0)	= 0.0000e+00	# [1]
	A6(1)	= 0.0000e+00	# [1]
	cr(0)	= 0.0000e+00	# [eV]
	cr(1)	= 0.0000e+00	# [eV]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a_nu(0)	= 1	# [eV]
	a_nu(1)	= 1.16	# [eV]
	a_c(0)	= -5.0800e+00	# [eV]
	a_c(1)	= -7.1700e+00	# [eV]
	b_shear(0)	= -1.8000e+00	# [eV]
	b_shear(1)	= -1.7000e+00	# [eV]
	C_11(0)	= 8.329	# [1e-2 GPa]
	C_11(1)	= 11.879	# [1e-2 GPa]
	C_12(0)	= 4.526	# [1e-2 GPa]
	C_12(1)	= 5.376	# [1e-2 GPa]
	eps(0)	= 0.0000e+00	# [1]
	eps(1)	= 0.0000e+00	# [1]
	a0(0)	= 6.0583e-10	# [m]
	a0(1)	= 5.6533e-10	# [m]
	alpha(0)	= 2.7400e-15	# [m/K]
	alpha(1)	= 3.8800e-15	# [m/K]
	D1(0)	= 0.0000e+00	# [eV]
	D1(1)	= 0.0000e+00	# [eV]
	D2(0)	= 0.0000e+00	# [eV]
	D2(1)	= 0.0000e+00	# [eV]
	D3(0)	= 0.0000e+00	# [eV]
	D3(1)	= 0.0000e+00	# [eV]
	D4(0)	= 0.0000e+00	# [eV]
	D4(1)	= 0.0000e+00	# [eV]
	C_13(0)	= 0.0000e+00	# [1e-2 GPa]
	C_13(1)	= 0.0000e+00	# [1e-2 GPa]
	C_33(0)	= 0.0000e+00	# [1e-2 GPa]
	C_33(1)	= 0.0000e+00	# [1e-2 GPa]
	c0(0)	= 0.0000e+00	# [cm]
	c0(1)	= 0.0000e+00	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.1905	# [1]
	a(1)	= 0.1905	# [1]
	ml(0)	= 0.9163	# [1]
	ml(1)	= 0.9163	# [1]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nc300(0)	= 8.7200e+16	# [cm-3]
	Nc300(1)	= 4.4200e+17	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.443587	# [1]
	a(1)	= 0.443587	# [1]
	b(0)	= 3.6095e-03	# [K^-1]
	b(1)	= 3.6095e-03	# [K^-1]
	c(0)	= 1.1735e-04	# [K^-2]
	c(1)	= 1.1735e-04	# [K^-2]
	d(0)	= 1.2632e-06	# [K^-3]
	d(1)	= 1.2632e-06	# [K^-3]
	e(0)	= 3.0256e-09	# [K^-4]
	e(1)	= 3.0256e-09	# [K^-4]
	f(0)	= 4.6834e-03	# [K^-1]
	f(1)	= 4.6834e-03	# [K^-1]
	g(0)	= 2.2869e-04	# [K^-2]
	g(1)	= 2.2869e-04	# [K^-2]
	h(0)	= 7.4693e-07	# [K^-3]
	h(1)	= 7.4693e-07	# [K^-3]
	i(0)	= 1.7275e-09	# [K^-4]
	i(1)	= 1.7275e-09	# [K^-4]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nv300(0)	= 6.6600e+18	# [cm-3]
	Nv300(1)	= 8.4700e+18	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A(0)	= 4.22	# [1]
	A(1)	= 4.22	# [1]
	B(0)	= 0.6084	# [1]
	B(1)	= 0.6084	# [1]
	C(0)	= 23.058	# [1]
	C(1)	= 23.058	# [1]
	ml(0)	= 0.024	# [1]
	ml(1)	= 0.074	# [1]
	mh(0)	= 0.41	# [1]
	mh(1)	= 0.62	# [1]
	me(0)	= 0.0000e+00	# [1]
	me(1)	= 0.0000e+00	# [1]
	eoffset(0)	= 0.0000e+00	# [eV]
	eoffset(1)	= 0.0000e+00	# [eV]
	hoffset(0)	= 0.0000e+00	# [eV]
	hoffset(1)	= 0.0000e+00	# [eV]
}


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1.5,	1.5	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 2.2600e+04,	2.5000e+02	#[cm^2/(Vs)]
	mumax(1)	= 8.5000e+03,	4.0000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1.5,	1.5	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 2.2600e+04,	2.5000e+02	#[cm^2/(Vs)]
	mumax(1)	= 8.5000e+03,	4.0000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

MultiValley
{ * Arbitrary number of electron and hole valleys can be defined. 
  * Electron density is written as: n=Nc*sum{d_i*F1/2((Ef-Ec-dEc_i)/kT)}, 
  * where dEc_i is energy shift, d_i is DOS factor (defined by valley masses 
  * and degeneracy) of valley i. To specify one valley the energy shift 
  * in respect to band edge, degeneracy, non parabolicity, effective masses, 
  * and valley orientation should be defined. The interface quantization mass
  * (for MLDA model) will be compute automatically (using valley inverse mass 
  * tensor and interface orientation). If the quantization mass is specified, 
  * then it'll be independent of the interface orientation.
	eValley"Gamma"(m=0.0244 energy=0.0000e+00 alpha=1.39 degeneracy=1 xid=-1.0200e+01) 
	eValley"L1"(1,1,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L2"(-1.0000e+00,1,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L3"(1,-1.0000e+00,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L4"(1,1,-1.0000e+00)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"X1"(1,0.0000e+00,0.0000e+00)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 degeneracy=1 xiu=4.5 xid=1.6) 
	eValley"X2"(0.0000e+00,1,0.0000e+00)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 degeneracy=1 xiu=4.5 xid=1.6) 
	eValley"X3"(0.0000e+00,0.0000e+00,1)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 degeneracy=1 xiu=4.5 xid=1.6) 
	hValley"LH"(m=0.082 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(m=0.51 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	Xmax(0) = 0.0
	Xmax(1) = 1
	eValley"Gamma"(1)(m=0.065 energy=0.0000e+00 alpha=0.61 degeneracy=1 xid=-1.1000e+01) 
	eValley"L1"(1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L2"(1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L3"(1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L4"(1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"X1"(1)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	eValley"X2"(1)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	eValley"X3"(1)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	hValley"LH"(1)(m=0.026 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(1)(m=0.41 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
}

LatticeParameters
{ * Crystal system, elasticity, and deformation potential are defined.
  * X and Y vectors define the simulation coordinate system relative to the
  * crystal orientation system. Also there is an option to represent the crystal
  * system relative to the simulation one. In this case a keyword CrystalAxis 
  * has to be in this section and X and Y vectors will represent [100] and [010]
  * axis of the crystal system in the simulation one.
  * Additional notes: 1 Pa = 10 dyn/cm^2; tensile stress/strain is positive. 
  *  
  * S[i][j] - elasticity modulus; i,j = 1,2,...6 and j>=i.
  * CrystalSystem is symmetry, used ONLY to define the elasticity matrics.
  *   Cubic (CrystalSystem=0): S[1][1],S[1][2],S[4][4]
  *   Hexagonal (CrystalSystem=1): S[1][1],S[1][2],S[1][3],S[3][3],S[4][4]
  * 
	X	= (1, 0.0000e+00, 0.0000e+00) #[1]
	Y	= (0.0000e+00, 1, 0.0000e+00) #[1]
	S[1][1]	= 1.9	# [1e-12 cm^2/din]
	S[1][2]	= -6.9000e-01	# [1e-12 cm^2/din]
	S[4][4]	= 2.5	# [1e-12 cm^2/din]
	CrystalSystem	= 0	# [1]

  * Deformation potentials of 2 k.p model for electron delta-valleys 
	xis	= 0.0000e+00	# [eV]
	dbs	= 0.0000e+00	# [eV]
	xiu	= 4.5	# [eV]
	xid	= 1.6	# [eV]
	Mkp	= 1	# [1]

  * Deformation potentials of 6 k.p model for hole bands
	adp	= 1	# [eV]
	bdp	= -1.8000e+00	# [eV]
	ddp	= -3.6000e+00	# [eV]
	dso	= 0.394	# [eV]

  * Luttinger parameters
	gamma_1	= 14.46	# [1]
	gamma_2	= 5.74	# [1]
	gamma_3	= 6.59	# [1]

  * Deformation potentials and energy (in reference to delta-valley) for L-valleys 
	xiu_l	= 9.5	# [eV]
	xid_l	= -2.0000e+00	# [eV]
	e_l	= -3.0000e-01	# [eV]

  * Deformation potentials and energy (in reference to delta-valley) for Gamma-valley 
	xid_gamma	= -1.0200e+01	# [eV]
	e_gamma	= -1.0100e+00	# [eV]
  * 
    Xmax(0) = 0.0 
    Xmax(1) = 1.0 
  * 
	S[1][1](1)	= 1.2	# [1e-12 cm^2/din]
	S[1][2](1)	= -3.6000e-01	# [1e-12 cm^2/din]
	S[4][4](1)	= 1.7	# [1e-12 cm^2/din]
  * 
	xis(1)	= 0.0000e+00	# [eV]
	dbs(1)	= 0.0000e+00	# [eV]
	xiu(1)	= 9.3	# [eV]
	xid(1)	= 1.1	# [eV]
	Mkp(1)	= 1	# [1]

  * 
	adp(1)	= -8.5000e-01	# [eV]
	bdp(1)	= -1.8500e+00	# [eV]
	ddp(1)	= -5.1000e+00	# [eV]
	dso(1)	= 0.347	# [eV]

  * 
	gamma_1(1)	= 7.02	# [1]
	gamma_2(1)	= 2.27	# [1]
	gamma_3(1)	= 2.99	# [1]

  * 
	xiu_l(1)	= 14.1	# [eV]
	xid_l(1)	= -2.0000e+00	# [eV]
	e_l(1)	= -1.9000e-01	# [eV]

  * 
	xid_gamma(1)	= -1.1000e+01	# [eV]
	e_gamma(1)	= -4.8000e-01	# [eV]
}


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

StressMobility
{ * Stress-induced electron channel mobility model.
  * The model is based on 2 band k.p theory for electron bands and 
  * intervalley/intravelly scattering model with acoustic and optical phonons.
	Ephonon	= 0.03	# [eV]
	beta	= 1.22	# [1]
	beta_mlda	= (1.5, 1.5, 1.5) #[1]
	Nref	= 3.0000e+19	# [cm^-3]
	alpha	= 0.65	# [1]
	Dop	= 6.0000e+08	# [eV/cm]
	Dac_cl	= 1.6000e-05	# [eVs/cm]
  * 
  * Stress-induced change of delta2 electron mass proposed by TU Vienna.
  * The model is based on 2 band k.p theory for electron bands,
  * k.p parameters of the model are defined in LatticeParameters section. 
  * me_l0 and me_t0 are unstressed longitudinal and transverse effective masses:
	me_l0	= 3.75	# [1]
	me_t0	= 0.363	# [1]
  * 
  * Relaxed effective masses of electrons in L-valleys:
	me_l0_l	= 1.634	# [1]
	me_t0_l	= 0.108	# [1]
  * 
  * Relaxed effective mass of electrons in Gamma-valley:
	me0_gamma	= 0.0244	# [1]
  * 
  * Stress-induced hole channel mobility model.
  * The model is based on 6 band k.p hole bands and MLDA channel quantization,
  * k.p parameters of the model are defined in LatticeParameters section. 
	Ephonon_h	= 0.03	# [eV]
	Dop_h	= 6.0000e+08	# [eV/cm]
	Dac_cl_h	= 1.0000e-05	# [eVs/cm]
	beta_h	= 1.0000e+10	# [1]
	beta_mlda_h	= (3, 1.5, 2.5) #[1]
	Nref_h	= 3.0000e+19	# [cm^-3]
	alpha_h	= 0.85	# [1]
  * 
  * Stress-induced hole mobility model is proposed by Intel:
  * the hole band structure in 100 plane is described by two ellipsoids directed in 
  * 110 and -110 directions, the multiplication factor of hole mobility in 110 direction
  * is the following:
  *             fh_110 = (f_110/mh_l0+f_'110/mh_t'110)/(0.5/mh_l0+0.5/mh_t0),
  * where:
  *   f_110 = 1/(1+exp(delta/kT), f_'110 = 1/(1+exp(-delta/kT) - occupation of
  *           the ellipsoids if just two (ne) considered in the hole band
  *   mh_l0 is the hole longitudinal mass in the ellipsoid at no stress
  *   mh_t0 is the hole transverse mass in the ellipsoid at no stress
  *   delta is stress-induced energy split between the ellipsoids
  * 
  *   delta = d1*s
  *   mh_t110 = mh_t0/(1-st1*s+st2*s^2+bt1*b+bt2*b^2)
  *   mh_t'110 = mh_t0/(1+st1*s+st2*s^2+bt1*b+bt2*b^2)
  *      (s is shear and b is biaxial components of the stress)
  * 
  * Modification of the Intel model:
  *   1) considered three 100 plans (6 ellipsoids)
  *   2) ne is number of ellipsoids in the occupation functions fh*
  *   3) considered mass in 100 direction: mh_t100 = mh_t0/(1+btt*b)
	mh_l0	= 0.48	# [1]
	mh_t0	= 0.15	# [1]
	d1	= -6.0000e-11	# [eV/Pa]
	st1	= -9.4426e-10	# [1/Pa]
	st2	= 4.3066e-19	# [1/Pa^2]
	bt1	= -1.0086e-10	# [1/Pa]
	bt2	= 6.5886e-21	# [1/Pa^2]
	btt	= 1.2000e-10	# [1/Pa]
	ne	= 2	# [1]
  * 
    Xmax(0) = 0.0 
    Xmax(1) = 1.0 
  * 
	me_l0(1)	= 1.714	# [1]
	me_t0(1)	= 0.26	# [1]
	me_l0_l(1)	= 1.521	# [1]
	me_t0_l(1)	= 0.129	# [1]
  * 
	me0_gamma(1)	= 0.065	# [1]
  * 
	Ephonon(1)	= 0.03	# [eV]
	beta(1)	= 1.22	# [1]
	beta_mlda(1)	= (1.5, 1.5, 1.5) #[1]
	Nref(1)	= 3.0000e+19	# [cm^-3]
	alpha(1)	= 0.65	# [1]
	Dop(1)	= 5.6000e+08	# [eV/cm]
	Dac_cl(1)	= 1.2000e-05	# [eVs/cm]
  * 
	Ephonon_h(1)	= 0.03	# [eV]
	Dop_h(1)	= 6.0000e+08	# [eV/cm]
	Dac_cl_h(1)	= 1.0000e-05	# [eVs/cm]
	beta_h(1)	= 1.0000e+10	# [1]
	beta_mlda_h(1)	= (3, 1.5, 2.5) #[1]
	Nref_h(1)	= 3.0000e+19	# [cm^-3]
	alpha_h(1)	= 0.85	# [1]
}


}

Material = "InGaAsP" {
*  Mole dependent material: InGaAsP (x=0,y=0) = InP
*  Mole dependent material: InGaAsP (x=1,y=0) = GaP
*  Mole dependent material: InGaAsP (x=1,y=1) = GaAs
*  Mole dependent material: InGaAsP (x=0,y=1) = InAs

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.22	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInP(x))) + 
*            y*(1-y)*(x*P(GaAsP(y))+(1-x)*P(InAsP(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "InGaAsSb" {
*  Mole dependent material: InGaAsSb (x=0,y=0) = InSb
*  Mole dependent material: InGaAsSb (x=1,y=0) = GaSb
*  Mole dependent material: InGaAsSb (x=1,y=1) = GaAs
*  Mole dependent material: InGaAsSb (x=0,y=1) = InAs

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following interpolation is applied between
*  four materials:
*       P = (x*(1-x)*(y*P(InGaAs(x))+(1-y)*P(GaInSb(x))) + 
*            y*(1-y)*(x*P(GaAsSb(y))+(1-x)*P(InAsSb(y))))/(x*(1-x)+y(1-y))
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "InGaN" {
*  Mole dependent material: InGaN (x=0) = GaN
*  Mole dependent material: InGaN (x=1) = InN

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	gamma_1(0)	= 6.85	# [1]
	gamma_1(1)	= 6.85	# [1]
	gamma_2(0)	= 2.1	# [1]
	gamma_2(1)	= 2.1	# [1]
	gamma_3(0)	= 2.9	# [1]
	gamma_3(1)	= 2.9	# [1]
	so(0)	= 1.0000e-03	# [eV]
	so(1)	= 0.014	# [eV]
	ep_te(0)	= 15.3	# [eV]
	ep_te(1)	= 18.8	# [eV]
	ep_tm(0)	= 15.6	# [eV]
	ep_tm(1)	= 12.4	# [eV]
	A1(0)	= -9.2400e+00	# [1]
	A1(1)	= -7.2400e+00	# [1]
	A2(0)	= -6.0000e-01	# [1]
	A2(1)	= -5.1000e-01	# [1]
	A3(0)	= 8.68	# [1]
	A3(1)	= 6.73	# [1]
	A4(0)	= -4.3400e+00	# [1]
	A4(1)	= -3.3600e+00	# [1]
	A5(0)	= -4.3200e+00	# [1]
	A5(1)	= -3.3500e+00	# [1]
	A6(0)	= -6.0800e+00	# [1]
	A6(1)	= -4.7200e+00	# [1]
	cr(0)	= 0.041	# [eV]
	cr(1)	= 0.019	# [eV]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a_nu(0)	= 0.19	# [eV]
	a_nu(1)	= 0.19	# [eV]
	a_c(0)	= -4.0800e+00	# [eV]
	a_c(1)	= -4.0800e+00	# [eV]
	b_shear(0)	= 0.9163	# [eV]
	b_shear(1)	= 0.9163	# [eV]
	C_11(0)	= 11.879	# [1e-2 GPa]
	C_11(1)	= 11.879	# [1e-2 GPa]
	C_12(0)	= 5.376	# [1e-2 GPa]
	C_12(1)	= 5.376	# [1e-2 GPa]
	eps(0)	= 0.0000e+00	# [1]
	eps(1)	= 0.0000e+00	# [1]
	a0(0)	= 3.5480e-10	# [m]
	a0(1)	= 3.1890e-10	# [m]
	alpha(0)	= 0.0000e+00	# [m/K]
	alpha(1)	= 0.0000e+00	# [m/K]
	D1(0)	= -8.9000e-01	# [eV]
	D1(1)	= -8.9000e-01	# [eV]
	D2(0)	= 4.27	# [eV]
	D2(1)	= 4.27	# [eV]
	D3(0)	= 5.18	# [eV]
	D3(1)	= 5.18	# [eV]
	D4(0)	= -2.5900e+00	# [eV]
	D4(1)	= -2.5900e+00	# [eV]
	C_13(0)	= 0.94	# [1e-2 GPa]
	C_13(1)	= 1	# [1e-2 GPa]
	C_33(0)	= 2	# [1e-2 GPa]
	C_33(1)	= 3.92	# [1e-2 GPa]
	c0(0)	= 5.7030e-10	# [cm]
	c0(1)	= 5.1850e-10	# [cm]
}


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

TransferredElectronEffect2:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	* parameter mu1:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	mu1(0)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(1)	= 0.2,	0.2	#[1]
	mu1(1)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(1))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(1))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(2)	= 0.5,	0.5	#[1]
	mu1(2)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(2))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(2))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(3)	= 0.8,	0.8	#[1]
	mu1(3)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(3))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(3))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(4)	= 1,	1	#[1]
	mu1(4)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(4))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(4))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]

	* parameter E0:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	E0(0)	= 2.2089e+05,	4.0000e+03	#[V/cm]
	Xmax(1)	= 0.2,	0.2	#[1]
	E0(1)	= 1.5189e+05,	4.0000e+03	#[V/cm]
	B(E0(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(2)	= 0.5,	0.5	#[1]
	E0(2)	= 9.3815e+04,	4.0000e+03	#[V/cm]
	B(E0(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(3)	= 0.8,	0.8	#[1]
	E0(3)	= 6.3430e+04,	4.0000e+03	#[V/cm]
	B(E0(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(4)	= 1,	1	#[1]
	E0(4)	= 5.2424e+04,	4.0000e+03	#[V/cm]
	B(E0(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]

	* parameter E1:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	E1(0)	= 2.2089e+05,	4.0000e+03	#[V/cm]
	Xmax(1)	= 0.2,	0.2	#[1]
	E1(1)	= 1.5189e+05,	4.0000e+03	#[V/cm]
	B(E1(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(2)	= 0.5,	0.5	#[1]
	E1(2)	= 9.3815e+04,	4.0000e+03	#[V/cm]
	B(E1(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(3)	= 0.8,	0.8	#[1]
	E1(3)	= 6.3430e+04,	4.0000e+03	#[V/cm]
	B(E1(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(4)	= 1,	1	#[1]
	E1(4)	= 5.2424e+04,	4.0000e+03	#[V/cm]
	B(E1(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.7857,	0.0000e+00	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	alpha(1)	= 0.767,	0.0000e+00	#[1]
	B(alpha(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	alpha(2)	= 0.7395,	0.0000e+00	#[1]
	B(alpha(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	alpha(3)	= 0.6725,	0.0000e+00	#[1]
	B(alpha(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	alpha(4)	= 0.6078,	0.0000e+00	#[1]
	B(alpha(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(4))	= 0.0000e+00,	0.0000e+00	#[1]

	* parameter beta:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	beta(0)	= 7.2044,	4	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	beta(1)	= 6.0373,	4	#[1]
	B(beta(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	beta(2)	= 4.8807,	4	#[1]
	B(beta(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	beta(3)	= 4.133,	4	#[1]
	B(beta(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	beta(4)	= 3.8501,	4	#[1]
	B(beta(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(4))	= 0.0000e+00,	0.0000e+00	#[1]

	* parameter gamma:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	gamma(0)	= 6.1973,	0.0000e+00	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	gamma(1)	= 5.1797,	0.0000e+00	#[1]
	B(gamma(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	gamma(2)	= 3.7387,	0.0000e+00	#[1]
	B(gamma(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	gamma(3)	= 2.7321,	0.0000e+00	#[1]
	B(gamma(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	gamma(4)	= 2.2623,	0.0000e+00	#[1]
	B(gamma(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(4))	= 0.0000e+00,	0.0000e+00	#[1]

}

TransferredElectronEffect2_aniso:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	* parameter mu1:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	mu1(0)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(1)	= 0.2,	0.2	#[1]
	mu1(1)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(1))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(1))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(2)	= 0.5,	0.5	#[1]
	mu1(2)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(2))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(2))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(3)	= 0.8,	0.8	#[1]
	mu1(3)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(3))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(3))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	Xmax(4)	= 1,	1	#[1]
	mu1(4)	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	B(mu1(4))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]
	C(mu1(4))	= 0.0000e+00,	0.0000e+00	#[cm^2/Vs]

	* parameter E0:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	E0(0)	= 2.2089e+05,	4.0000e+03	#[V/cm]
	Xmax(1)	= 0.2,	0.2	#[1]
	E0(1)	= 1.5189e+05,	4.0000e+03	#[V/cm]
	B(E0(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(2)	= 0.5,	0.5	#[1]
	E0(2)	= 9.3815e+04,	4.0000e+03	#[V/cm]
	B(E0(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(3)	= 0.8,	0.8	#[1]
	E0(3)	= 6.3430e+04,	4.0000e+03	#[V/cm]
	B(E0(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(4)	= 1,	1	#[1]
	E0(4)	= 5.2424e+04,	4.0000e+03	#[V/cm]
	B(E0(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E0(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]

	* parameter E1:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	E1(0)	= 2.2089e+05,	4.0000e+03	#[V/cm]
	Xmax(1)	= 0.2,	0.2	#[1]
	E1(1)	= 1.5189e+05,	4.0000e+03	#[V/cm]
	B(E1(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(1))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(2)	= 0.5,	0.5	#[1]
	E1(2)	= 9.3815e+04,	4.0000e+03	#[V/cm]
	B(E1(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(2))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(3)	= 0.8,	0.8	#[1]
	E1(3)	= 6.3430e+04,	4.0000e+03	#[V/cm]
	B(E1(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(3))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	Xmax(4)	= 1,	1	#[1]
	E1(4)	= 5.2424e+04,	4.0000e+03	#[V/cm]
	B(E1(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]
	C(E1(4))	= 0.0000e+00,	0.0000e+00	#[V/cm]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.7857,	0.0000e+00	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	alpha(1)	= 0.767,	0.0000e+00	#[1]
	B(alpha(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	alpha(2)	= 0.7395,	0.0000e+00	#[1]
	B(alpha(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	alpha(3)	= 0.6725,	0.0000e+00	#[1]
	B(alpha(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	alpha(4)	= 0.6078,	0.0000e+00	#[1]
	B(alpha(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(alpha(4))	= 0.0000e+00,	0.0000e+00	#[1]

	* parameter beta:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	beta(0)	= 7.2044,	4	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	beta(1)	= 6.0373,	4	#[1]
	B(beta(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	beta(2)	= 4.8807,	4	#[1]
	B(beta(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	beta(3)	= 4.133,	4	#[1]
	B(beta(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	beta(4)	= 3.8501,	4	#[1]
	B(beta(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(beta(4))	= 0.0000e+00,	0.0000e+00	#[1]

	* parameter gamma:
	Xmax(0)	= 0.0000e+00,	0.0000e+00	#[1]
	gamma(0)	= 6.1973,	0.0000e+00	#[1]
	Xmax(1)	= 0.2,	0.2	#[1]
	gamma(1)	= 5.1797,	0.0000e+00	#[1]
	B(gamma(1))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(1))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(2)	= 0.5,	0.5	#[1]
	gamma(2)	= 3.7387,	0.0000e+00	#[1]
	B(gamma(2))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(2))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(3)	= 0.8,	0.8	#[1]
	gamma(3)	= 2.7321,	0.0000e+00	#[1]
	B(gamma(3))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(3))	= 0.0000e+00,	0.0000e+00	#[1]
	Xmax(4)	= 1,	1	#[1]
	gamma(4)	= 2.2623,	0.0000e+00	#[1]
	B(gamma(4))	= 0.0000e+00,	0.0000e+00	#[1]
	C(gamma(4))	= 0.0000e+00,	0.0000e+00	#[1]

}


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(InN) + (1-x) * P(GaN)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "InN" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

	gamma_1	= 6.85	# [1]
	gamma_2	= 2.1	# [1]
	gamma_3	= 2.9	# [1]
	so	= 1.0000e-03	# [eV]
	ep_te	= 15.3	# [eV]
	ep_tm	= 15.6	# [eV]
	cr	= 0.041	# [eV]
	A1	= -9.2400e+00	# [1]
	A2	= -6.0000e-01	# [1]
	A3	= 8.68	# [1]
	A4	= -4.3400e+00	# [1]
	A5	= -4.3200e+00	# [1]
	A6	= -6.0800e+00	# [1]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.5480e-10	# [cm]
	alpha	= 0.0000e+00	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 0.19	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= 0.9163	# [eV]
	c_11	= 11.879	# [1e-2 GPa]
	c_12	= 5.376	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 0.94	# [1e-2 GPa]
	c_33	= 2	# [1e-2 GPa]
	c0	= 5.7030e-10	# [cm]
}

TransferredElectronEffect2:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	mu1	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	E0	= 5.2424e+04 ,	4.0000e+03	# [V/cm]
	E1	= 5.2424e+04 ,	4.0000e+03	# [V/cm]
	alpha	= 0.6078 ,	0.0000e+00	# [1]
	beta	= 3.8501 ,	4	# [1]
	gamma	= 2.2623 ,	0.0000e+00	# [1]
}

TransferredElectronEffect2_aniso:
{ * Transferred Electron Effect 2:
  *
  *                mu_lowfield + mu1 * (F/E0)^alpha + vsat * F^(beta-1) / E1^beta
  * mu_highfield = --------------------------------------------------------------
  *                            1 + gamma * (F/E0)^alpha + (F/E1)^beta
  *
	mu1	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	E0	= 5.2424e+04 ,	4.0000e+03	# [V/cm]
	E1	= 5.2424e+04 ,	4.0000e+03	# [V/cm]
	alpha	= 0.6078 ,	0.0000e+00	# [1]
	beta	= 3.8501 ,	4	# [1]
	gamma	= 2.2623 ,	0.0000e+00	# [1]
}

Piezoelectric_Polarization
{ * The 'strain' model computes the polarization vector as follows:
  * 
  *   [P_x]   [psp_x                                     ]
  *   [P_y] = [psp_y                                     ]
  *   [P_z]   [psp_z + 2*d31*strain*(c11+c12-2*c13^2/c33)] (Formula 1)
  *   [P_z]   [psp_z + 2*strain*(e31 - e33*c13/c33)      ] (Formula 2)
  * 
  *   strain = (1-relax)*(a0-a)/a
  * 
  * The 'stress' model computes the polarization vector as follows:
  * 
  *   [P_x]   [psp_x]   [d11 d12 d13 d14 d15 d16]   [stress_XX]
  *   [P_y] = [psp_y] + [d21 d22 d23 d24 d25 d26] * [stress_YY]
  *   [P_z]   [psp_z]   [d31 d32 d33 d34 d35 d36]   [stress_ZZ]
  *                                                 [stress_YZ]
  *                                                 [stress_XZ]
  *                                                 [stress_XY]
  * 
  * The Poisson equation is:
  * 
  *   div(eps*grad(phi)) = -ro + activation*div(P),
  *   where P = (P_x,P_y,P_z) - polarization vector
  * 
  * Parameters:
  * 
  *   activation: non negative real calibration parameter
  *               to scale the polarization charge [1], 
  *               this value can be set in a 'Physics' section of input file 
  * 
  *   [psp_x]: spontaneous polarization vector,
  *   [psp_y]  defined in crystal system [C/cm^2]
  *   [psp_z]
  * 
  *   c11, c12, c13, c33: stiffness constants,
  *                       defined in crystal system [Pa]
  * 
  *   e31, e33: strain-charge piezoelectric coefficients,
  *             defined in crystal system [C/cm^2]
  * 
  *   a0: strained lattice constant [Angstrem]
  *   a: unstrained lattice constant [Angstrem]
  *   relax: relaxation parameter [1]
  * 
  *   d11 ... d36: piezoelectric coefficients,
  *                defined in crystal system [cm/V]
  * 
  * Fields:
  * 
  *   [stress_XX]: stress tensor,
  *   [stress_YY]  defined in stress system [Pa]
  *   [stress_ZZ]
  *   [stress_YZ]
  *   [stress_XZ]
  *   [stress_XY]
  * 
  *   [P_x]: polarization vector,
  *   [P_y]  defined in simulation system [C/cm^2]
  *   [P_z]
  * 
  * Coordinate systems:
  * 
  *   The simulation system is defined relative to the crystal
  *   system.  For example:
  * 
  *     LatticeParameters {
  *       X = (1, 0,  0)
  *       Y = (0, 0, -1)
  *     }
  * 
  *   The stress coordinate system is defined relative to the simulation
  *   system.  For example:
  * 
  *     Physics {
  *       Piezo (
  *         OriKddX = (-0.96  0.28  0)
  *         OriKddY = ( 0.28  0.96  0)
  *         Stress = (1e9  2e9  3e9  4e9  5e9  6e9)  # [Pa]
  *       )
  *     }
  * 
  *   To compute the polarization vector, the stress tensor is first
  *   transformed from the stress system to the crystal system.  Then
  *   the polarization vector is evaluated according to the 'strain' or
  *   'stress' model above.  Finally, the polarization vector is transformed
  *   from the crystal system to the simulation system.
  * 
  * piezoelectric coefficients:
	d11	= 0.0000e+00	# [cm/V]
	d12	= 0.0000e+00	# [cm/V]
	d13	= 0.0000e+00	# [cm/V]
	d14	= 0.0000e+00	# [cm/V]
	d15	= 0.0000e+00	# [cm/V]
	d16	= 0.0000e+00	# [cm/V]
	d21	= 0.0000e+00	# [cm/V]
	d22	= 0.0000e+00	# [cm/V]
	d23	= 0.0000e+00	# [cm/V]
	d24	= 0.0000e+00	# [cm/V]
	d25	= 0.0000e+00	# [cm/V]
	d26	= 0.0000e+00	# [cm/V]
	d31	= -3.9000e-10	# [cm/V]
	d32	= -3.9000e-10	# [cm/V]
	d33	= 7.6000e-10	# [cm/V]
	d34	= 0.0000e+00	# [cm/V]
	d35	= 0.0000e+00	# [cm/V]
	d36	= 0.0000e+00	# [cm/V]
  * 
  * spontaneous polarization:
	psp_x	= 0.0000e+00	# [C/cm^2]
	psp_y	= 0.0000e+00	# [C/cm^2]
	psp_z	= -3.2000e-06	# [C/cm^2]
  * 
	Formula	= 1	# [1]
  * 
  * stiffness constants:
	c11	= 2.2300e+11	# [Pa]
	c12	= 1.1500e+11	# [Pa]
	c13	= 9.2000e+10	# [Pa]
	c33	= 2.2400e+11	# [Pa]
  * 
  * piezoelectric coefficients:
	e31	= -5.7000e-05	# [C/cm^2]
	e33	= 9.7000e-05	# [C/cm^2]
  * 
  * strain parameters:
	a0	= 3.189	# [Angstrem]
	a	= 3.54	# [Angstrem]
	relax	= 0.1	# [1]
}


}

Material = "InP" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 12.4	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 12.4	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 3.22	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.22	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 4.4	# [eV]
	Eg0	= 1.4205	# [eV]
	alpha	= 4.1000e-04	# [eV K^-1]
	beta	= 1.3600e+02	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

	gamma_1	= 4.95	# [1]
	gamma_2	= 1.65	# [1]
	gamma_3	= 2.35	# [1]
	so	= 0.11	# [eV]
	ep_te	= 20.7	# [eV]
	ep_tm	= 20.7	# [eV]
	cr	= 0.019	# [eV]
	A1	= -7.2400e+00	# [1]
	A2	= -5.1000e-01	# [1]
	A3	= 6.73	# [1]
	A4	= -3.3600e+00	# [1]
	A5	= -3.3500e+00	# [1]
	A6	= -4.7200e+00	# [1]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 2.7900e-15	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 1.27	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= -1.7000e+00	# [eV]
	c_11	= 10.11	# [1e-2 GPa]
	c_12	= 5.61	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
	Nc300	= 5.6600e+17	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
	Nv300	= 2.0300e+19	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.089	# [1]
	mh	= 0.85	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 4.5000e+03 ,	1.5000e+02	# [cm^2/(Vs)]
	Exponent	= 1.5 ,	1.5	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 4.5000e+03 ,	1.5000e+02	# [cm^2/(Vs)]
	Exponent	= 1.5 ,	1.5	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 4.5000e+03 ,	1.5000e+02	# [cm^2/Vs]
	Ar_alm  	= -1.5000e+00 ,	-1.5000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 2 ,	2	# [1]
  * If formula=2, model suggested by Arora is used:
  * mu_dop = muminA + mudA/(1.+(N/N00)^AA),
  * where muminA=Ar_mumin*(T/T0)^Ar_alm; mudA = Ar_mud*(T/T0)^Ar_ald
  * N is net doping
  * N00=Ar_N0*(T/T0)^Ar_alN; AA = Ar_a*(T/T0)^Ar_ala
	Ar_mumin	= 4.5000e+03 ,	1.5000e+02	# [cm^2/Vs]
	Ar_alm  	= -1.5000e+00 ,	-1.5000e+00	# [1]
	Ar_mud  	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Ar_ald  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_N0   	= 1.0000e+17 ,	1.0000e+17	# [cm^(-3)]
	Ar_alN  	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_a    	= 0.0000e+00 ,	0.0000e+00	# [1]
	Ar_ala  	= 0.0000e+00 ,	0.0000e+00	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.0000e+07 ,	1.0000e+07	# [1]
	B_vsat	= 0.0000e+00 ,	0.0000e+00	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
	A_vsat	= 1.0000e+07 ,	1.0000e+07	# [1]
	B_vsat	= 0.0000e+00 ,	0.0000e+00	# [1]
	vsat_min	= 5.0000e+05 ,	5.0000e+05	# [1]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 12.4 ,	12.4	# [1]
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}


}

Material = "InSb" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "Insulator1" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.97	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1.97	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.67	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "Insulator2" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.97	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1.97	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.67	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "Insulator3" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.97	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1.97	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.67	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "InsulatorX" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.97	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1.97	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


************************* Ferroelectric Parameters: ***************************
*******************************************************************************

Polarization
{ * Remanent polarization P_r, saturation polarization P_s, 
  * and coercive field F_c for x,y,z direction (crystal axes)
	P_r	= (1.0000e-05, 1.0000e-05, 1.0000e-05) #[C/cm^2]
	P_s	= (2.0000e-05, 2.0000e-05, 2.0000e-05) #[C/cm^2]
	F_c	= (2.5000e+04, 2.5000e+04, 2.5000e+04) #[V/cm]
  * Relaxation time for the auxiliary field tau_E, relaxation
  * time for the polarization tau_P, nonlinear coupling kn.
	tau_E	= (0.0000e+00, 0.0000e+00, 0.0000e+00) #[s]
	tau_P	= (0.0000e+00, 0.0000e+00, 0.0000e+00) #[s]
	kn	= (0.0000e+00, 0.0000e+00, 0.0000e+00) #[cm*s/V]
}


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.67	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "InterfacialOxide" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.46	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1.46	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.051	0.804	0.322;
          0.053	0.811	0.366;
          0.055	0.822	0.408;
          0.056	0.829	0.43;
          0.058	0.843	0.47;
          0.059	0.851	0.482;
          0.0636	0.879	0.613;
          0.0653	0.902	0.645;
          0.067	0.927	0.677;
          0.0689	0.957	0.712;
          0.0699	0.975	0.731;
          0.0709	0.999	0.75;
          0.0719	1.03	0.763;
          0.0729	1.072	0.768;
          0.074	1.124	0.765;
          0.0751	1.137	0.755;
          0.0763	1.156	0.737;
          0.0775	1.172	0.717;
          0.0787	1.178	0.703;
          0.08	1.172	0.696;
          0.0813	1.167	0.699;
          0.0827	1.168	0.711;
          0.0841	1.175	0.739;
          0.0855	1.195	0.771;
          0.087	1.225	0.799;
          0.0886	1.265	0.808;
          0.0902	1.32	0.795;
          0.0919	1.363	0.775;
          0.0936	1.371	0.755;
          0.0954	1.368	0.747;
          0.0972	1.372	0.766;
          0.0992	1.383	0.793;
          0.1012	1.41	0.824;
          0.1033	1.475	0.861;
          0.1051	1.554	0.874;
          0.1069	1.635	0.859;
          0.1088	1.716	0.81;
          0.1127	1.739	0.569;
          0.1137	1.687	0.565;
          0.1148	1.587	0.618;
          0.1159	1.513	0.725;
          0.117	1.492	0.914;
          0.1181	1.567	1.11;
          0.1187	1.645	1.136;
          0.1192	1.772	1.13;
          0.1198	1.919	1.045;
          0.1204	2.048	0.925;
          0.121	2.152	0.81;
          0.1215	2.24	0.715;
          0.1228	2.332	0.46;
          0.124	2.33	0.323;
          0.1252	2.292	0.236;
          0.1265	2.243	0.168;
          0.1278	2.19	0.119;
          0.1291	2.14	0.077;
          0.1319	2.047	0.043;
          0.1333	2.006	0.0339;
          0.1348	1.969	0.0271;
          0.1362	1.935	0.0228;
          0.1378	1.904	0.0189;
          0.1393	1.876	0.0156;
          0.1409	1.85	0.0132;
          0.1425	1.825	0.0109;
          0.1442	1.803	8.3800e-03;
          0.1459	1.783	5.5700e-03;
          0.1476	1.764	3.1700e-03;
          0.1494	1.747	1.4000e-03;
          0.1512	1.73	4.6300e-04;
          0.1531	1.716	1.2200e-04;
          0.155	1.702	3.2000e-05;
          0.159	1.676	4.7000e-06;
          0.1631	1.653	0.0000e+00;
          0.1675	1.633	0.0000e+00;
          0.1722	1.616	0.0000e+00;
          0.1771	1.6	0.0000e+00;
          0.1837	1.582	0.0000e+00;
          0.1907	1.567	0.0000e+00;
          0.1984	1.554	0.0000e+00;
          0.2066	1.543	0.0000e+00;
          0.2144	1.53371	0.0000e+00;
          0.2267	1.52276	0.0000e+00;
          0.2302	1.52009	0.0000e+00;
          0.2378	1.51474	0.0000e+00;
          0.2399	1.51338	0.0000e+00;
          0.2483	1.50841	0.0000e+00;
          0.2652	1.50004	0.0000e+00;
          0.2699	1.49805	0.0000e+00;
          0.2753	1.49592	0.0000e+00;
          0.2803	1.49404	0.0000e+00;
          0.2894	1.49099	0.0000e+00;
          0.2967	1.48873	0.0000e+00;
          0.30215	1.48719	0.0000e+00;
          0.3303	1.48053	0.0000e+00;
          0.33415	1.47976	0.0000e+00;
          0.3404	1.47858	0.0000e+00;
          0.3466	1.47746	0.0000e+00;
          0.36105	1.47512	0.0000e+00;
          0.365	1.47453	0.0000e+00;
          0.40465	1.46961	0.0000e+00;
          0.4358	1.46669	0.0000e+00;
          0.4678	1.46429	0.0000e+00;
          0.4861	1.46313	0.0000e+00;
          0.5086	1.46197	0.0000e+00;
          0.5461	1.46008	0.0000e+00;
          0.577	1.45885	0.0000e+00;
          0.5791	1.45877	0.0000e+00;
          0.5876	1.45847	0.0000e+00;
          0.5893	1.45841	0.0000e+00;
          0.64385	1.45671	0.0000e+00;
          0.6563	1.45637	0.0000e+00;
          0.6678	1.45608	0.0000e+00;
          0.7065	1.45515	0.0000e+00;
          0.8521	1.45248	0.0000e+00;
          0.89435	1.45185	0.0000e+00;
          1.014	1.45025	0.0000e+00;
          1.0829	1.44941	0.0000e+00;
          1.1287	1.44888	0.0000e+00;
          1.3622	1.44621	0.0000e+00;
          1.3951	1.44584	0.0000e+00;
          1.4695	1.44497	0.0000e+00;
          1.5295	1.44427	0.0000e+00;
          1.6606	1.44267	0.0000e+00;
          1.681	1.44241	0.0000e+00;
          1.6932	1.44226	0.0000e+00;
          1.7091	1.44205	0.0000e+00;
          1.8131	1.44069	0.0000e+00;
          1.9701	1.43851	0.0000e+00;
          2.0581	1.43722	0.0000e+00;
          2.1526	1.43576	0.0000e+00;
          2.3254	1.43292	0.0000e+00;
          2.4374	1.43095	0.0000e+00;
          3.2439	1.41314	0.0000e+00;
          3.2668	1.41253	0.0000e+00;
          3.3026	1.41155	0.0000e+00;
          3.422	1.40819	0.0000e+00;
          3.507	1.40568	0.0000e+00;
          3.5564	1.40418	0.0000e+00;
          10	1.4	0.0000e+00;
          10.001	1.4	0.0000e+00;
          10.002	1.4	0.0000e+00;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.67	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 0.9	# [eV]
	Eg0	= 9	# [eV]
	alpha	= 0.0000e+00	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "Iron" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "Metal" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 0.0000e+00	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 0.0000e+00	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 2.38	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 2.38	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 4.25	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	3	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}


MMPeltierHeat  
{ * Metal/Metal Peltier heat parameters 
  * Hpeltier = alpha*j*T*Pdiff   Peltier Heat
  * where: 
  *     j is the current density 
  *     alpha is an adjustable parameter 
  *     Pdiff is Seeback coefficients difference at interface 
	alpha	= 1	# [1]
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 2.4500e-06	# [ohm*cm]
	TempCoef	= 4.5000e-03	# [1/K]
}


}

Material = "Molybdenum" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 0.0000e+00	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 2.56	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.32	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.32	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 4.53	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 5.2000e-06	# [ohm*cm]
	TempCoef	= 4.3500e-03	# [1/K]
}


}

Material = "Nickel" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "NickelSilicide" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "Nitride" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 7.5	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 7.5	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 2.74	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 2.74	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.05166	0.655	0.42;
          0.05391	0.625	0.481;
          0.05636	0.611	0.56;
          0.05904	0.617	0.647;
          0.06199	0.635	0.743;
          0.06526	0.676	0.841;
          0.06888	0.735	0.936;
          0.07293	0.81	1.03;
          0.07749	0.902	1.11;
          0.08266	1.001	1.18;
          0.08856	1.111	1.26;
          0.09537	1.247	1.35;
          0.1033	1.417	1.43;
          0.1127	1.657	1.52;
          0.1181	1.827	1.53;
          0.124	2	1.49;
          0.1305	2.162	1.44;
          0.1378	2.326	1.32;
          0.1459	2.492	1.16;
          0.155	2.651	0.962;
          0.16	2.711	0.866;
          0.1653	2.753	0.75;
          0.171	2.766	0.612;
          0.1771	2.752	0.493;
          0.1837	2.724	0.38;
          0.1907	2.682	0.273;
          0.1984	2.62	0.174;
          0.2066	2.541	0.102;
          0.2156	2.464	0.057;
          0.2254	2.393	0.029;
          0.2362	2.331	0.011;
          0.248	2.278	4.9000e-03;
          0.261	2.234	1.2000e-03;
          0.2755	2.198	2.2000e-04;
          0.2917	2.167	0.0000e+00;
          0.31	2.141	0.0000e+00;
          0.3542	2.099	0.0000e+00;
          0.4133	2.066	0.0000e+00;
          0.4959	2.041	0.0000e+00;
          0.6199	2.022	0.0000e+00;
          0.8266	2.008	0.0000e+00;
          1.24	1.998	0.0000e+00;
          1.3	1.99	0.0000e+00;
          10.001	1.99	0.0000e+00;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 2.78	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.185	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.185	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 1.9	# [eV]
	Eg0	= 5	# [eV]
	alpha	= 0.0000e+00	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}

Makram-Ebeid
{ * mt tunneling mass 
  * Wph phonon energy 
  * Wt thermal energy 
  * Wopt optical energy of ionization 
  * SumNumber series expansion limit 
	mt	= 0.5 ,	0.5	# [1]
	Wph	= 0.06	# [eV]
	Wt	= 1.4	# [eV]
	Wopt	= 2.8	# [eV]
	SumNumber	= 49	# [1]
}

HoppingTransport:
{ * DOSShape: DensityOfState distribution (Gaussian = 0),
  * Nt: density of hopping sites (trapping sites),
  * EnS: energy distribution standard deviation,
  * En0: energy distribution peak from vacuum level,
  * BM: average number of neighboring sites,
  * Alpha: inverse of localization length,
  * Sigma0: constant conductivity,
  * HopFrequency: jump rate prefactor,
  * See the manual for more details.
	DOSShape	= 0 ,	0	# [1]
	Conc	= 1.0000e+19 ,	1.0000e-05	# [cm^-3]
	EnergySig	= 1.5 ,	1.5	# [eV]
	EnergyMid	= 4.4 ,	4.4	# [eV]
	BM	= 2.3 ,	2.3	# [1]
	Alpha	= 1.0000e+06 ,	1.0000e+06	# [cm^-1]
	Sigma0	= 1.0000e+12 ,	1.0000e+12	# [A*V^-1*cm^-1]
	HopFrequency	= 1.0000e+12 ,	1.0000e+12	# [s^-1]
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 3.0000e+09	# [ohm*cm]
	TempCoef	= 4.5000e-03	# [1/K]
}


}

Material = "Oxide" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.46	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1.46	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.051	0.804	0.322;
          0.053	0.811	0.366;
          0.055	0.822	0.408;
          0.056	0.829	0.43;
          0.058	0.843	0.47;
          0.059	0.851	0.482;
          0.0636	0.879	0.613;
          0.0653	0.902	0.645;
          0.067	0.927	0.677;
          0.0689	0.957	0.712;
          0.0699	0.975	0.731;
          0.0709	0.999	0.75;
          0.0719	1.03	0.763;
          0.0729	1.072	0.768;
          0.074	1.124	0.765;
          0.0751	1.137	0.755;
          0.0763	1.156	0.737;
          0.0775	1.172	0.717;
          0.0787	1.178	0.703;
          0.08	1.172	0.696;
          0.0813	1.167	0.699;
          0.0827	1.168	0.711;
          0.0841	1.175	0.739;
          0.0855	1.195	0.771;
          0.087	1.225	0.799;
          0.0886	1.265	0.808;
          0.0902	1.32	0.795;
          0.0919	1.363	0.775;
          0.0936	1.371	0.755;
          0.0954	1.368	0.747;
          0.0972	1.372	0.766;
          0.0992	1.383	0.793;
          0.1012	1.41	0.824;
          0.1033	1.475	0.861;
          0.1051	1.554	0.874;
          0.1069	1.635	0.859;
          0.1088	1.716	0.81;
          0.1127	1.739	0.569;
          0.1137	1.687	0.565;
          0.1148	1.587	0.618;
          0.1159	1.513	0.725;
          0.117	1.492	0.914;
          0.1181	1.567	1.11;
          0.1187	1.645	1.136;
          0.1192	1.772	1.13;
          0.1198	1.919	1.045;
          0.1204	2.048	0.925;
          0.121	2.152	0.81;
          0.1215	2.24	0.715;
          0.1228	2.332	0.46;
          0.124	2.33	0.323;
          0.1252	2.292	0.236;
          0.1265	2.243	0.168;
          0.1278	2.19	0.119;
          0.1291	2.14	0.077;
          0.1319	2.047	0.043;
          0.1333	2.006	0.0339;
          0.1348	1.969	0.0271;
          0.1362	1.935	0.0228;
          0.1378	1.904	0.0189;
          0.1393	1.876	0.0156;
          0.1409	1.85	0.0132;
          0.1425	1.825	0.0109;
          0.1442	1.803	8.3800e-03;
          0.1459	1.783	5.5700e-03;
          0.1476	1.764	3.1700e-03;
          0.1494	1.747	1.4000e-03;
          0.1512	1.73	4.6300e-04;
          0.1531	1.716	1.2200e-04;
          0.155	1.702	3.2000e-05;
          0.159	1.676	4.7000e-06;
          0.1631	1.653	0.0000e+00;
          0.1675	1.633	0.0000e+00;
          0.1722	1.616	0.0000e+00;
          0.1771	1.6	0.0000e+00;
          0.1837	1.582	0.0000e+00;
          0.1907	1.567	0.0000e+00;
          0.1984	1.554	0.0000e+00;
          0.2066	1.543	0.0000e+00;
          0.2144	1.53371	0.0000e+00;
          0.2267	1.52276	0.0000e+00;
          0.2302	1.52009	0.0000e+00;
          0.2378	1.51474	0.0000e+00;
          0.2399	1.51338	0.0000e+00;
          0.2483	1.50841	0.0000e+00;
          0.2652	1.50004	0.0000e+00;
          0.2699	1.49805	0.0000e+00;
          0.2753	1.49592	0.0000e+00;
          0.2803	1.49404	0.0000e+00;
          0.2894	1.49099	0.0000e+00;
          0.2967	1.48873	0.0000e+00;
          0.30215	1.48719	0.0000e+00;
          0.3303	1.48053	0.0000e+00;
          0.33415	1.47976	0.0000e+00;
          0.3404	1.47858	0.0000e+00;
          0.3466	1.47746	0.0000e+00;
          0.36105	1.47512	0.0000e+00;
          0.365	1.47453	0.0000e+00;
          0.40465	1.46961	0.0000e+00;
          0.4358	1.46669	0.0000e+00;
          0.4678	1.46429	0.0000e+00;
          0.4861	1.46313	0.0000e+00;
          0.5086	1.46197	0.0000e+00;
          0.5461	1.46008	0.0000e+00;
          0.577	1.45885	0.0000e+00;
          0.5791	1.45877	0.0000e+00;
          0.5876	1.45847	0.0000e+00;
          0.5893	1.45841	0.0000e+00;
          0.64385	1.45671	0.0000e+00;
          0.6563	1.45637	0.0000e+00;
          0.6678	1.45608	0.0000e+00;
          0.7065	1.45515	0.0000e+00;
          0.8521	1.45248	0.0000e+00;
          0.89435	1.45185	0.0000e+00;
          1.014	1.45025	0.0000e+00;
          1.0829	1.44941	0.0000e+00;
          1.1287	1.44888	0.0000e+00;
          1.3622	1.44621	0.0000e+00;
          1.3951	1.44584	0.0000e+00;
          1.4695	1.44497	0.0000e+00;
          1.5295	1.44427	0.0000e+00;
          1.6606	1.44267	0.0000e+00;
          1.681	1.44241	0.0000e+00;
          1.6932	1.44226	0.0000e+00;
          1.7091	1.44205	0.0000e+00;
          1.8131	1.44069	0.0000e+00;
          1.9701	1.43851	0.0000e+00;
          2.0581	1.43722	0.0000e+00;
          2.1526	1.43576	0.0000e+00;
          2.3254	1.43292	0.0000e+00;
          2.4374	1.43095	0.0000e+00;
          3.2439	1.41314	0.0000e+00;
          3.2668	1.41253	0.0000e+00;
          3.3026	1.41155	0.0000e+00;
          3.422	1.40819	0.0000e+00;
          3.507	1.40568	0.0000e+00;
          3.5564	1.40418	0.0000e+00;
          10	1.4	0.0000e+00;
          10.001	1.4	0.0000e+00;
          10.002	1.4	0.0000e+00;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.67	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 0.9	# [eV]
	Eg0	= 9	# [eV]
	alpha	= 0.0000e+00	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 0.0000e+00	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 0.0000e+00	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= 0.0000e+00	# [eV]
	c_11	= 0.0000e+00	# [1e-2 GPa]
	c_12	= 0.0000e+00	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


  HydrogenDiffusion {

    HydrogenAtom {
      charge   = 0	 # [1]
      hydrogen = 1	 # [1]
      d0       = 3.8000e-13	 # [cm^2/s]
      Ed       = 0.0000e+00	 # [eV]
      atd      = 1	 # [1]
      n0       = 0.0000e+00	 # [/cm^3]
      krec     = 0.0000e+00	 # [s^-1 or cm*s^-1]
    }

    HydrogenMolecule {
      charge   = 0	 # [1]
      hydrogen = 2	 # [1]
      d0       = 1.8000e-14	 # [cm^2/s]
      Ed       = 0.0000e+00	 # [eV]
      atd      = 1	 # [1]
      n0       = 0.0000e+00	 # [/cm^3]
      krec     = 0.0000e+00	 # [s^-1 or cm*s^-1]
    }

    HydrogenIon {
      charge   = 1	 # [1]
      hydrogen = 1	 # [1]
      d0       = 3.8000e-13	 # [cm^2/s]
      Ed       = 0.0000e+00	 # [eV]
      atd      = 1	 # [1]
      n0       = 0.0000e+00	 # [/cm^3]
      krec     = 0.0000e+00	 # [s^-1 or cm*s^-1]
    }
  }

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}

Radiation
{ * G = g * D * ((E+E0)/(E+E1))^m  -  the generation term, 
  *  where E is the electric field, 
  *        E0, E1, m are constants to account the recombination, 
  *        g is the electron-hole creation rate , 
  *        D is the dose rate defined in the input file. 
	g	= 7.6000e+12	# [1/(rad*cm^3)]
	E0	= 0.1	# [V/cm]
	E1	= 1.3500e+06	# [V/cm]
	m	= 0.9	# [1]
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 3.0000e+09	# [ohm*cm]
	TempCoef	= 4.5000e-03	# [1/K]
}


}

Material = "OxideAsSemiconductor" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 3.9	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 1.46	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.67	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.014	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 0.9	# [eV]
	Eg0	= 9	# [eV]
	alpha	= 0.0000e+00	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 0.0000e+00	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 0.0000e+00	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= 0.0000e+00	# [eV]
	c_11	= 0.0000e+00	# [1e-2 GPa]
	c_12	= 0.0000e+00	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 1 ,	1	# [1]
	eta	= 1 ,	1	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 0.05 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.5 ,	2.2	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 0.05 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.5 ,	2.2	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 3.9 ,	3.9	# [1]
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}

Radiation
{ * G = g * D * ((E+E0)/(E+E1))^m  -  the generation term, 
  *  where E is the electric field, 
  *        E0, E1, m are constants to account the recombination, 
  *        g is the electron-hole creation rate , 
  *        D is the dose rate defined in the input file. 
	g	= 7.6000e+12	# [1/(rad*cm^3)]
	E0	= 0.1	# [V/cm]
	E1	= 1.3500e+06	# [V/cm]
	m	= 0.9	# [1]
}


}

Material = "Oxynitride" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "Photoresist" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0000e+00	# [1]
	ml	= 0.0000e+00	# [1]
	mm	= 0.42	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 1	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Formula(hole) 2 parameters:
	ml	= 0.629961	# [1]
	mh	= 0.629961	# [1]
	me	= 0.0000e+00	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 1 ,	1	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 0.0000e+00 ,	0.0000e+00	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}


}

Material = "Platinum" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.015	0.885	0.075;
          0.016	0.892	0.086;
          0.018	0.892	0.114;
          0.02	0.882	0.145;
          0.022	0.869	0.18;
          0.024	0.881	0.217;
          0.026	0.862	0.166;
          0.028	0.838	0.194;
          0.03	0.81	0.227;
          0.032	0.779	0.272;
          0.034	0.742	0.322;
          0.036	0.696	0.379;
          0.038	0.663	0.447;
          0.04	0.687	0.551;
          0.042	0.709	0.573;
          0.044	0.722	0.579;
          0.046	0.719	0.622;
          0.048	0.714	0.656;
          0.05	0.709	0.718;
          0.052	0.711	0.797;
          0.054	0.72	0.845;
          0.056	0.744	0.887;
          0.058	0.792	0.924;
          0.06	0.835	0.938;
          0.062	0.887	0.93;
          0.064	0.937	0.915;
          0.066	0.975	0.884;
          0.068	1.01	0.856;
          0.07	1.03	0.826;
          0.072	1.04	0.809;
          0.074	1.05	0.817;
          0.076	1.06	0.835;
          0.078	1.07	0.85;
          0.08	1.08	0.866;
          0.082	1.09	0.878;
          0.084	1.1	0.891;
          0.086	1.12	0.899;
          0.088	1.14	0.903;
          0.09	1.16	0.912;
          0.092	1.18	0.919;
          0.094	1.2	0.93;
          0.096	1.19	0.942;
          0.098	1.17	0.957;
          0.1	1.19	0.981;
          0.102	1.22	1.01;
          0.104	1.22	1.02;
          0.106	1.23	1.04;
          0.108	1.24	1.05;
          0.11	1.24	1.07;
          0.112	1.25	1.09;
          0.114	1.27	1.11;
          0.116	1.28	1.13;
          0.118	1.3	1.15;
          0.12	1.32	1.17;
          0.122	1.35	1.18;
          0.124	1.37	1.18;
          0.126	1.4	1.17;
          0.128	1.42	1.17;
          0.13	1.43	1.16;
          0.132	1.43	1.15;
          0.134	1.43	1.15;
          0.136	1.43	1.14;
          0.138	1.43	1.14;
          0.14	1.45	1.15;
          0.142	1.46	1.15;
          0.144	1.46	1.15;
          0.146	1.47	1.15;
          0.148	1.47	1.15;
          0.15	1.47	1.15;
          0.155	1.46	1.16;
          0.16	1.46	1.22;
          0.165	1.48	1.21;
          0.17	1.49	1.22;
          0.175	1.46	1.23;
          0.18	1.42	1.23;
          0.185	1.38	1.24;
          0.19	1.34	1.26;
          0.195	1.3	1.29;
          0.2	1.34	1.35;
          0.2101	1.37	1.43;
          0.2138	1.36	1.47;
          0.2214	1.36	1.54;
          0.2296	1.36	1.61;
          0.2384	1.36	1.67;
          0.248	1.36	1.76;
          0.2583	1.38	1.85;
          0.2695	1.39	1.95;
          0.2818	1.43	2.04;
          0.2952	1.45	2.14;
          0.31	1.49	2.25;
          0.3179	1.51	2.32;
          0.3263	1.53	2.37;
          0.3351	1.56	2.42;
          0.3444	1.58	2.48;
          0.3542	1.6	2.55;
          0.3647	1.62	2.62;
          0.3757	1.65	2.69;
          0.3874	1.68	2.76;
          0.3999	1.72	2.84;
          0.4133	1.75	2.92;
          0.4275	1.79	3.01;
          0.4428	1.83	3.1;
          0.4592	1.87	3.2;
          0.4769	1.91	3.3;
          0.4959	1.96	3.42;
          0.5166	2.03	3.54;
          0.539	2.1	3.67;
          0.5636	2.17	3.77;
          0.5904	2.23	3.92;
          0.6199	2.3	4.07;
          0.6525	2.38	4.26;
          0.6888	2.51	4.43;
          0.7293	2.63	4.63;
          0.7749	2.76	4.84;
          0.8265	2.92	5.07;
          0.8856	3.1	5.32;
          0.9537	3.29	5.61;
          1.033	3.55	5.92;
          1.078	3.7	6.08;
          1.127	3.86	6.24;
          1.181	4.03	6.44;
          1.24	4.25	6.62;
          1.305	4.5	6.77;
          1.378	4.77	6.91;
          1.409	4.91	6.95;
          1.459	5.05	6.98;
          1.512	5.17	7.01;
          1.55	5.31	7.04;
          1.61	5.44	7.04;
          1.653	5.57	7.02;
          1.698	5.67	6.95;
          1.771	5.71	6.83;
          1.823	5.66	6.73;
          1.907	5.52	6.66;
          1.968	5.34	6.7;
          2.066	5.13	6.75;
          2.175	4.86	6.89;
          2.254	4.58	7.14;
          2.384	4.3	7.4;
          2.455	3.91	7.71;
          2.638	3.36	8.4;
          2.755	3.03	9.31;
          2.883	2.92	10.3;
          3.1	2.81	11.4;
          3.263	3.03	12.5;
          3.542	3.28	13.7;
          3.875	3.57	14.9;
          4.133	3.92	16.2;
          4.428	4.24	17.7;
          4.959	4.7	19.4;
          5.636	5.24	21.5;
          6.199	5.9	24;
          7.293	6.78	27.2;
          8.266	8.18	31.2;
          9.537	9.91	36.7;
          12.4	13.2	44.7;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 9.8100e-06	# [ohm*cm]
	TempCoef	= 3.9200e-03	# [1/K]
}


}

Material = "PolySi" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 11.7	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 11.7	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 3.45	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.45	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 3.7100e-18 ,	3.3300e-18	# [cm^2]
	Gamma_k_carr	= 3 ,	3	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.2101	1.0922	2.8831;
          0.2119	1.1009	2.90361;
          0.2138	1.1184	2.9315;
          0.2156	1.14237	2.96529;
          0.2175	1.1705	3.0035;
          0.2194	1.19797	3.04419;
          0.2214	1.2299	3.0872;
          0.2234	1.2698	3.13376;
          0.2254	1.3177	3.1778;
          0.2275	1.3785	3.21564;
          0.2296	1.4411	3.2413;
          0.2317	1.49894	3.2415;
          0.2339	1.5433	3.2345;
          0.2362	1.55796	3.23247;
          0.2384	1.5588	3.2404;
          0.2407	1.55514	3.26932;
          0.2431	1.5504	3.3133;
          0.2455	1.55126	3.3704;
          0.248	1.5572	3.4397;
          0.2505	1.56976	3.51967;
          0.253	1.5894	3.6102;
          0.2556	1.61655	3.70929;
          0.2583	1.6528	3.8211;
          0.261	1.6961	3.94773;
          0.2638	1.7578	4.0934;
          0.2666	1.84299	4.26904;
          0.2695	1.9684	4.4566;
          0.2725	2.15662	4.64815;
          0.2755	2.3952	4.8243;
          0.2786	2.67333	4.96418;
          0.2818	3.0086	5.0643;
          0.285	3.4429	5.14668;
          0.2883	3.8925	5.1139;
          0.2917	4.30741	4.81355;
          0.2952	4.6283	4.4327;
          0.2988	4.7398	4.11512;
          0.3024	4.7601	3.8384;
          0.3061	4.77064	3.63769;
          0.31	4.7663	3.4841;
          0.3139	4.76873	3.36293;
          0.3179	4.779	3.2667;
          0.322	4.80814	3.18317;
          0.3263	4.8479	3.1119;
          0.3306	4.89223	3.04714;
          0.3351	4.9456	2.9925;
          0.3397	5.00374	2.94735;
          0.3444	5.0868	2.9186;
          0.3493	5.19221	2.93819;
          0.3542	5.3839	2.9304;
          0.3594	5.80733	2.86335;
          0.3647	6.2153	2.6374;
          0.3701	6.38979	2.02886;
          0.3757	6.3887	1.378;
          0.3815	6.14004	0.998007;
          0.3875	5.8155	0.7465;
          0.3936	5.58197	0.598994;
          0.3999	5.3818	0.515;
          0.4065	5.21597	0.44355;
          0.4133	5.0755	0.3916;
          0.4203	4.95259	0.349431;
          0.4275	4.8447	0.3161;
          0.435	4.74682	0.287837;
          0.4428	4.6586	0.2634;
          0.4509	4.57823	0.240775;
          0.4592	4.505	0.2185;
          0.4679	4.43795	0.192556;
          0.4769	4.376	0.1686;
          0.4862	4.31774	0.15245;
          0.4959	4.2632	0.1396;
          0.5061	4.212	0.127413;
          0.5166	4.1639	0.1161;
          0.5276	4.11859	0.105156;
          0.5391	4.0759	0.0941;
          0.551	4.03563	0.081281;
          0.5636	3.9975	0.0697;
          0.5767	3.96109	0.063163;
          0.5904	3.9266	0.0576;
          0.6048	3.89436	0.049456;
          0.6199	3.8636	0.041;
          0.6358	3.83326	0.033381;
          0.6525	3.8045	0.0264;
          0.6702	3.77842	0.020056;
          0.6888	3.7542	0.0149;
          0.7085	3.73137	0.011813;
          0.7293	3.71	9.8000e-03;
          0.7514	3.69049	8.1750e-03;
          0.7749	3.6714	6.9000e-03;
          0.7999	3.65111	5.6310e-03;
          0.8266	3.6305	4.6000e-03;
          0.8551	3.60901	4.0130e-03;
          0.8856	3.5894	3.6000e-03;
          0.9184	3.57576	3.1440e-03;
          0.9537	3.5636	2.7000e-03;
          0.9919	3.54898	2.1940e-03;
          1.033	3.5344	1.8000e-03;
          1.078	3.52153	1.8000e-03;
          1.127	3.5089	1.8000e-03;
          1.181	3.49585	1.5750e-03;
          1.24	3.4817	9.0000e-04;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.63	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.5	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 1.5	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 0.3	# [ps]
	tau_w_hol	= 0.25	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 1	# [1]
	p_l_f	= 1	# [1]
	n_gamma	= 1	# [1]
	p_gamma	= 1	# [1]
	n_delta	= 1.5	# [1]
	p_delta	= 1.5	# [1]
}

Bandgap
{ * Eg = Eg0 + dEg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * dEg0(<bgn_model_name>) is a band gap correction term.  It is used together with
  * an appropriate BGN model, if this BGN model is chosen in Physics section
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 4.05	# [eV]
	Bgn2Chi	= 0.5	# [1]
	Eg0	= 1.16964	# [eV]
	dEg0(Bennett)	= 0.0000e+00	# [eV]
	dEg0(Slotboom)	= -4.7950e-03	# [eV]
	dEg0(OldSlotboom)	= -1.5950e-02	# [eV]
	dEg0(delAlamo)	= -1.4070e-02	# [eV]
	alpha	= 4.7300e-04	# [eV K^-1]
	beta	= 6.3600e+02	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= 0.0000e+00	# [eV]
	dEgMin	= 0.01	# [eV]
	Tpar	= 0.0000e+00	# [K]
}


OldSlotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
	Ebgn	= 9.0000e-03	# [eV]
	Nref	= 1.0000e+17	# [cm^(-3)]
	C	= 0.5	# [1]
}


Slotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
	Ebgn	= 6.9200e-03	# [eV]
	Nref	= 1.3000e+17	# [cm^(-3)]
	C	= 0.5	# [1]
}

delAlamo
{ * deltaEg = dEg0 + Ebgn  ln(N/Nref) 
  * dEg0 is defined in BandGap section 
	Ebgn	= 0.0187	# [eV]
	Nref	= 7.0000e+17	# [cm^(-3)]
}

Bennett
{ * deltaEg = dEg0 + Ebgn (ln(N/Nref))^2
  * dEg0 is defined in BandGap section 
	Ebgn	= 6.8400e-03	# [eV]
	Nref	= 3.1620e+18	# [cm^(-3)]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 0.0000e+00	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 0.19	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= 0.9163	# [eV]
	c_11	= 11.879	# [1e-2 GPa]
	c_12	= 5.376	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.1905	# [1]
	ml	= 0.9163	# [1]
	mm	= 0.0000e+00	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0.443587	# [1]
	b	= 0.003609528	# [K^-1]
	c	= 0.0001173515	# [K^-2]
	d	= 1.263218e-06	# [K^-3]
	e	= 3.025581e-09	# [K^-4]
	f	= 0.004683382	# [K^-1]
	g	= 0.0002286895	# [K^-2]
	h	= 7.469271e-07	# [K^-3]
	i	= 1.727481e-09	# [K^-4]
	mm	= 0	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 1 ,	1	# [1]
  * Formula(hole) 1 parameters:
	A	= 4.22	# [1]
	B	= 0.6084	# [1]
	C	= 23.058	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 3.6 ,	5.6	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 1 ,	1	# [1]
	eta	= 1 ,	1	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.4170e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.5 ,	2.2	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.4170e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.5 ,	2.2	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 1 ,	1	# [1]
  * If formula=1, model suggested by Masetti et al. is used:
  * mu_dop = mumin1 exp(-Pc/N) + (mu_const - mumin2)/(1+(N/Cr)^alpha)
  *                             - mu1/(1+(Cs/N)^beta)
  * with mu_const from ConstantMobility
	mumin1	= 52.2 ,	44.9	# [cm^2/Vs]
	mumin2	= 52.2 ,	0.0000e+00	# [cm^2/Vs]
	mu1	= 43.4 ,	29	# [cm^2/Vs]
	Pc	= 0.0000e+00 ,	9.2300e+16	# [cm^3]
	Cr	= 9.6800e+16 ,	2.2300e+17	# [cm^3]
	Cs	= 3.4300e+20 ,	6.1000e+20	# [cm^3]
	alpha	= 0.68 ,	0.719	# [1]
	beta	= 2 ,	2	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 1 ,	1	# [1]
  * If formula=1, model suggested by Masetti et al. is used:
  * mu_dop = mumin1 exp(-Pc/N) + (mu_const - mumin2)/(1+(N/Cr)^alpha)
  *                             - mu1/(1+(Cs/N)^beta)
  * with mu_const from ConstantMobility
	mumin1	= 52.2 ,	44.9	# [cm^2/Vs]
	mumin2	= 52.2 ,	0.0000e+00	# [cm^2/Vs]
	mu1	= 43.4 ,	29	# [cm^2/Vs]
	Pc	= 0.0000e+00 ,	9.2300e+16	# [cm^3]
	Cr	= 9.6800e+16 ,	2.2300e+17	# [cm^3]
	Cs	= 3.4300e+20 ,	6.1000e+20	# [cm^3]
	alpha	= 0.68 ,	0.719	# [1]
	beta	= 2 ,	2	# [1]
}

ThinLayerMobility:
{ * Mobility model for thin layers with geometric
  * quantization.  See the manual for details.
	beta	= 4 ,	4	# [1]
	zeta	= 2.88 ,	1.05	# [1]
	p1	= 0.55 ,	0.0000e+00	# [1]
	p2	= 4.0000e+02 ,	0.66	# [1]
	p3	= 1.44 ,	1	# [1]
	mz1	= 0.916 ,	0.29	# [m0]
	mz2	= 0.19 ,	0.25	# [m0]
	wt01	= 3.0000e-06 ,	0.0000e+00	# [um]
	wt02	= 3.5000e-07 ,	0.0000e+00	# [um]
	muac01	= 3.1500e+02 ,	30.2	# [cm^2/(Vs)]
	muac02	= 6.4 ,	69	# [cm^2/(Vs)]
	mutf0	= 0.15 ,	0.28	# [cm^2/(Vs)]
	musp0	= 1.1450e-08 ,	1.6000e-10	# [cm^2/(Vs)]
	tsp0	= 1.0000e-04 ,	1.0000e-04	# [um]
	ftf0	= 6.2500e+03 ,	1.0000e+100	# [V/cm]
	tmin	= 2.0000e-03 ,	2.0000e-03	# [um]
	eta1	= 6 ,	6	# [1]
	eta2	= 1 ,	1	# [1]
	mutfh0	= 1.0000e+06 ,	1.0000e+06	# [cm^2/(Vs)]
	ftfh0	= 1.0000e+100 ,	1.0000e+100	# [V/cm]
	a_bp	= 1 ,	1	# [1]
	a_sp	= 1 ,	1	# [1]
	a_tf	= 1 ,	1	# [1]
}

ThinLayerMobility_aniso:
{ * Mobility model for thin layers with geometric
  * quantization.  See the manual for details.
	beta	= 4 ,	4	# [1]
	zeta	= 2.88 ,	1.05	# [1]
	p1	= 0.55 ,	0.0000e+00	# [1]
	p2	= 4.0000e+02 ,	0.66	# [1]
	p3	= 1.44 ,	1	# [1]
	mz1	= 0.916 ,	0.29	# [m0]
	mz2	= 0.19 ,	0.25	# [m0]
	wt01	= 3.0000e-06 ,	0.0000e+00	# [um]
	wt02	= 3.5000e-07 ,	0.0000e+00	# [um]
	muac01	= 3.1500e+02 ,	30.2	# [cm^2/(Vs)]
	muac02	= 6.4 ,	69	# [cm^2/(Vs)]
	mutf0	= 0.15 ,	0.28	# [cm^2/(Vs)]
	musp0	= 1.1450e-08 ,	1.6000e-10	# [cm^2/(Vs)]
	tsp0	= 1.0000e-04 ,	1.0000e-04	# [um]
	ftf0	= 6.2500e+03 ,	1.0000e+100	# [V/cm]
	tmin	= 2.0000e-03 ,	2.0000e-03	# [um]
	eta1	= 6 ,	6	# [1]
	eta2	= 1 ,	1	# [1]
	mutfh0	= 1.0000e+06 ,	1.0000e+06	# [cm^2/(Vs)]
	ftfh0	= 1.0000e+100 ,	1.0000e+100	# [V/cm]
	a_bp	= 1 ,	1	# [1]
	a_sp	= 1 ,	1	# [1]
	a_tf	= 1 ,	1	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 1.109 ,	1.213	# [1]
	betaexp	= 0.66 ,	0.17	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 1.0700e+07 ,	8.3700e+06	# [1]
	vsatexp	= 0.87 ,	0.52	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 1.109 ,	1.213	# [1]
	betaexp	= 0.66 ,	0.17	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 1.0700e+07 ,	8.3700e+06	# [1]
	vsatexp	= 0.87 ,	0.52	# [1]
}

UniBoDopingDependence:
{
  * Baccarani model (University of Bologna) is used:
  * Constant mobility model is defined here as well:
  * mu_const = mumax (T/T0)^(-Exponent+Exponent2*(T/T0))
  * mu_dop = mu_0(Na,Nd,T/T0)                                               
  *         + (mu_const - mu_0)/(1 + (Nd/Cr)^alpha + (Na/Cr2)^beta)         
  *         - mu_1(Na,Nd,T/T0)/(1+(Nd/Cs + Na/Cs2)^(-2))                    
  * with mu_const from above
  * mu_0 = (mumin1 (T/T0)^(-mumin1_exp) Nd + mumin2 (T/T0)^(-mumin2_exp)Na)/(Nd+Na)
  * mu_1 = (mu1 (T/T0)^(-mu1_exp) Nd + mu2 (T/T0)^(-mu2_exp) Na)/(Nd+Na)
  * Cr=Cr (T/T0)^Cr_exp
  * Cr2=Cr2 (T/T0)^Cr2_exp
  * Cs=Cs (T/T0)^Cs_exp
	mumax	= 1.4410e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.45 ,	2.16	# [1]
	Exponent2	= -1.1000e-01 ,	0.0000e+00	# [1]
	mumin1	= 55 ,	90	# [cm^2/Vs]
	mumin2	= 1.3200e+02 ,	44	# [cm^2/Vs]
	mumin1_exp	= 0.6 ,	1.3	# [1]
	mumin2_exp	= 1.3 ,	0.7	# [1]
	mu1	= 42.4 ,	28.2	# [cm^2/Vs]
	mu2	= 73.5 ,	28.2	# [cm^2/Vs]
	mu1_exp	= 0.5 ,	2	# [1]
	mu2_exp	= 1.25 ,	0.8	# [1]
	Pc	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	Cr	= 8.9000e+16 ,	1.3000e+18	# [cm^3]
	Cr2	= 1.2200e+17 ,	2.4500e+17	# [cm^3]
	Cs	= 2.9000e+20 ,	1.1000e+18	# [cm^3]
	Cs2	= 7.0000e+20 ,	6.1000e+20	# [cm^3]
	Cr_exp	= 3.65 ,	2.2	# [1]
	Cr2_exp	= 2.65 ,	3.1	# [1]
	Cs_exp	= 0.0000e+00 ,	6.2	# [1]
	alpha	= 0.68 ,	0.77	# [1]
	beta	= 0.72 ,	0.719	# [1]
}

UniBoDopingDependence_aniso:
{
  * Baccarani model (University of Bologna) is used:
  * Constant mobility model is defined here as well:
  * mu_const = mumax (T/T0)^(-Exponent+Exponent2*(T/T0))
  * mu_dop = mu_0(Na,Nd,T/T0)                                               
  *         + (mu_const - mu_0)/(1 + (Nd/Cr)^alpha + (Na/Cr2)^beta)         
  *         - mu_1(Na,Nd,T/T0)/(1+(Nd/Cs + Na/Cs2)^(-2))                    
  * with mu_const from above
  * mu_0 = (mumin1 (T/T0)^(-mumin1_exp) Nd + mumin2 (T/T0)^(-mumin2_exp)Na)/(Nd+Na)
  * mu_1 = (mu1 (T/T0)^(-mu1_exp) Nd + mu2 (T/T0)^(-mu2_exp) Na)/(Nd+Na)
  * Cr=Cr (T/T0)^Cr_exp
  * Cr2=Cr2 (T/T0)^Cr2_exp
  * Cs=Cs (T/T0)^Cs_exp
	mumax	= 1.4410e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.45 ,	2.16	# [1]
	Exponent2	= -1.1000e-01 ,	0.0000e+00	# [1]
	mumin1	= 55 ,	90	# [cm^2/Vs]
	mumin2	= 1.3200e+02 ,	44	# [cm^2/Vs]
	mumin1_exp	= 0.6 ,	1.3	# [1]
	mumin2_exp	= 1.3 ,	0.7	# [1]
	mu1	= 42.4 ,	28.2	# [cm^2/Vs]
	mu2	= 73.5 ,	28.2	# [cm^2/Vs]
	mu1_exp	= 0.5 ,	2	# [1]
	mu2_exp	= 1.25 ,	0.8	# [1]
	Pc	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	Cr	= 8.9000e+16 ,	1.3000e+18	# [cm^3]
	Cr2	= 1.2200e+17 ,	2.4500e+17	# [cm^3]
	Cs	= 2.9000e+20 ,	1.1000e+18	# [cm^3]
	Cs2	= 7.0000e+20 ,	6.1000e+20	# [cm^3]
	Cr_exp	= 3.65 ,	2.2	# [1]
	Cr2_exp	= 2.65 ,	3.1	# [1]
	Cs_exp	= 0.0000e+00 ,	6.2	# [1]
	alpha	= 0.68 ,	0.77	# [1]
	beta	= 0.72 ,	0.719	# [1]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-05 ,	3.0000e-06	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= -1.5000e+00 ,	-1.5000e+00	# [1]
	Tcoeff	= 2.55 ,	2.55	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 11.7 ,	11.7	# [1]
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}

Absorption
{ * Formula = 1:
  * A = A1*exp((phE-E1)/E2),     for phE < E1 
  *   = A1 + A2*((phE-E1)/E2)^P, for phE >= E1 
  * Formula = 2:
  * A = A0*exp((phE-phE0)*ST),              for phE < phE0 
  *   = AT*(2*ST*(phE-E0-(LN-0.5)/ST))^0.5, for phE >= phE0 
  * where 
  *      phE is a photon energy, 
  *      LN = log(AT/A0), 
  *      ST = S/(T+T0), T is a temperature, 
  *      phE0 = E0 + LN/ST. 

	Formula	= 1	# [1]
  * Formula = 1:
	A1	= 1.0000e+04	# [cm-1]
	A2	= 100	# [cm-1]
	E1	= 1.12	# [eV]
	E2	= 0.025	# [eV]
	P	= 0.5	# [1]
}

LatticeParameters
{ * Crystal system, elasticity, and deformation potential are defined.
  * X and Y vectors define the simulation coordinate system relative to the
  * crystal orientation system. Also there is an option to represent the crystal
  * system relative to the simulation one. In this case a keyword CrystalAxis 
  * has to be in this section and X and Y vectors will represent [100] and [010]
  * axis of the crystal system in the simulation one.
  * Additional notes: 1 Pa = 10 dyn/cm^2; tensile stress/strain is positive. 
  *  
  * S[i][j] - elasticity modulus; i,j = 1,2,...6 and j>=i.
  * CrystalSystem is symmetry, used ONLY to define the elasticity matrics.
  *   Cubic (CrystalSystem=0): S[1][1],S[1][2],S[4][4]
  *   Hexagonal (CrystalSystem=1): S[1][1],S[1][2],S[1][3],S[3][3],S[4][4]
  * 
	X	= (1, 0.0000e+00, 0.0000e+00) #[1]
	Y	= (0.0000e+00, 1, 0.0000e+00) #[1]
	S[1][1]	= 0.77	# [1e-12 cm^2/din]
	S[1][2]	= -2.1000e-01	# [1e-12 cm^2/din]
	S[4][4]	= 1.25	# [1e-12 cm^2/din]
	CrystalSystem	= 0	# [1]

  * Deformation potentials of 2 k.p model for electron delta-valleys 
	xis	= 7	# [eV]
	dbs	= 0.53	# [eV]
	xiu	= 9.16	# [eV]
	xid	= 0.77	# [eV]
	Mkp	= 1.2	# [1]

  * Deformation potentials of 6 k.p model for hole bands
	adp	= 2.1	# [eV]
	bdp	= -2.3300e+00	# [eV]
	ddp	= -4.7500e+00	# [eV]
	dso	= 0.044	# [eV]

  * Luttinger parameters
	gamma_1	= 4.27	# [1]
	gamma_2	= 0.315	# [1]
	gamma_3	= 1.4576	# [1]

  * Deformation potentials and energy (in reference to delta-valley) for L-valleys 
	xiu_l	= 11.5	# [eV]
	xid_l	= -6.5800e+00	# [eV]
	e_l	= 1.1	# [eV]

  * Deformation potentials and energy (in reference to delta-valley) for Gamma-valley 
	xid_gamma	= -7.0000e+00	# [eV]
	e_gamma	= 2.3	# [eV]
}


}

Material = "SiC_4H" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "SiC_6H" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "Silicide" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "Silicon" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 11.7	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 11.7	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 3.45	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.45	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 3.7100e-18 ,	3.3300e-18	# [cm^2]
	Gamma_k_carr	= 3 ,	3	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.1908	0.84	2.73;
          0.1984	0.968	2.89;
          0.2066	1.01	2.909;
          0.2073	1.036	2.928;
          0.208	1.046	2.944;
          0.2087	1.066	2.937;
          0.2094	1.07	2.963;
          0.2101	1.083	2.982;
          0.2109	1.088	2.987;
          0.2116	1.102	3.005;
          0.2123	1.109	3.015;
          0.213	1.119	3.025;
          0.2138	1.133	3.045;
          0.2145	1.139	3.061;
          0.2153	1.155	3.073;
          0.216	1.164	3.086;
          0.2168	1.175	3.102;
          0.2175	1.18	3.112;
          0.2183	1.195	3.135;
          0.2191	1.211	3.15;
          0.2198	1.222	3.169;
          0.2206	1.235	3.19;
          0.2214	1.247	3.206;
          0.2222	1.265	3.228;
          0.223	1.28	3.245;
          0.2238	1.299	3.267;
          0.2246	1.319	3.285;
          0.2254	1.34	3.302;
          0.2263	1.362	3.319;
          0.2271	1.389	3.334;
          0.2279	1.416	3.35;
          0.2296	1.471	3.366;
          0.2305	1.502	3.368;
          0.2313	1.526	3.368;
          0.2322	1.548	3.364;
          0.2339	1.579	3.353;
          0.2348	1.585	3.346;
          0.2357	1.59	3.344;
          0.2366	1.591	3.344;
          0.2375	1.592	3.347;
          0.2384	1.589	3.354;
          0.2394	1.586	3.363;
          0.2403	1.582	3.376;
          0.2412	1.579	3.389;
          0.2422	1.573	3.408;
          0.2431	1.571	3.429;
          0.2441	1.57	3.451;
          0.245	1.569	3.477;
          0.246	1.568	3.504;
          0.247	1.569	3.533;
          0.248	1.57	3.565;
          0.249	1.575	3.598;
          0.25	1.58	3.632;
          0.251	1.584	3.67;
          0.252	1.591	3.709;
          0.253	1.597	3.749;
          0.2541	1.608	3.789;
          0.2551	1.618	3.835;
          0.2562	1.629	3.88;
          0.2572	1.643	3.928;
          0.2583	1.658	3.979;
          0.2594	1.673	4.031;
          0.2605	1.692	4.088;
          0.2616	1.713	4.149;
          0.2627	1.737	4.211;
          0.2638	1.764	4.278;
          0.2649	1.794	4.35;
          0.2661	1.831	4.426;
          0.2672	1.874	4.506;
          0.2684	1.927	4.59;
          0.2695	1.988	4.678;
          0.2707	2.059	4.764;
          0.2719	2.14	4.849;
          0.2731	2.234	4.933;
          0.2743	2.339	5.011;
          0.2755	2.451	5.082;
          0.2768	2.572	5.148;
          0.278	2.7	5.206;
          0.2792	2.833	5.257;
          0.2805	2.974	5.304;
          0.2818	3.12	5.344;
          0.2831	3.277	5.381;
          0.2844	3.444	5.414;
          0.2857	3.634	5.435;
          0.287	3.849	5.439;
          0.2883	4.086	5.395;
          0.2897	4.318	5.301;
          0.291	4.525	5.158;
          0.2924	4.686	4.989;
          0.2938	4.805	4.812;
          0.2952	4.888	4.639;
          0.2966	4.941	4.48;
          0.298	4.977	4.335;
          0.2995	4.999	4.204;
          0.3009	5.012	4.086;
          0.3024	5.02	3.979;
          0.3039	5.021	3.885;
          0.3054	5.02	3.798;
          0.3069	5.018	3.72;
          0.3084	5.015	3.65;
          0.31	5.01	3.587;
          0.3115	5.009	3.529;
          0.3131	5.01	3.477;
          0.3147	5.009	3.429;
          0.3163	5.012	3.386;
          0.3179	5.016	3.346;
          0.3195	5.021	3.31;
          0.3212	5.029	3.275;
          0.3229	5.04	3.242;
          0.3246	5.052	3.211;
          0.3263	5.065	3.182;
          0.328	5.079	3.154;
          0.3297	5.095	3.128;
          0.3315	5.115	3.103;
          0.3333	5.134	3.079;
          0.3351	5.156	3.058;
          0.3369	5.179	3.039;
          0.3388	5.204	3.021;
          0.3406	5.231	3.007;
          0.3425	5.261	2.995;
          0.3444	5.296	2.987;
          0.3463	5.336	2.983;
          0.3483	5.383	2.984;
          0.3502	5.442	2.989;
          0.3522	5.515	2.999;
          0.3542	5.61	3.014;
          0.3563	5.733	3.026;
          0.3583	5.894	3.023;
          0.3604	6.089	2.982;
          0.3625	6.308	2.881;
          0.3647	6.522	2.705;
          0.3668	6.695	2.456;
          0.369	6.796	2.169;
          0.3712	6.829	1.87;
          0.3734	6.799	1.577;
          0.3757	6.709	1.321;
          0.38	6.548	0.88602;
          0.39	5.976	0.46553;
          0.4	5.587	0.30303;
          0.41	5.305	0.2199;
          0.42	5.091	0.16711;
          0.43	4.925	0.13414;
          0.44	4.793	0.10889;
          0.45	4.676	0.091315;
          0.46	4.577	0.076872;
          0.47	4.491	0.06433;
          0.48	4.416	0.056532;
          0.49	4.348	0.049521;
          0.5	4.293	0.044165;
          0.51	4.239	0.039367;
          0.52	4.192	0.036415;
          0.53	4.15	0.033108;
          0.54	4.11	0.030295;
          0.55	4.077	0.027968;
          0.56	4.044	0.025758;
          0.57	4.015	0.024131;
          0.58	3.986	0.022524;
          0.59	3.962	0.021081;
          0.6	3.939	0.019767;
          0.61	3.916	0.018495;
          0.62	3.895	0.017367;
          0.63	3.879	0.016394;
          0.64	3.861	0.015483;
          0.65	3.844	0.014535;
          0.66	3.83	0.01355;
          0.67	3.815	0.012689;
          0.68	3.8	0.011959;
          0.69	3.787	0.011256;
          0.7	3.774	0.010584;
          0.71	3.762	0.010001;
          0.72	3.751	9.5111e-03;
          0.73	3.741	8.9461e-03;
          0.74	3.732	8.3620e-03;
          0.75	3.723	7.7588e-03;
          0.76	3.714	7.1970e-03;
          0.77	3.705	6.7402e-03;
          0.78	3.696	6.2691e-03;
          0.79	3.688	5.8340e-03;
          0.8	3.681	5.4113e-03;
          0.81	3.674	4.9955e-03;
          0.82	3.668	4.6134e-03;
          0.83	3.662	4.2734e-03;
          0.84	3.656	3.9505e-03;
          0.85	3.65	3.6188e-03;
          0.86	3.644	3.2850e-03;
          0.87	3.638	2.9908e-03;
          0.88	3.632	2.6821e-03;
          0.89	3.626	2.4293e-03;
          0.9	3.62	2.1916e-03;
          0.91	3.614	1.9697e-03;
          0.92	3.608	1.7571e-03;
          0.93	3.602	1.5541e-03;
          0.94	3.597	1.3689e-03;
          0.95	3.592	1.1869e-03;
          0.96	3.587	1.0237e-03;
          0.97	3.582	8.7997e-04;
          0.98	3.578	7.4788e-04;
          0.99	3.574	6.2395e-04;
          1	3.57	5.0930e-04;
          1.01	3.566	4.1071e-04;
          1.02	3.563	3.2386e-04;
          1.03	3.56	2.4753e-04;
          1.04	3.557	1.8704e-04;
          1.05	3.554	1.3620e-04;
          1.06	3.551	9.3631e-05;
          1.07	3.548	6.8118e-05;
          1.08	3.546	5.3285e-05;
          1.09	3.544	4.0768e-05;
          1.1	3.541	3.0637e-05;
          1.11	3.539	2.3849e-05;
          1.12	3.537	1.7825e-05;
          1.13	3.534	1.3488e-05;
          1.14	3.532	9.0718e-06;
          1.15	3.53	6.2230e-06;
          1.16	3.528	3.8770e-06;
          1.17	3.526	2.0483e-06;
          1.18	3.524	6.1036e-07;
          1.19	3.522	3.4091e-07;
          1.2	3.52	2.1008e-07;
          1.21	3.528	1.2518e-07;
          1.22	3.516	7.9609e-08;
          1.23	3.515	4.6004e-08;
          1.24	3.513	2.3682e-08;
          1.25	3.511	9.9472e-09;
          1.26	3.51	3.6096e-09;
          1.27	3.508	2.0213e-09;
          1.28	3.507	1.2223e-09;
          1.29	3.506	7.2885e-10;
          1.3	3.504	4.6553e-10;
          1.31	3.503	2.8147e-10;
          1.32	3.501	1.6807e-10;
          1.33	3.5	8.4670e-11;
          1.34	3.498	3.7322e-11;
          1.35	3.497	1.8263e-11;
          1.36	3.496	1.0823e-11;
          1.37	3.495	7.3044e-12;
          1.38	3.493	4.9418e-12;
          1.39	3.492	2.7653e-12;
          1.4	3.491	2.2282e-12;
          1.41	3.49	1.6831e-12;
          1.42	3.489	9.6050e-13;
          1.43	3.488	8.7623e-13;
          1.44	3.487	4.8128e-13;
          1.45	3.486	3.6924e-13;
          10	3.42	1.0000e-13;
          10.001	3.42	1.0000e-13;
          10.002	3.42	1.0000e-13;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.63	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
	1/kappa	= 0.03	# [K cm/W]
	1/kappa_b	= 1.5600e-03	# [cm/W]
	1/kappa_c	= 1.6500e-06	# [cm/(W K)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
	1/kappa	= 0.03	# [K cm/W]
	1/kappa_b	= 1.5600e-03	# [cm/W]
	1/kappa_c	= 1.6500e-06	# [cm/(W K)]
}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 0.3	# [ps]
	tau_w_hol	= 0.25	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}


EnergyFlux
{ *  Coefficient in front of the energy flux equation
  *  energy_flux_coef=0.6 corresponds to Stratton model
	energy_flux_coef_ele	= 0.6	# [1]
	energy_flux_coef_hol	= 0.6	# [1]
}

ThermalDiffusion
{ *  Thermal diffusion factor, td: td*mu*kB*N*grad(T), td=0 for Stratton model
  *  Carrier diffusion factor, td_g: mu*kB*(td_g*Tcarrier + (1-td_g)*Tlattice)*grad(N)
	td_n	= 0.0000e+00	# [1]
	td_p	= 0.0000e+00	# [1]
	td_gn	= 1	# [1]
	td_gp	= 1	# [1]
}

HeatFlux
{ *  Heat flux diffusion factor, hf: hf*mu*(kB^2/q)*N*T*grad(T) 
	hf_n	= 1	# [1]
	hf_p	= 1	# [1]

 * Coefficients can be defined also as:
 *      hf_new = hf*(1.+Delta(w))
 * where Delta(w) is the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * Delta(w) = factor*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(w^P(i))], w=Tc/Tl
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * Option can be activated by specifying nonzero 'factor'.
 *
 *      Wmax(interval)_ele = 
 *      F(interval)_ele     = 1    
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }
 *
 *      Wmax(interval)_hol = 
 *      F(interval)_hol     = 1 

 * Alternatively, the function Delta(w) can also be
 * specified as a spline function, for example:
 *
 *      Spline (electron) {
 *        0   1
 *        1   1
 *        2   0.8
 *        4   0.6
 *        10  0.5
 *      }
 *
 *      Spline (hole) {
 *        0   1
 *        1   1.1
 *        2   0.9
 *        4   0.8
 *        10  0.75
 *      }
 *
 * The given data points are interpolated by a cubic spline.  Zero
 * derivatives are imposed as boundary conditions at the end points.
 * The spline function remains constant beyond the end points.
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 1	# [1]
	p_l_f	= 1	# [1]
	n_gamma	= 1	# [1]
	p_gamma	= 1	# [1]
	n_delta	= 1.5	# [1]
	p_delta	= 1.5	# [1]
}


TEPower
{ 
	s_n	= 1	# [1]
	s_p	= 1	# [1]
	scale_n	= 1	# [1]
	scale_p	= 1	# [1]
}


Ionization
{ 
	E_As_0  	= 0.054	# [eV]
	alpha_As	= 3.1000e-08	# [eV cm]
	g_As    	= 2	# [1]
	Xsec_As	= 1.0000e-12	# [cm^2]

	E_P_0   	= 0.045	# [eV]
	alpha_P 	= 3.1000e-08	# [eV cm]
	g_P     	= 2	# [1]
	Xsec_P     	= 1.0000e-12	# [cm^2]

	E_Sb_0  	= 0.039	# [eV]
	alpha_Sb	= 3.1000e-08	# [eV cm]
	g_Sb    	= 2	# [1]
	Xsec_Sb    	= 1.0000e-12	# [cm^2]

	E_B_0   	= 0.045	# [eV]
	alpha_B 	= 3.1000e-08	# [eV cm]
	g_B     	= 4	# [1]
	Xsec_B     	= 1.0000e-12	# [cm^2]

	E_Al_0   	= 0.045	# [eV]
	alpha_Al 	= 3.1000e-08	# [eV cm]
	g_Al     	= 4	# [1]
	Xsec_Al     	= 1.0000e-12	# [cm^2]

	E_In_0  	= 0.16	# [eV]
	alpha_In	= 3.1000e-08	# [eV cm]
	g_In    	= 4	# [1]
	Xsec_In    	= 1.0000e-12	# [cm^2]

	E_N_0	= 0.045	# [eV]
	alpha_N 	= 3.1000e-08	# [eV cm]
	g_N	= 2	# [1]
	Xsec_N	= 1.0000e-12	# [cm^2]

	E_NDopant_0	= 0.045	# [eV]
	alpha_NDopant 	= 3.1000e-08	# [eV cm]
	g_NDopant	= 2	# [1]
	Xsec_NDopant	= 1.0000e-12	# [cm^2]

	E_PDopant_0	= 0.045	# [eV]
	alpha_PDopant 	= 3.1000e-08	# [eV cm]
	g_PDopant	= 4	# [1]
	Xsec_PDopant	= 1.0000e-12	# [cm^2]

	NdCrit  	= 1.0000e+22	# [cm-3]
	NaCrit  	= 1.0000e+22	# [cm-3]
}

Bandgap
{ * Eg = Eg0 + dEg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * dEg0(<bgn_model_name>) is a band gap correction term.  It is used together with
  * an appropriate BGN model, if this BGN model is chosen in Physics section
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 4.05	# [eV]
	Bgn2Chi	= 0.5	# [1]
	Eg0	= 1.16964	# [eV]
	dEg0(Bennett)	= 0.0000e+00	# [eV]
	dEg0(Slotboom)	= -4.7950e-03	# [eV]
	dEg0(OldSlotboom)	= -1.5950e-02	# [eV]
	dEg0(delAlamo)	= -1.4070e-02	# [eV]
	alpha	= 4.7300e-04	# [eV K^-1]
	beta	= 6.3600e+02	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= 0.0000e+00	# [eV]
	dEgMin	= 0.01	# [eV]
	Tpar	= 0.0000e+00	# [K]
}


OldSlotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
	Ebgn	= 9.0000e-03	# [eV]
	Nref	= 1.0000e+17	# [cm^(-3)]
	C	= 0.5	# [1]
}


Slotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
	Ebgn	= 6.9200e-03	# [eV]
	Nref	= 1.3000e+17	# [cm^(-3)]
	C	= 0.5	# [1]
}

delAlamo
{ * deltaEg = dEg0 + Ebgn  ln(N/Nref) 
  * dEg0 is defined in BandGap section 
	Ebgn	= 0.0187	# [eV]
	Nref	= 7.0000e+17	# [cm^(-3)]
}

Bennett
{ * deltaEg = dEg0 + Ebgn (ln(N/Nref))^2
  * dEg0 is defined in BandGap section 
	Ebgn	= 6.8400e-03	# [eV]
	Nref	= 3.1620e+18	# [cm^(-3)]
}

JainRoulston
{ * deltaEg = A_i N^(1/3) + B_i N^(1/4) + C_i N^(1/2) + D_i N^(1/2)
  * where i is n for n-type or p for p-type
	A_n	= 1.0200e-08	# [eV cm]
	A_p	= 1.1100e-08	# [eV cm]
	B_n	= 4.1500e-07	# [eV cm^(3/4)]
	B_p	= 4.7900e-07	# [eV cm^(3/4)]
	C_n	= 1.4500e-12	# [eV cm^(3/2)]
	C_p	= 3.2300e-12	# [eV cm^(3/2)]
	D_n	= 1.4800e-12	# [eV cm^(3/2)]
	D_p	= 1.8100e-12	# [eV cm^(3/2)]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
	fcaalpha_n	= 4.0000e-18	# [cm^2]
	fcaalpha_p	= 8.0000e-18	# [cm^2]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
	eps	= 0.0000e+00	# [1]
	a0	= 3.1890e-10	# [cm]
	alpha	= 0.0000e+00	# [cm/K]
	Tpar	= 3.0000e+02	# [K]
	a_nu	= 0.19	# [eV]
	a_c	= -4.0800e+00	# [eV]
	b_shear	= 0.9163	# [eV]
	c_11	= 11.879	# [1e-2 GPa]
	c_12	= 5.376	# [1e-2 GPa]
	d1	= -8.9000e-01	# [eV]
	d2	= 4.27	# [eV]
	d3	= 5.18	# [eV]
	d4	= -2.5900e+00	# [eV]
	c_13	= 1	# [1e-2 GPa]
	c_33	= 3.92	# [1e-2 GPa]
	c0	= 5.1850e-10	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.1905	# [1]
	ml	= 0.9163	# [1]
	mm	= 0.0000e+00	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 0.443587	# [1]
	b	= 0.003609528	# [K^-1]
	c	= 0.0001173515	# [K^-2]
	d	= 1.263218e-06	# [K^-3]
	e	= 3.025581e-09	# [K^-4]
	f	= 0.004683382	# [K^-1]
	g	= 0.0002286895	# [K^-2]
	h	= 7.469271e-07	# [K^-3]
	i	= 1.727481e-09	# [K^-4]
	mm	= 0	# [1]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 1 ,	1	# [1]
  * Formula(hole) 1 parameters:
	A	= 4.22	# [1]
	B	= 0.6084	# [1]
	C	= 23.058	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}

QuantumPotentialParameters
{ * gamma:  weighting factor for quantum potential
  * theta:  weight for quadratic term
  * xi:     weight for quasi Fermi potential
  * eta:    weight for electrostatic potential
  * nu :    weight for DOS mass change from stress
	gamma	= 3.6 ,	5.6	# [1]
	theta	= 0.5 ,	0.5	# [1]
	xi	= 1 ,	1	# [1]
	eta	= 1 ,	1	# [1]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.4170e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.5 ,	2.2	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 1.4170e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.5 ,	2.2	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 1 ,	1	# [1]
  * If formula=1, model suggested by Masetti et al. is used:
  * mu_dop = mumin1 exp(-Pc/N) + (mu_const - mumin2)/(1+(N/Cr)^alpha)
  *                             - mu1/(1+(Cs/N)^beta)
  * with mu_const from ConstantMobility
	mumin1	= 52.2 ,	44.9	# [cm^2/Vs]
	mumin2	= 52.2 ,	0.0000e+00	# [cm^2/Vs]
	mu1	= 43.4 ,	29	# [cm^2/Vs]
	Pc	= 0.0000e+00 ,	9.2300e+16	# [cm^3]
	Cr	= 9.6800e+16 ,	2.2300e+17	# [cm^3]
	Cs	= 3.4300e+20 ,	6.1000e+20	# [cm^3]
	alpha	= 0.68 ,	0.719	# [1]
	beta	= 2 ,	2	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 1 ,	1	# [1]
  * If formula=1, model suggested by Masetti et al. is used:
  * mu_dop = mumin1 exp(-Pc/N) + (mu_const - mumin2)/(1+(N/Cr)^alpha)
  *                             - mu1/(1+(Cs/N)^beta)
  * with mu_const from ConstantMobility
	mumin1	= 52.2 ,	44.9	# [cm^2/Vs]
	mumin2	= 52.2 ,	0.0000e+00	# [cm^2/Vs]
	mu1	= 43.4 ,	29	# [cm^2/Vs]
	Pc	= 0.0000e+00 ,	9.2300e+16	# [cm^3]
	Cr	= 9.6800e+16 ,	2.2300e+17	# [cm^3]
	Cs	= 3.4300e+20 ,	6.1000e+20	# [cm^3]
	alpha	= 0.68 ,	0.719	# [1]
	beta	= 2 ,	2	# [1]
}

PhuMob: 
{ * Philips Unified Mobility Model:
	mumax_As  	= 1.4170e+03	# [cm^2/Vs]
	mumin_As  	= 52.2	# [cm^2/Vs]
	theta_As  	= 2.285	# [1]
	n_ref_As  	= 9.6800e+16	# [cm^(-3)]
	alpha_As  	= 0.68	# [1]
	mumax_P  	= 1.4140e+03	# [cm^2/Vs]
	mumin_P  	= 68.5	# [cm^2/Vs]
	theta_P  	= 2.285	# [1]
	n_ref_P  	= 9.2000e+16	# [cm^(-3)]
	alpha_P  	= 0.711	# [1]
	mumax_B   	= 4.7050e+02	# [cm^2/Vs]
	mumin_B   	= 44.9	# [cm^2/Vs]
	theta_B   	= 2.247	# [1]
	n_ref_B   	= 2.2300e+17	# [cm^(-3)]
	alpha_B   	= 0.719	# [1]
	nref_D    	= 4.0000e+20	# [cm^(-3)]
	nref_A    	= 7.2000e+20	# [cm^(-3)]
	cref_D    	= 0.21	# [1]
	cref_A    	= 0.5	# [1]
	me_over_m0	= 1	# [1]
	mh_over_m0	= 1.258	# [1]
	f_CW      	= 2.459	# [1]
	f_BH      	= 3.828	# [1]
	f_e       	= 1	# [1]
	f_h       	= 1	# [1]
	alpha1_g_k	= -7.2169e-01	# [1]
	alpha1_g_m	= -1.5952e+00	# [1]
}

EnormalDependence
{ * mu_Enorm^(-1) = mu_ac^(-1) + mu_sr^(-1)  with:
  * mu_ac = B / Enorm + C (T/T0)^(-k) ((N+N2)/N0)^lambda / Enorm^(1/3)
  * mu_sr^-1 = Enorm^(A+alpha*n/(N+N1)^nu) / delta + Enorm^3 / eta
  * EnormalDependence is added with factor exp(-l/l_crit), where l is
  * the distance to the nearest point of semiconductor/insulator interface.
  * Factor is equal to 1 if l_crit > 100.
	B	= 4.7500e+07 ,	9.9250e+06	# [cm/s]
	C	= 5.8000e+02 ,	2.9470e+03	# [cm^(5/3)/(V^(2/3)s)]
	N0	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	lambda	= 0.125 ,	0.0317	# [1]
	k	= 1 ,	1	# [1]
	delta	= 5.8200e+14 ,	2.0546e+14	# [V/s]
	A	= 2 ,	2	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	aother	= 0.0000e+00 ,	0.0000e+00	# [1]
	N1	= 1 ,	1	# [cm^(-3)]
	nu	= 1 ,	1	# [1]
	eta	= 5.8200e+30 ,	2.0546e+30	# [V^2/cm*s]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	a_ac	= 1 ,	1	# [1]
	a_sr	= 1 ,	1	# [1]
}

EnormalDependence_aniso
{ * mu_Enorm^(-1) = mu_ac^(-1) + mu_sr^(-1)  with:
  * mu_ac = B / Enorm + C (T/T0)^(-k) ((N+N2)/N0)^lambda / Enorm^(1/3)
  * mu_sr^-1 = Enorm^(A+alpha*n/(N+N1)^nu) / delta + Enorm^3 / eta
  * EnormalDependence is added with factor exp(-l/l_crit), where l is
  * the distance to the nearest point of semiconductor/insulator interface.
  * Factor is equal to 1 if l_crit > 100.
	B	= 4.7500e+07 ,	9.9250e+06	# [cm/s]
	C	= 5.8000e+02 ,	2.9470e+03	# [cm^(5/3)/(V^(2/3)s)]
	N0	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	lambda	= 0.125 ,	0.0317	# [1]
	k	= 1 ,	1	# [1]
	delta	= 5.8200e+14 ,	2.0546e+14	# [V/s]
	A	= 2 ,	2	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	aother	= 0.0000e+00 ,	0.0000e+00	# [1]
	N1	= 1 ,	1	# [cm^(-3)]
	nu	= 1 ,	1	# [1]
	eta	= 5.8200e+30 ,	2.0546e+30	# [V^2/cm*s]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	a_ac	= 1 ,	1	# [1]
	a_sr	= 1 ,	1	# [1]
}

ThinLayerMobility:
{ * Mobility model for thin layers with geometric
  * quantization.  See the manual for details.
	beta	= 4 ,	4	# [1]
	zeta	= 2.88 ,	1.05	# [1]
	p1	= 0.55 ,	0.0000e+00	# [1]
	p2	= 4.0000e+02 ,	0.66	# [1]
	p3	= 1.44 ,	1	# [1]
	mz1	= 0.916 ,	0.29	# [m0]
	mz2	= 0.19 ,	0.25	# [m0]
	wt01	= 3.0000e-06 ,	0.0000e+00	# [um]
	wt02	= 3.5000e-07 ,	0.0000e+00	# [um]
	muac01	= 3.1500e+02 ,	30.2	# [cm^2/(Vs)]
	muac02	= 6.4 ,	69	# [cm^2/(Vs)]
	mutf0	= 0.15 ,	0.28	# [cm^2/(Vs)]
	musp0	= 1.1450e-08 ,	1.6000e-10	# [cm^2/(Vs)]
	tsp0	= 1.0000e-04 ,	1.0000e-04	# [um]
	ftf0	= 6.2500e+03 ,	1.0000e+100	# [V/cm]
	tmin	= 2.0000e-03 ,	2.0000e-03	# [um]
	eta1	= 6 ,	6	# [1]
	eta2	= 1 ,	1	# [1]
	mutfh0	= 1.0000e+06 ,	1.0000e+06	# [cm^2/(Vs)]
	ftfh0	= 1.0000e+100 ,	1.0000e+100	# [V/cm]
	a_bp	= 1 ,	1	# [1]
	a_sp	= 1 ,	1	# [1]
	a_tf	= 1 ,	1	# [1]
}

ThinLayerMobility_aniso:
{ * Mobility model for thin layers with geometric
  * quantization.  See the manual for details.
	beta	= 4 ,	4	# [1]
	zeta	= 2.88 ,	1.05	# [1]
	p1	= 0.55 ,	0.0000e+00	# [1]
	p2	= 4.0000e+02 ,	0.66	# [1]
	p3	= 1.44 ,	1	# [1]
	mz1	= 0.916 ,	0.29	# [m0]
	mz2	= 0.19 ,	0.25	# [m0]
	wt01	= 3.0000e-06 ,	0.0000e+00	# [um]
	wt02	= 3.5000e-07 ,	0.0000e+00	# [um]
	muac01	= 3.1500e+02 ,	30.2	# [cm^2/(Vs)]
	muac02	= 6.4 ,	69	# [cm^2/(Vs)]
	mutf0	= 0.15 ,	0.28	# [cm^2/(Vs)]
	musp0	= 1.1450e-08 ,	1.6000e-10	# [cm^2/(Vs)]
	tsp0	= 1.0000e-04 ,	1.0000e-04	# [um]
	ftf0	= 6.2500e+03 ,	1.0000e+100	# [V/cm]
	tmin	= 2.0000e-03 ,	2.0000e-03	# [um]
	eta1	= 6 ,	6	# [1]
	eta2	= 1 ,	1	# [1]
	mutfh0	= 1.0000e+06 ,	1.0000e+06	# [cm^2/(Vs)]
	ftfh0	= 1.0000e+100 ,	1.0000e+100	# [V/cm]
	a_bp	= 1 ,	1	# [1]
	a_sp	= 1 ,	1	# [1]
	a_tf	= 1 ,	1	# [1]
}

IALMob
{ * Inversion and Accumulation Layer Mobility model. See the manual for details.
	EnormMinimum	= 0.0000e+00	# [V/cm]
  * "PhuMob" parameters.
	nref_D	= 4.0000e+20	# [cm^(-3)]
	nref_A	= 7.2000e+20	# [cm^(-3)]
	cref_D	= 0.21	# [1]
	cref_A	= 0.5	# [1]
	me_over_m0	= 1	# [1]
	mh_over_m0	= 1.258	# [1]
	mumax	= 1.4170e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	mumin	= 52.2 ,	44.9	# [cm^2/(Vs)]
	theta	= 2.285 ,	2.247	# [1]
	n_ref	= 9.6800e+16 ,	2.2300e+17	# [cm^(-3)]
	alpha	= 0.68 ,	0.719	# [1]
  * Coulomb quantization parameters.
	S	= 0.3042 ,	0.3042	# [K(cm/V)^(2/3)]
	S_t	= 0.0000e+00 ,	0.0000e+00	# [K(um)^2]
	t0	= 5.0000e-04 ,	5.0000e-04	# [um]
	p	= 4 ,	4	# [1]
	l_crit_c	= 1.0000e+03 ,	1.0000e+03	# [cm]
  * 2D phonon scattering parameters.
	B	= 9.0000e+05 ,	9.0000e+05	# [cm/s]
	C	= 4.4000e+03 ,	4.4000e+03	# [cm^(5/3)/V^(2/3)/s]
	lambda	= 0.057 ,	0.057	# [1]
	k	= 1 ,	1	# [1]
	alpha_ph2d_A	= 1 ,	1	# [1]
	alpha_ph2d_D	= 1 ,	1	# [1]
	lambda_ph2d_A	= 1 ,	1	# [1]
	lambda_ph2d_D	= 1 ,	1	# [1]
  * Surface roughness scattering parameters.
	delta	= 3.9700e+13 ,	3.9700e+13	# [cm^2/(Vs)]
	lambda_sr	= 0.057 ,	0.057	# [1]
	A	= 2 ,	2	# [1]
	alpha_sr	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 1.0000e+50 ,	1.0000e+50	# [V^2/cm/s]
	N1	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	alpha_sr_A	= 1 ,	1	# [1]
	alpha_sr_D	= 1 ,	1	# [1]
	lambda_sr_A	= 1 ,	1	# [1]
	lambda_sr_D	= 1 ,	1	# [1]
	l_crit	= 1.0000e+03 ,	1.0000e+03	# [cm]
  * 2D Coulomb scattering parameters.
	D1_inv	= 1.3500e+02 ,	1.3500e+02	# [cm^2/(Vs)]
	D2_inv	= 40 ,	40	# [cm^2/(Vs)]
	nu0_inv	= 1.5 ,	1.5	# [1]
	nu1_inv	= 2 ,	2	# [1]
	nu2_inv	= 0.5 ,	0.5	# [1]
	alpha1_inv	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha2_inv	= 0.0000e+00 ,	0.0000e+00	# [1]
	D1_acc	= 1.3500e+02 ,	1.3500e+02	# [cm^2/(Vs)]
	D2_acc	= 40 ,	40	# [cm^2/(Vs)]
	nu0_acc	= 1.5 ,	1.5	# [1]
	nu1_acc	= 2 ,	2	# [1]
	nu2_acc	= 0.5 ,	0.5	# [1]
	alpha1_acc	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha2_acc	= 0.0000e+00 ,	0.0000e+00	# [1]
	tcoulomb	= 0.0000e+00 ,	0.0000e+00	# [um]
	t1      	= 3.0000e-04 ,	3.0000e-04	# [um]
  * Stress scaling parameters.
	a_ph2d	= 1 ,	1	# [1]
	a_ph3d	= 1 ,	1	# [1]
	a_c2d	= 1 ,	1	# [1]
	a_c3d	= 1 ,	1	# [1]
	a_sr	= 1 ,	1	# [1]
}

IALMob_aniso
{ * Inversion and Accumulation Layer Mobility model. See the manual for details.
	EnormMinimum	= 0.0000e+00	# [V/cm]
  * "PhuMob" parameters.
	nref_D	= 4.0000e+20	# [cm^(-3)]
	nref_A	= 7.2000e+20	# [cm^(-3)]
	cref_D	= 0.21	# [1]
	cref_A	= 0.5	# [1]
	me_over_m0	= 1	# [1]
	mh_over_m0	= 1.258	# [1]
	mumax	= 1.4170e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	mumin	= 52.2 ,	44.9	# [cm^2/(Vs)]
	theta	= 2.285 ,	2.247	# [1]
	n_ref	= 9.6800e+16 ,	2.2300e+17	# [cm^(-3)]
	alpha	= 0.68 ,	0.719	# [1]
  * Coulomb quantization parameters.
	S	= 0.3042 ,	0.3042	# [K(cm/V)^(2/3)]
	S_t	= 0.0000e+00 ,	0.0000e+00	# [K(um)^2]
	t0	= 5.0000e-04 ,	5.0000e-04	# [um]
	p	= 4 ,	4	# [1]
	l_crit_c	= 1.0000e+03 ,	1.0000e+03	# [cm]
  * 2D phonon scattering parameters.
	B	= 9.0000e+05 ,	9.0000e+05	# [cm/s]
	C	= 4.4000e+03 ,	4.4000e+03	# [cm^(5/3)/V^(2/3)/s]
	lambda	= 0.057 ,	0.057	# [1]
	k	= 1 ,	1	# [1]
	alpha_ph2d_A	= 1 ,	1	# [1]
	alpha_ph2d_D	= 1 ,	1	# [1]
	lambda_ph2d_A	= 1 ,	1	# [1]
	lambda_ph2d_D	= 1 ,	1	# [1]
  * Surface roughness scattering parameters.
	delta	= 3.9700e+13 ,	3.9700e+13	# [cm^2/(Vs)]
	lambda_sr	= 0.057 ,	0.057	# [1]
	A	= 2 ,	2	# [1]
	alpha_sr	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	nu	= 0.0000e+00 ,	0.0000e+00	# [1]
	eta	= 1.0000e+50 ,	1.0000e+50	# [V^2/cm/s]
	N1	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	alpha_sr_A	= 1 ,	1	# [1]
	alpha_sr_D	= 1 ,	1	# [1]
	lambda_sr_A	= 1 ,	1	# [1]
	lambda_sr_D	= 1 ,	1	# [1]
	l_crit	= 1.0000e+03 ,	1.0000e+03	# [cm]
  * 2D Coulomb scattering parameters.
	D1_inv	= 1.3500e+02 ,	1.3500e+02	# [cm^2/(Vs)]
	D2_inv	= 40 ,	40	# [cm^2/(Vs)]
	nu0_inv	= 1.5 ,	1.5	# [1]
	nu1_inv	= 2 ,	2	# [1]
	nu2_inv	= 0.5 ,	0.5	# [1]
	alpha1_inv	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha2_inv	= 0.0000e+00 ,	0.0000e+00	# [1]
	D1_acc	= 1.3500e+02 ,	1.3500e+02	# [cm^2/(Vs)]
	D2_acc	= 40 ,	40	# [cm^2/(Vs)]
	nu0_acc	= 1.5 ,	1.5	# [1]
	nu1_acc	= 2 ,	2	# [1]
	nu2_acc	= 0.5 ,	0.5	# [1]
	alpha1_acc	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha2_acc	= 0.0000e+00 ,	0.0000e+00	# [1]
	tcoulomb	= 0.0000e+00 ,	0.0000e+00	# [um]
	t1      	= 3.0000e-04 ,	3.0000e-04	# [um]
  * Stress scaling parameters.
	a_ph2d	= 1 ,	1	# [1]
	a_ph3d	= 1 ,	1	# [1]
	a_c2d	= 1 ,	1	# [1]
	a_c3d	= 1 ,	1	# [1]
	a_sr	= 1 ,	1	# [1]
}

RCSMobility
{ *
  *          murcs0 * (N/N0)^gamma1 * (T/300)^gamma2 * g_screening^[gamma3+gamma4*ln(N/N0)]
  * mu_rcs = ------------------------------------------------------------------------------
  *                                  D_rcs * D_rcs_highk * f(En)
  *
  * g_screening = s + c/[c0*(N/N0)^gamma5]
  * N           = Na (for electrons), Nd (for holes)
  * N0          = 3e16/cm^3
  * c           = n (for electrons) , p (for holes)
  * f(En)       = 1 - exp[-xi*En/N_depl]
  * N_depl      = approximate depletion charge
  * D_rcs       = exp[-(dist + d_crit)/l_crit]
  * dist        = distance from interface
  * D_rcs_highk = exp[-dist_highk/l_crit_highk]
  * dist_highk  = distance from high-k insulator
  *
	murcs0	= 1.4900e+02 ,	1.4900e+02	# [cm^2/(Vs)]
	gamma1	= -2.3187e-01 ,	-2.3187e-01	# [1]
	gamma2	= 2.1 ,	2.1	# [1]
	gamma3	= 0.4 ,	0.4	# [1]
	gamma4	= 0.05 ,	0.05	# [1]
	gamma5	= 1 ,	1	# [1]
	s	= 0.1 ,	0.1	# [1]
	c0	= 3.0000e+16 ,	3.0000e+16	# [cm^-3]
	d_crit	= 0.0000e+00 ,	0.0000e+00	# [cm]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	l_crit_highk	= 1.0000e+06 ,	1.0000e+06	# [cm]
	xi	= 1.3042e+07 ,	1.3042e+07	# [V^-1 cm^-1]
	a_rcs	= 1 ,	1	# [1]
}

RCSMobility_aniso
{ *
  *          murcs0 * (N/N0)^gamma1 * (T/300)^gamma2 * g_screening^[gamma3+gamma4*ln(N/N0)]
  * mu_rcs = ------------------------------------------------------------------------------
  *                                  D_rcs * D_rcs_highk * f(En)
  *
  * g_screening = s + c/[c0*(N/N0)^gamma5]
  * N           = Na (for electrons), Nd (for holes)
  * N0          = 3e16/cm^3
  * c           = n (for electrons) , p (for holes)
  * f(En)       = 1 - exp[-xi*En/N_depl]
  * N_depl      = approximate depletion charge
  * D_rcs       = exp[-(dist + d_crit)/l_crit]
  * dist        = distance from interface
  * D_rcs_highk = exp[-dist_highk/l_crit_highk]
  * dist_highk  = distance from high-k insulator
  *
	murcs0	= 1.4900e+02 ,	1.4900e+02	# [cm^2/(Vs)]
	gamma1	= -2.3187e-01 ,	-2.3187e-01	# [1]
	gamma2	= 2.1 ,	2.1	# [1]
	gamma3	= 0.4 ,	0.4	# [1]
	gamma4	= 0.05 ,	0.05	# [1]
	gamma5	= 1 ,	1	# [1]
	s	= 0.1 ,	0.1	# [1]
	c0	= 3.0000e+16 ,	3.0000e+16	# [cm^-3]
	d_crit	= 0.0000e+00 ,	0.0000e+00	# [cm]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	l_crit_highk	= 1.0000e+06 ,	1.0000e+06	# [cm]
	xi	= 1.3042e+07 ,	1.3042e+07	# [V^-1 cm^-1]
	a_rcs	= 1 ,	1	# [1]
}

RPSMobility
{ *
  *          murps0 * (1e6/En)^gamma1 * (300/T)^gamma2
  * mu_rps = -----------------------------------------
  *                  D_rps * D_rps_highk
  *
  * D_rps       = exp[-(dist + d_crit)/l_crit]
  * dist        = distance from interface
  * D_rps_highk = exp[-dist_highk/l_crit_highk]
  * dist_highk  = distance from high-k insulator
  *
	murps0	= 4.9670e+02 ,	4.9670e+02	# [cm^2/(Vs)]
	gamma1	= 0.68 ,	0.68	# [1]
	gamma2	= 0.34 ,	0.34	# [1]
	d_crit	= 0.0000e+00 ,	0.0000e+00	# [cm]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	l_crit_highk	= 1.0000e+06 ,	1.0000e+06	# [cm]
	a_rps	= 1 ,	1	# [1]
}

RPSMobility_aniso
{ *
  *          murps0 * (1e6/En)^gamma1 * (300/T)^gamma2
  * mu_rps = -----------------------------------------
  *                  D_rps * D_rps_highk
  *
  * D_rps       = exp[-(dist + d_crit)/l_crit]
  * dist        = distance from interface
  * D_rps_highk = exp[-dist_highk/l_crit_highk]
  * dist_highk  = distance from high-k insulator
  *
	murps0	= 4.9670e+02 ,	4.9670e+02	# [cm^2/(Vs)]
	gamma1	= 0.68 ,	0.68	# [1]
	gamma2	= 0.34 ,	0.34	# [1]
	d_crit	= 0.0000e+00 ,	0.0000e+00	# [cm]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	l_crit_highk	= 1.0000e+06 ,	1.0000e+06	# [cm]
	a_rps	= 1 ,	1	# [1]
}

EffectiveStressModel
{ * Stress-dependent enhancement factor for mobility. See the manual for details.
	alpha1	= 1 ,	1	# [MPa]
	alpha2	= -1.7000e+00 ,	-4.0000e-01	# [MPa]
	alpha3	= 0.7 ,	-6.0000e-01	# [MPa]
	beta11	= 0.0000e+00 ,	0.0000e+00	# [MPa]
	beta12	= 0.0000e+00 ,	0.0000e+00	# [MPa]
	beta13	= 0.0000e+00 ,	-4.0000e-05	# [MPa]
	beta22	= 0.0000e+00 ,	6.0000e-05	# [MPa]
	beta23	= 0.0000e+00 ,	-1.8000e-04	# [MPa]
	beta33	= 0.0000e+00 ,	1.1000e-04	# [MPa]
	mu0	= 8.1000e+02 ,	2.1200e+02	# [cm^2/(Vs)]
	a10	= 5.6500e+02 ,	2.4600e+03	# [cm^2/(Vs)]
	a11	= -8.1000e+01 ,	0.0000e+00	# [cm^2/(Vs)]
	a12	= -4.4000e+01 ,	0.0000e+00	# [cm^2/(Vs)]
	a20	= 2.0280e+03 ,	42	# [cm^2/(Vs)]
	a21	= -1.9920e+03 ,	0.0000e+00	# [cm^2/(Vs)]
	a22	= 9.2000e+02 ,	0.0000e+00	# [cm^2/(Vs)]
	s00	= 1.3340e+03 ,	-1.3380e+03	# [MPa]
	s01	= -2.6460e+03 ,	0.0000e+00	# [MPa]
	s02	= 8.7500e+02 ,	0.0000e+00	# [MPa]
	t0	= 8.8200e+02 ,	5.2400e+02	# [MPa]
	t1	= -9.8700e+02 ,	0.0000e+00	# [MPa]
	t2	= 6.0400e+02 ,	0.0000e+00	# [MPa]
	F0	= 1.0000e+10 ,	1.0000e+10	# [1]
	F_fixed	= -1.0000e+00 ,	-1.0000e+00	# [MV/cm]
}

NegInterfaceChargeMobility
{ *
  *         mu1 * (T/300)^T_exp * [1 + c/(c_trans * ((Na,d + N1)/1e18)^N_exp1 * (Nc/N0)^Nc_exp1)]^c_exp
  * mu_ic = -------------------------------------------------------------------------------------------
  *                          ((Na,d + N2)/1e18)^N_exp2 * (Nc/N0)^Nc_exp2 * D * f(En)
  *
  * Nc    = negative interface charge density
  * N0    = 1e11/cm^2
  * c     = n (for electrons) , p (for holes)
  * f(En) = 1 - exp[-(En/E0)^En_exp]
  * D     = exp[-dist/l_crit]
  * dist  = distance from interface
  *
	mu1	= 40 ,	40	# [cm^2/Vs]
	T_exp	= 1 ,	1	# [1]
	c_trans	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
	c_exp	= 1.5 ,	1.5	# [1]
	Nc_exp1	= 1 ,	1	# [1]
	Nc_exp2	= 0.5 ,	0.5	# [1]
	N1	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	N_exp1	= 0.0000e+00 ,	0.0000e+00	# [1]
	N_exp2	= 0.0000e+00 ,	0.0000e+00	# [1]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	E0	= 2.0000e+05 ,	2.0000e+05	# [V/cm]
	En_exp	= 2 ,	2	# [1]
	a_c	= 1 ,	1	# [1]
}

NegInterfaceChargeMobility_aniso
{ *
  *         mu1 * (T/300)^T_exp * [1 + c/(c_trans * ((Na,d + N1)/1e18)^N_exp1 * (Nc/N0)^Nc_exp1)]^c_exp
  * mu_ic = -------------------------------------------------------------------------------------------
  *                          ((Na,d + N2)/1e18)^N_exp2 * (Nc/N0)^Nc_exp2 * D * f(En)
  *
  * Nc    = negative interface charge density
  * N0    = 1e11/cm^2
  * c     = n (for electrons) , p (for holes)
  * f(En) = 1 - exp[-(En/E0)^En_exp]
  * D     = exp[-dist/l_crit]
  * dist  = distance from interface
  *
	mu1	= 40 ,	40	# [cm^2/Vs]
	T_exp	= 1 ,	1	# [1]
	c_trans	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
	c_exp	= 1.5 ,	1.5	# [1]
	Nc_exp1	= 1 ,	1	# [1]
	Nc_exp2	= 0.5 ,	0.5	# [1]
	N1	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	N_exp1	= 0.0000e+00 ,	0.0000e+00	# [1]
	N_exp2	= 0.0000e+00 ,	0.0000e+00	# [1]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	E0	= 2.0000e+05 ,	2.0000e+05	# [V/cm]
	En_exp	= 2 ,	2	# [1]
	a_c	= 1 ,	1	# [1]
}

PosInterfaceChargeMobility
{ *
  *         mu1 * (T/300)^T_exp * [1 + c/(c_trans * ((Na,d + N1)/1e18)^N_exp1 * (Nc/N0)^Nc_exp1)]^c_exp
  * mu_ic = -------------------------------------------------------------------------------------------
  *                          ((Na,d + N2)/1e18)^N_exp2 * (Nc/N0)^Nc_exp2 * D * f(En)
  *
  * Nc    = positive interface charge density
  * N0    = 1e11/cm^2
  * c     = n (for electrons) , p (for holes)
  * f(En) = 1 - exp[-(En/E0)^En_exp]
  * D     = exp[-dist/l_crit]
  * dist  = distance from interface
  *
	mu1	= 40 ,	40	# [cm^2/Vs]
	T_exp	= 1 ,	1	# [1]
	c_trans	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
	c_exp	= 1.5 ,	1.5	# [1]
	Nc_exp1	= 1 ,	1	# [1]
	Nc_exp2	= 0.5 ,	0.5	# [1]
	N1	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	N_exp1	= 0.0000e+00 ,	0.0000e+00	# [1]
	N_exp2	= 0.0000e+00 ,	0.0000e+00	# [1]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	E0	= 2.0000e+05 ,	2.0000e+05	# [V/cm]
	En_exp	= 2 ,	2	# [1]
	a_c	= 1 ,	1	# [1]
}

PosInterfaceChargeMobility_aniso
{ *
  *         mu1 * (T/300)^T_exp * [1 + c/(c_trans * ((Na,d + N1)/1e18)^N_exp1 * (Nc/N0)^Nc_exp1)]^c_exp
  * mu_ic = -------------------------------------------------------------------------------------------
  *                          ((Na,d + N2)/1e18)^N_exp2 * (Nc/N0)^Nc_exp2 * D * f(En)
  *
  * Nc    = positive interface charge density
  * N0    = 1e11/cm^2
  * c     = n (for electrons) , p (for holes)
  * f(En) = 1 - exp[-(En/E0)^En_exp]
  * D     = exp[-dist/l_crit]
  * dist  = distance from interface
  *
	mu1	= 40 ,	40	# [cm^2/Vs]
	T_exp	= 1 ,	1	# [1]
	c_trans	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
	c_exp	= 1.5 ,	1.5	# [1]
	Nc_exp1	= 1 ,	1	# [1]
	Nc_exp2	= 0.5 ,	0.5	# [1]
	N1	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	N_exp1	= 0.0000e+00 ,	0.0000e+00	# [1]
	N_exp2	= 0.0000e+00 ,	0.0000e+00	# [1]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	E0	= 2.0000e+05 ,	2.0000e+05	# [V/cm]
	En_exp	= 2 ,	2	# [1]
	a_c	= 1 ,	1	# [1]
}

Coulomb2DMobility
{ *
  *         mu1 * (T/300)^T_exp * [1 + c/(c_trans * ((Na,d + N1)/1e18)^N_exp1 * (Nc/N0)^Nc_exp1)]^c_exp
  * mu_ic = -------------------------------------------------------------------------------------------
  *                          ((Na,d + N2)/1e18)^N_exp2 * (Nc/N0)^Nc_exp2 * D * f(En)
  *
  * Nc    = Na (for electrons), Nd (for holes)
  * N0    = 1e18/cm^3
  * c     = n (for electrons) , p (for holes)
  * f(En) = 1 - exp[-(En/E0)^En_exp]
  * D     = exp[-dist/l_crit]
  * dist  = distance from interface
  *
	mu1	= 40 ,	40	# [cm^2/Vs]
	T_exp	= 1 ,	1	# [1]
	c_trans	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
	c_exp	= 1.5 ,	1.5	# [1]
	Nc_exp1	= 1 ,	1	# [1]
	Nc_exp2	= 0.5 ,	0.5	# [1]
	N1	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	N_exp1	= 0.0000e+00 ,	0.0000e+00	# [1]
	N_exp2	= 0.0000e+00 ,	0.0000e+00	# [1]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	E0	= 2.0000e+05 ,	2.0000e+05	# [V/cm]
	En_exp	= 2 ,	2	# [1]
	a_c	= 1 ,	1	# [1]
}

Coulomb2DMobility_aniso
{ *
  *         mu1 * (T/300)^T_exp * [1 + c/(c_trans * ((Na,d + N1)/1e18)^N_exp1 * (Nc/N0)^Nc_exp1)]^c_exp
  * mu_ic = -------------------------------------------------------------------------------------------
  *                          ((Na,d + N2)/1e18)^N_exp2 * (Nc/N0)^Nc_exp2 * D * f(En)
  *
  * Nc    = Na (for electrons), Nd (for holes)
  * N0    = 1e18/cm^3
  * c     = n (for electrons) , p (for holes)
  * f(En) = 1 - exp[-(En/E0)^En_exp]
  * D     = exp[-dist/l_crit]
  * dist  = distance from interface
  *
	mu1	= 40 ,	40	# [cm^2/Vs]
	T_exp	= 1 ,	1	# [1]
	c_trans	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
	c_exp	= 1.5 ,	1.5	# [1]
	Nc_exp1	= 1 ,	1	# [1]
	Nc_exp2	= 0.5 ,	0.5	# [1]
	N1	= 1 ,	1	# [cm^(-3)]
	N2	= 1 ,	1	# [cm^(-3)]
	N_exp1	= 0.0000e+00 ,	0.0000e+00	# [1]
	N_exp2	= 0.0000e+00 ,	0.0000e+00	# [1]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	E0	= 2.0000e+05 ,	2.0000e+05	# [V/cm]
	En_exp	= 2 ,	2	# [1]
	a_c	= 1 ,	1	# [1]
}

CarrierCarrierScattering
{ * with Conwell/Weisskopf screening:
  * mu_cc = D (T/T0)^3/2 / sqrt(n p) [ln( 1 + F (T/T0)^2 (n p)^(-1/3))]^(-1)
	D	= 1.0400e+21	# [(cmVs)^(-1)]
	F	= 7.4520e+13	# [(cm)^(-2)]

  * with Brooks/Herring screening:
  * mu_cc = c1 (T/T0)^1.5 / ( sqrt(n,p) ( ln(1+eta) - eta / (1+eta) ) )
  *  with   eta = c2(T/T0)^2/(n+p)
	c1	= 1.5600e+21	# [(cmVs)^(-1)]
	c2	= 7.6300e+19	# [cm^(-3)]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 1.109 ,	1.213	# [1]
	betaexp	= 0.66 ,	0.17	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 1.0700e+07 ,	8.3700e+06	# [1]
	vsatexp	= 0.87 ,	0.52	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 1.109 ,	1.213	# [1]
	betaexp	= 0.66 ,	0.17	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 1.0700e+07 ,	8.3700e+06	# [1]
	vsatexp	= 0.87 ,	0.52	# [1]
}

UniBoDopingDependence:
{
  * Baccarani model (University of Bologna) is used:
  * Constant mobility model is defined here as well:
  * mu_const = mumax (T/T0)^(-Exponent+Exponent2*(T/T0))
  * mu_dop = mu_0(Na,Nd,T/T0)                                               
  *         + (mu_const - mu_0)/(1 + (Nd/Cr)^alpha + (Na/Cr2)^beta)         
  *         - mu_1(Na,Nd,T/T0)/(1+(Nd/Cs + Na/Cs2)^(-2))                    
  * with mu_const from above
  * mu_0 = (mumin1 (T/T0)^(-mumin1_exp) Nd + mumin2 (T/T0)^(-mumin2_exp)Na)/(Nd+Na)
  * mu_1 = (mu1 (T/T0)^(-mu1_exp) Nd + mu2 (T/T0)^(-mu2_exp) Na)/(Nd+Na)
  * Cr=Cr (T/T0)^Cr_exp
  * Cr2=Cr2 (T/T0)^Cr2_exp
  * Cs=Cs (T/T0)^Cs_exp
	mumax	= 1.4410e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.45 ,	2.16	# [1]
	Exponent2	= -1.1000e-01 ,	0.0000e+00	# [1]
	mumin1	= 55 ,	90	# [cm^2/Vs]
	mumin2	= 1.3200e+02 ,	44	# [cm^2/Vs]
	mumin1_exp	= 0.6 ,	1.3	# [1]
	mumin2_exp	= 1.3 ,	0.7	# [1]
	mu1	= 42.4 ,	28.2	# [cm^2/Vs]
	mu2	= 73.5 ,	28.2	# [cm^2/Vs]
	mu1_exp	= 0.5 ,	2	# [1]
	mu2_exp	= 1.25 ,	0.8	# [1]
	Pc	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	Cr	= 8.9000e+16 ,	1.3000e+18	# [cm^3]
	Cr2	= 1.2200e+17 ,	2.4500e+17	# [cm^3]
	Cs	= 2.9000e+20 ,	1.1000e+18	# [cm^3]
	Cs2	= 7.0000e+20 ,	6.1000e+20	# [cm^3]
	Cr_exp	= 3.65 ,	2.2	# [1]
	Cr2_exp	= 2.65 ,	3.1	# [1]
	Cs_exp	= 0.0000e+00 ,	6.2	# [1]
	alpha	= 0.68 ,	0.77	# [1]
	beta	= 0.72 ,	0.719	# [1]
}

UniBoDopingDependence_aniso:
{
  * Baccarani model (University of Bologna) is used:
  * Constant mobility model is defined here as well:
  * mu_const = mumax (T/T0)^(-Exponent+Exponent2*(T/T0))
  * mu_dop = mu_0(Na,Nd,T/T0)                                               
  *         + (mu_const - mu_0)/(1 + (Nd/Cr)^alpha + (Na/Cr2)^beta)         
  *         - mu_1(Na,Nd,T/T0)/(1+(Nd/Cs + Na/Cs2)^(-2))                    
  * with mu_const from above
  * mu_0 = (mumin1 (T/T0)^(-mumin1_exp) Nd + mumin2 (T/T0)^(-mumin2_exp)Na)/(Nd+Na)
  * mu_1 = (mu1 (T/T0)^(-mu1_exp) Nd + mu2 (T/T0)^(-mu2_exp) Na)/(Nd+Na)
  * Cr=Cr (T/T0)^Cr_exp
  * Cr2=Cr2 (T/T0)^Cr2_exp
  * Cs=Cs (T/T0)^Cs_exp
	mumax	= 1.4410e+03 ,	4.7050e+02	# [cm^2/(Vs)]
	Exponent	= 2.45 ,	2.16	# [1]
	Exponent2	= -1.1000e-01 ,	0.0000e+00	# [1]
	mumin1	= 55 ,	90	# [cm^2/Vs]
	mumin2	= 1.3200e+02 ,	44	# [cm^2/Vs]
	mumin1_exp	= 0.6 ,	1.3	# [1]
	mumin2_exp	= 1.3 ,	0.7	# [1]
	mu1	= 42.4 ,	28.2	# [cm^2/Vs]
	mu2	= 73.5 ,	28.2	# [cm^2/Vs]
	mu1_exp	= 0.5 ,	2	# [1]
	mu2_exp	= 1.25 ,	0.8	# [1]
	Pc	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	Cr	= 8.9000e+16 ,	1.3000e+18	# [cm^3]
	Cr2	= 1.2200e+17 ,	2.4500e+17	# [cm^3]
	Cs	= 2.9000e+20 ,	1.1000e+18	# [cm^3]
	Cs2	= 7.0000e+20 ,	6.1000e+20	# [cm^3]
	Cr_exp	= 3.65 ,	2.2	# [1]
	Cr2_exp	= 2.65 ,	3.1	# [1]
	Cs_exp	= 0.0000e+00 ,	6.2	# [1]
	alpha	= 0.68 ,	0.77	# [1]
	beta	= 0.72 ,	0.719	# [1]
}

UniBoEnormalDependence:
{ * Baccarani model (University of Bologna):
  * 1/mu_dop_sc = (1/mu_dop) * [D(f_sc^tau + 1)^(-1/tau) + (a-D)] with:
  * mu_dop from DopingDependence , and D=exp(-d/l_crit)
  * f_sc =(N1/Ntot)^eta (c_ele (n-n0) +c_hole (p-p0))/Ntot 
  * 1/mu_Enorm = 1/mu_ac + 1/mu_sr  with:
  * mu_ac = C (T/T)^(-C_exp)/ Enorm^delta (Ntot/N2)^ac_exp 
  * mu_sr = B (T/T)^(B_exp)/ Enorm^lambda ((Ntot+N3)/N4)^sr_exp
	B	= 5.8000e+18 ,	7.8200e+15	# [cm/s]
	C	= 1.8600e+04 ,	5.7260e+03	# [cm/s]
	lambda	= 2.64 ,	2.24	# [1]
	delta	= 0.29 ,	0.3	# [1]
	eta	= 0.3 ,	0.5	# [1]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	tau	= 1 ,	3	# [1]
	c_ele	= 1 ,	0.0000e+00	# [1]
	c_hole	= 0.0000e+00 ,	1	# [1]
	C_exp	= 2.1 ,	1.3	# [1]
	B_exp	= 0.0000e+00 ,	1.4	# [1]
	ac_exp	= 0.026 ,	-2.0000e-02	# [1]
	sr_exp	= 0.11 ,	0.08	# [1]
	N1	= 2.3400e+16 ,	2.0200e+16	# [cm^(-3)]
	N2	= 4.0000e+15 ,	7.8000e+15	# [cm^(-3)]
	N3	= 1.0000e+17 ,	2.0000e+15	# [cm^(-3)]
	N4	= 2.4000e+18 ,	6.6000e+17	# [cm^(-3)]
	a	= 0.0000e+00 ,	0.0000e+00	# [1]
}

UniBoEnormalDependence_aniso:
{ * Baccarani model (University of Bologna):
  * 1/mu_dop_sc = (1/mu_dop) * [D(f_sc^tau + 1)^(-1/tau) + (a-D)] with:
  * mu_dop from DopingDependence , and D=exp(-d/l_crit)
  * f_sc =(N1/Ntot)^eta (c_ele (n-n0) +c_hole (p-p0))/Ntot 
  * 1/mu_Enorm = 1/mu_ac + 1/mu_sr  with:
  * mu_ac = C (T/T)^(-C_exp)/ Enorm^delta (Ntot/N2)^ac_exp 
  * mu_sr = B (T/T)^(B_exp)/ Enorm^lambda ((Ntot+N3)/N4)^sr_exp
	B	= 5.8000e+18 ,	7.8200e+15	# [cm/s]
	C	= 1.8600e+04 ,	5.7260e+03	# [cm/s]
	lambda	= 2.64 ,	2.24	# [1]
	delta	= 0.29 ,	0.3	# [1]
	eta	= 0.3 ,	0.5	# [1]
	l_crit	= 1.0000e-06 ,	1.0000e-06	# [cm]
	tau	= 1 ,	3	# [1]
	c_ele	= 1 ,	0.0000e+00	# [1]
	c_hole	= 0.0000e+00 ,	1	# [1]
	C_exp	= 2.1 ,	1.3	# [1]
	B_exp	= 0.0000e+00 ,	1.4	# [1]
	ac_exp	= 0.026 ,	-2.0000e-02	# [1]
	sr_exp	= 0.11 ,	0.08	# [1]
	N1	= 2.3400e+16 ,	2.0200e+16	# [cm^(-3)]
	N2	= 4.0000e+15 ,	7.8000e+15	# [cm^(-3)]
	N3	= 1.0000e+17 ,	2.0000e+15	# [cm^(-3)]
	N4	= 2.4000e+18 ,	6.6000e+17	# [cm^(-3)]
	a	= 0.0000e+00 ,	0.0000e+00	# [1]
}

HydroHighFieldDependence:
{ * Parameter specifications for the high field degradation in 
  * some hydrodynamic models.
  * (A) Meinerzhagen-Engl model (ED-35, pp. 689-697):
  * mu_hf = mu / ( 1 + (3*mu/(2*vsat^2*tau_e) * (Tc-Tl))^beta )^1/beta
  * Tc=carrier temperature; Tl=lattice temperature
  * beta = beta0 (Tl/T0)^betaexp
  * Only for the Meinerzhagen-Engl model (ED-35, pp. 689-697)
	beta0	= 0.6 ,	0.6	# [1]
	betaexp	= 0.01 ,	0.01	# [1]

 * (B) Approximation by the ratio of two irrational polynomials
 * (driving force 'CarrierTempDrivePolynomial'):
 * If Wmax(interval-1) < w < Wmax(interval), then:
 * mu_hf = mu*factor*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)={SIGMA[A(i)(w^P(i))]+D*Ni},
 * w=Tc/Tl; Ni(cm^-3) is total doping.
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 *
 *      Wmax(interval)_ele = 
 *      F(interval)_ele     =  
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        D     = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        D     = 
 *        G     = 
 *      }
 *
 *      F(interval)_hol     =     
 *      Wmax(interval)_hol = 

 * (C) Approximation by a spline function
 * (driving force 'CarrierTempDriveSpline'):
 * The high field mobility is computed as
 *
 *   mu_hf = mu * spline(w)
 *
 * where the function spline(w) is defined by a sequence of
 * value pairs, for example:
 *
 *      Spline (electron) {
 *        0   1
 *        1   1
 *        2   2.5
 *        4   4
 *        10  5
 *      }
 *
 *      Spline (hole) {
 *        0   1
 *        1   1
 *        2   0.75
 *        4   0.5
 *        10  0.2
 *      }
 *
 * The given data points are interpolated by a cubic spline.  Zero
 * derivatives are imposed as boundary conditions at the end points.
 * The spline function remains constant beyond the end points.
}

HydroHighFieldDependence_aniso:
{ * Parameter specifications for the high field degradation in 
  * some hydrodynamic models.
  * (A) Meinerzhagen-Engl model (ED-35, pp. 689-697):
  * mu_hf = mu / ( 1 + (3*mu/(2*vsat^2*tau_e) * (Tc-Tl))^beta )^1/beta
  * Tc=carrier temperature; Tl=lattice temperature
  * beta = beta0 (Tl/T0)^betaexp
  * Only for the Meinerzhagen-Engl model (ED-35, pp. 689-697)
	beta0	= 0.6 ,	0.6	# [1]
	betaexp	= 0.01 ,	0.01	# [1]

 * (B) Approximation by the ratio of two irrational polynomials
 * (driving force 'CarrierTempDrivePolynomial'):
 * If Wmax(interval-1) < w < Wmax(interval), then:
 * mu_hf = mu*factor*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)={SIGMA[A(i)(w^P(i))]+D*Ni},
 * w=Tc/Tl; Ni(cm^-3) is total doping.
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 *
 *      Wmax(interval)_ele = 
 *      F(interval)_ele     =  
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        D     = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        D     = 
 *        G     = 
 *      }
 *
 *      F(interval)_hol     =     
 *      Wmax(interval)_hol = 

 * (C) Approximation by a spline function
 * (driving force 'CarrierTempDriveSpline'):
 * The high field mobility is computed as
 *
 *   mu_hf = mu * spline(w)
 *
 * where the function spline(w) is defined by a sequence of
 * value pairs, for example:
 *
 *      Spline (electron) {
 *        0   1
 *        1   1
 *        2   2.5
 *        4   4
 *        10  5
 *      }
 *
 *      Spline (hole) {
 *        0   1
 *        1   1
 *        2   0.75
 *        4   0.5
 *        10  0.2
 *      }
 *
 * The given data points are interpolated by a cubic spline.  Zero
 * derivatives are imposed as boundary conditions at the end points.
 * The spline function remains constant beyond the end points.
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-05 ,	3.0000e-06	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= -1.5000e+00 ,	-1.5000e+00	# [1]
	Tcoeff	= 2.55 ,	2.55	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

SurfaceRecombination * surface SRH recombination:
{ * s = S0 ( 1 + Sref ( N/Nref )^gamma ) recombination velocity
	S0	= 1.0000e+03 ,	1.0000e+03	# [cm/s]
	Sref	= 1.0000e-03	# [1]
	Nref	= 1.0000e+16	# [cm^(-3)]
	gamma	= 1	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 6.7000e-32 ,	7.2000e-32	# [cm^6/s]
	B	= 2.4500e-31 ,	4.5000e-33	# [cm^6/s]
	C	= -2.2000e-32 ,	2.6300e-32	# [cm^6/s]
	H	= 3.46667 ,	8.25688	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

TrapAssistedAuger * lifetimes:
{ * 1/tau_TAA = c ( n + p ) 
	c	= 1.0000e-12 ,	1.0000e-12	# [cm^3/s]
}

TrapAssistedTunneling
{ * See Sentaurus Device manual `Trap-Assisted Tunneling enhanced SRH'
	S	= 3.5	# [1]
	hbarOmega	= 0.068	# [eV]
	m_theta	= 0.258 ,	0.24	# [1]
	Z	= 0.0000e+00	# [1]
	MinField	= 0.0000e+00	# [V/cm]
	DenCorRef	= 1.0000e+03 ,	1.0000e+03	# [cm^-3]
}

HurkxTrapAssistedTunneling
{ * SRHlifetime = tau0/(1+Gt) 
  * TrapXsection = Xsec0*(1+Gt) 
  * Gt = pi^0.5*E*exp(E*E/3)*(2-erfc(0.5*(En/E-E))),      for E < En^0.5 
  * Gt = (pi*E)^0.5*En^0.25*exp(-En+E*En^0.5+En^1.5/E/3)* 
  *      erfc(E^0.5*En^0.25-En^0.75/E^0.5),               for E >= En^0.5 
  * where 
  *       E = F/Fref, 
  *       F is the electric field, 
  *       Fref = (8*mt*m0*(kB*T)^3)^0.5/q/h / ~4.3e5*mt^0.5*(T/300)^1.5 V/cm /, 
  *       En is a function of trap level and carrier concentration (see manual),
  *             the trap level will be used from SRH or Trap specifications. 
	mt	= 0.5 ,	0.5	# [1]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 11.7 ,	11.7	# [1]
}

CDL * Coupled Defect-Level Recombination:
{ * See Simul manual 'Coupled  Defect-Level Recombination 
  * Here: Variable = value for trap1 , value for trap2  # [units] 
	Etrap	= 0.0000e+00 ,	0.0000e+00	# [eV]
	e_taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	e_taumax	= 1.0000e-05 ,	1.0000e-05	# [s]
	e_Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	e_gamma	= 1 ,	1	# [1]
	e_Talpha	= -1.5000e+00 ,	-1.5000e+00	# [1]
	e_Tcoeff	= 2.55 ,	2.55	# [1]
	h_taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	h_taumax	= 3.0000e-06 ,	3.0000e-06	# [s]
	h_Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	h_gamma	= 1 ,	1	# [1]
	h_Talpha	= -1.5000e+00 ,	-1.5000e+00	# [1]
	h_Tcoeff	= 2.55 ,	2.55	# [1]
	m_theta_e	= 0.258 ,	0.258	# [1]
	m_theta_h	= 0.24 ,	0.24	# [1]
	TrapTrapRate	= 1.0000e+15	# [cm^-3 s^-1]
	S	= 2 ,	2	# [1]
	hbarOmega	= 0.068 ,	0.068	# [eV]
	MinField	= 0.0000e+00	# [V/cm]
	Z	= 0.0000e+00 ,	0.0000e+00	# [1]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 7.0300e+05 ,	1.5820e+06	# [1/cm]
	a(high)	= 7.0300e+05 ,	6.7100e+05	# [1/cm]
	b(low)	= 1.2310e+06 ,	2.0360e+06	# [V/cm]
	b(high)	= 1.2310e+06 ,	1.6930e+06	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 0.063 ,	0.063	# [eV]
	beta(low)	= 0.678925 ,	0.815009	# [1]
	beta(high)	= 0.678925 ,	0.677706	# [1]
	lambda	= 6.2000e-07 ,	4.5000e-07	# [cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 7.0300e+05 ,	1.5820e+06	# [1/cm]
	a(high)	= 7.0300e+05 ,	6.7100e+05	# [1/cm]
	b(low)	= 1.2310e+06 ,	2.0360e+06	# [V/cm]
	b(high)	= 1.2310e+06 ,	1.6930e+06	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 0.063 ,	0.063	# [eV]
	beta(low)	= 0.678925 ,	0.815009	# [1]
	beta(high)	= 0.678925 ,	0.677706	# [1]
	lambda	= 6.2000e-07 ,	4.5000e-07	# [cm]
}

OkutoCrowell * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = a (1+c(T-300)) E^gamma exp[-(Ecrit (1+d(T-300)) /E )^delta]
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a	= 0.426 ,	0.243	# [1/V]
	b	= 4.8100e+05 ,	6.5300e+05	# [V/cm]
	c	= 3.0500e-04 ,	5.3500e-04	# [1/K]
	d	= 6.8600e-04 ,	5.6700e-04	# [1/K]
	gamma	= 1 ,	1	# [1]
	delta	= 2 ,	2	# [1]
	beta	= 0.265283 ,	0.261395	# [1]
	lambda	= 6.2000e-07 ,	4.5000e-07	# [cm]
}

OkutoCrowell_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = a (1+c(T-300)) E^gamma exp[-(Ecrit (1+d(T-300)) /E )^delta]
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a	= 0.426 ,	0.243	# [1/V]
	b	= 4.8100e+05 ,	6.5300e+05	# [V/cm]
	c	= 3.0500e-04 ,	5.3500e-04	# [1/K]
	d	= 6.8600e-04 ,	5.6700e-04	# [1/K]
	gamma	= 1 ,	1	# [1]
	delta	= 2 ,	2	# [1]
	beta	= 0.265283 ,	0.261395	# [1]
	lambda	= 6.2000e-07 ,	4.5000e-07	# [cm]
}

Lackner * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = a_x gamma / Z exp(-Ecrit_x gamma / E)  ,  x=n,p
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT)) 
  * and Z = 1 + gamma (Ecrit_n/E) exp(-gamma Ecrit_n / E) + gamma (Ecrit_p/E) exp(-gamma Ecrit_p / E)
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a	= 1.3160e+06 ,	1.8180e+06	# [1/cm]
	b	= 1.4740e+06 ,	2.0360e+06	# [V/cm]
	hbarOmega	= 0.063 ,	0.063	# [eV]
	beta	= 0.812945 ,	0.815009	# [1]
	lambda	= 6.2000e-07 ,	4.5000e-07	# [cm]
}

UniBo * Impact Ionization (University of Bologna):
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha_p = E / (A_p + B_p * exp(D_p/(E + C_p))) 
  * with alpha_n = E / (A_n + B_e * exp(D_e/(E + C_e))) 
  * with A_p = a0_p + a1_p * T 
  * with B_p = b0_p * exp (b1_p * T) 
  * with C_p = c0_p * T^(c1_p)   
  * with D_p = (Ecrit_p/d0_p) * (d0_p + d1_p * T + d2_p *T^2)  
  * with A_n = a0_n + a1_n * T ^(a2_n)   
  * with B_n = b0_n   
  * with C_n = c0_n + c1_n * T + c2_n *T^2  
  * with D_n = (Ecrit_n/d0_n) * (d0_n + d1_n * T + d2_n *T^2  
  * and Ecrit = d0 (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	ha0	= 4.3383 ,	2.376	# [V]
	ha1	= -2.4200e-12 ,	0.01033	# [V]
	ha2	= 4.1233 ,	0.0000e+00	# [1]
	hb0	= 0.235 ,	0.17714	# [V]
	hb1	= 0.0000e+00 ,	-2.1780e-03	# [1]
	hb2	= 0.0000e+00 ,	0.0000e+00	# [1]
	hc0	= 1.6831e+04 ,	9.4700e-03	# [V/cm]
	hc1	= 4.3796 ,	2.4924	# [V/cm, 1]
	hc2	= 0.13005 ,	0.0000e+00	# [V/cm, 1]
	hd0	= 1.2337e+06 ,	1.4043e+06	# [V/cm]
	hd1	= 1.2039e+03 ,	2.9744e+03	# [V/cm]
	hd2	= 0.56703 ,	1.4829	# [V/cm]
	beta	= 0.680414 ,	0.56214	# [1]
	lambda	= 6.2000e-07 ,	4.5000e-07	# [cm]
}

Band2BandTunneling 
{ * See Sentaurus Device manual `Band-To-Band Tunneling' 
	A	= 8.9770e+20	# [1/cm/sec/V^2]
	B	= 2.1466e+07	# [V/cm/eV^1.5]
	hbarOmega	= 0.0186	# [eV]

  * Traditional models for the following keywords in input file:
  * Band2Band(E1)  : A1*E*exp(-B1/E)
  * Band2Band(E1_5): A1_5*E^1.5*exp(-B1_5/E)
  * Band2Band(E2)  : A2*E^2*exp(-B2/E)
	A1	= 1.1000e+27	# [1/cm^2/sec/V]
	B1	= 2.1300e+07	# [V/cm]
	A1_5	= 1.9000e+24	# [1/cm^1.5/sec/V^1.5]
	B1_5	= 2.1900e+07	# [V/cm]
	A2	= 3.5000e+21	# [1/cm/sec/V^2]
	B2	= 2.2500e+07	# [V/cm]

  * Hurkx model for the following keywords in input file:
  * Band2Band(Hurkx)  : -Agen*D*(E/E0)^Pgen*exp(-Bgen*(Eg/Eg300)^1.5/E) if D < 0
  *                     -Arec*D*(E/E0)^Prec*exp(-Brec*(Eg/Eg300)^1.5/E) if D > 0
  *                     D = (n*p-ni^2)/(n+ni)/(p+ni)*(1-|alpha|)+alpha, E0 = 1 V/cm
  *                     So, if alpha = 0, it's original Hurkx model,
  *                         if alpha = -1, it's only generation,
  *                         if alpha = +1, it's only recombination.
	Agen	= 3.5000e+21	# [1/cm^3/sec]
	Bgen	= 2.2500e+07	# [V/cm]
	Pgen	= 2	# [1]
	Arec	= 3.5000e+21	# [1/cm^3/sec]
	Brec	= 2.2500e+07	# [V/cm]
	Prec	= 2	# [1]
	alpha	= 0.0000e+00	# [1]

  * nonlocal B2B models for the following keywords in command file:
  * Band2Band(Model=NonlocalPath) : Nonlocal B2B tunneling with transition process using the tunneling path
  * For the nonlocal B2B process:
  * Apath : Prefactor Ad or Ap in the uniform field limit for the direct or indirect tunneling
  * Bpath : Exponent  Bd or Bp in the uniform field limit for the direct or indirect tunneling
  * Cpath : Factor g*Dop^2/rho for indirect tunneling
  * Dpath : The conduction band offset D
  * Ppath : The phonon energy P
  *         Note that the indirect tunneling process is assumed if P>0, and the direct tunneling process is assumed if P=0
  * Rpath : The ratio mv/mc. If Rpathi=0, it is automatically determined by
  *         mv/mc = (1 + 2*mr)/(1 - 2*mr)
  *         where mr=mc*mv/(mc+mv) is the reduced mass
  * g     : Degeneracy factor
  * m_c   : Effective mass in the conduction band
  * m_v   : Effective mass in the valence band
  * In the uniform field limit, the generation rate can be expressed by
  * G = A * (F/F0)^2   * Exp(-B/F) for   direct tunneling
  *   = A * (F/F0)^2.5 * Exp(-B/F) for indirect tunneling
  * where
  * Ad = g * mr^0.5 * (qF0)^2 / (36 * pi * h_bar^2 *E_T^0.5)
  * Ap = g *(mc*mv)^1.5 * (1+2*N) * (qF0)^2.5 * Dop^2 / (2^7.75 * pi^2.5 * h_bar^2.5 * mr^1.25 * E_T^1.75 * rho * P)
  * Bd = pi    * mr^0.5 * E_T^1.5 / (2 * h_bar * q)
  * Bp = 2^2.5 * mr^0.5 * E_T^1.5 / (3 * h_bar * q)
  * F0 = 1 V/cm, qF0 = 1 eV/cm, E_T = E_G + D
  * For the paramter set (APath, Bpath, Dpath, Ppath, Rpath), the microscopic parameters such as mr, mc, and mv for the nonlocal B2B model are extracted internally.   * For the parameter set (Cpath, g, m_c, m_v), the microscopic parameters are used directly for the tunneling rate computation.
	Apath	= 4.0000e+14	# [1/cm^3/sec]
	Bpath	= 1.9000e+07	# [V/cm]
	Cpath	= 0.0000e+00	# [J^2*cm/kg]
	Dpath	= 0.0000e+00	# [eV]
	Ppath	= 0.037	# [eV]
	Rpath	= 0.0000e+00	# [1]
	m_c	= 0.0000e+00	# [m0]
	m_v	= 0.0000e+00	# [m0]
	degeneracy	= 0.0000e+00	# [1]
	QuantumPotentialFactor	= 0.0000e+00 ,	0.0000e+00	# [1]
	MaxTunnelLength	= 1.0000e-05	# [cm]

  * min length to interfaces (for traditional & Hurkx models):
	dDist	= 0.0000e+00	# [cm]
  * min potential difference on length dPot/E (for traditional & Hurkx models):
	dPot	= 0.0000e+00	# [V]
  * numeric smoothing
	MinField	= 0.0000e+00	# [V/cm]
	MinGradQF	= 0.0000e+00	# [eV/cm]
	DenCorRef	= 0.0000e+00 ,	0.0000e+00	# [cm^-3]
}


BarrierTunneling  
{ * Non Local Barrier Tunneling 
  * G(r) = g*A*T/kB*F(r)*Pt(r)*ln[(1+exp((E(r)-Es)/kB/T))/(1+exp((E(r)-Em)/kB/T))]
  * where: 
  *     Pt(r) is WKB approximation for the tunneling probability 
  *     g = As/A, As is the Richardson constant for carriers in semiconductor
  *     A is the Richardson constant for free electrons 
  *     F(r) is the electric field 
  *     E(r) is carrier energy 
  *     Es is carrier quasi fermi energy in semiconductor
  *     Em is carrier fermi energy in metal 
  *     alpha is the prefactor for quantum potential correction 
  *     eoffset and hoffset are lists of band offsets
	g	= 2.1 ,	0.66	# [1]
	mt	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	eoffset = () # eV
	hoffset = () # eV
}


MSPeltierHeat  
{ * Metal/Semiconductor Peltier heat parameters 
  * Hpeltier = j*(alpha*Ediff + (1-alpha)*deltaE)/e0   Peltier Heat
  * where: 
  *     j is the current density 
  *     alpha is an adjustable parameter 
  *     deltaE is additional energy variation at interface 
  *     Ediff is the Fermi energy difference at interface 
  *      = QF-(beta*(eQF+gamma*Pn*T)-(1-beta)*Ec) for electrons
  *      = QF-(beta*(hQF+gamma*Pp*T)-(1-beta)*Ev) for holes
  *     Here, beta is zero for the default temperature and the
  *     hydrodynamic model, and adjustable for the thermodynamic model.
	alpha	= 1 ,	1	# [1]
	beta	= 1 ,	1	# [1]
	gamma	= 1 ,	1	# [1]
	deltaE	= 0.0000e+00 ,	0.0000e+00	# [eV]
}


CondInsCurr  
{ * ConductiveInsulator/Semiconductor current parameter 
  * jc = curw*je + (1-curw)*jh 
  * where: 
  *     jc is the conduction current density 
  *     je is the electron current density 
  *     jh is the hole current density 
  *     curw is fraction of current converted to je 
	curw	= 1	# [1]
}


GaussianDOS_full  
{ * GaussianDOS parameters 
  * D(E) = Nt/sigmaDOS/Sqrt(2*Pi)*Exp(-(E-E0)*(E-E0)/sigmaDOS/SigmaDOS)  
  * where: 
  *     Nt is the total density 
  *     sigmaDOS is the distribution width 
  *     E0 is the position of the maximum from the band edge 
	Nt	= 1.0000e+21 ,	1.0000e+21	# [cm-3]
	sigmaDOS	= 0.052 ,	0.052	# [eV]
	E0	= 0.1 ,	0.1	# [eV]
}


SingletExciton  
{ * gamma - prefactor for singlet exciton generation rate 
  * l_diff - singlet exciton diffusion length 
  * tau - singlet exciton lifetime for radiative decay
  * tau_trap - singlet exciton lifetime for trap-assisted radiative decay
  * ex_cXsection - singlet exciton-carrier reaction cross section 
  * ex_dXsection - singlet exciton-dissociation center cross section 
  * vth - singlet exciton thermal velocity at 300 K 
  * vel - singlet exciton interface recombination velocity 
  * Eex - singlet exciton binding energy 
  * gex - singlet exciton degeneracy 
	gamma	= 0.25	# [1]
	l_diff	= 1.0000e-03	# [cm]
	tau	= 1.0000e-07	# [s]
	tau_trap	= 1.0000e-08	# [s]
	ex_cXsection	= 1.0000e-08 ,	1.0000e-08	# [cm^2]
	ex_dXsection	= 1.0000e-08	# [cm^2]
	N_diss	= 1.0000e+10	# [1/cm^2]
	vth	= 1.0000e+07	# [cm/s]
	vel	= 1.0000e+08	# [cm/s]
	Eex	= 0.015	# [eV]
	gex	= 4	# [1]
	vth_car	= 1.0000e+03 ,	1.0000e+03	# [cm/s]
}


NBTI {
  * The two-stage NBTI model involves 4 states:
  * s1: oxigen vacancy as a precursor
  * s2: positive E' center
  * s3: neutral E' center
  * s4: fixed positive charge with a Pb center
  *
  * The model involves the following transitions:
  * ds1/dt = - s1*k12 + s3*k31
  * ds2/dt = + s1*k12 - s2*(k23 + k24) + s3*k32 + s4*k42
  * ds3/dt = + s2*k23 - s3*(k32 + k31)
  * ds4/dt = + s2*k24 - s4*k42
  * ---------------------------------
  *    Stage One        |   Stage Two
  * 
  * s1 ----k12----> s2 ----k24----> s4
  *                    <---k42-----
  *  ^            | ^   |
  *  |           k23|   |
  * k31           | |   |
  *  |            |k32  |
  *  |            v |   |
  *  |                  |
  *   ----------- s3    |
  *                     |
  * ---------------------------------
  *
  * k12 = eE1 + hC1
  * k23 = eC2 + hE2
  * k32 = eE2 + hC2
  * k31 = nu1*exp( -EA/kT )
  * k24 = nu2*exp( -(ED - gamma*F)/kT )*Theta(C-r)
  * k42 = nu2*exp( -(ED + dED + gamma*F)/kT )*Theta(C-r)
  *
  * where
  * eE1 = eXsec*eVth*NC*exp( - H(EC-E1)/kT + Theta(eFc)*(F/eFc)^eRho - EB/kT )
  * hC1 = hXsec*hVth*p *exp( - H(EV-E1)/kT + Theta(hFc)*(F/hFc)^hRho - EB/kT )
  * eC2 = eXsec*eVth*n *exp( - H(E2-EC)/kT )
  * eE2 = eXsec*eVth*NC*exp( - H(EC-E2)/kT )
  * hC2 = hXsec*hVth*p *exp( - H(EV-E2)/kT )
  * hE2 = hXsec*hVth*NV*exp( - H(E2-EV)/kT )
  * H(x) = x*Theta(x) with Theta(x) the unit step function
	gamma	= 7.4000e-08	# [cm*eV/V]
	nu1	= 1.0000e+13	# [1/s]
	nu2	= 5.1100e+15	# [1/s]
  * E1: trap level of precursor relative to the valence band edge
  * E2: trap level of E' center relative to the valence band edge
  * E4: trap level of Pb center relative to the valence band edge
  * EA: barrier energy for k31
  * EB: barrier energy for k12
  * ED: barrier energy for k24 and k42
  *
  * E1, E2, E4, EA, EB, ED, and r are independent random variables, and
  * each sample has distinct set of values
  *
  * E1, E2, E4, EA, and EB follow the uniform distribution,
  * and you need to specify their minimum and maximum values:
	E1	= -1.1400e+00 ,	-3.1000e-01	# [eV]
	E2	= 0.01 ,	0.3	# [eV]
	E4	= 0.01 ,	0.5	# [eV]
	EA	= 0.01 ,	1.15	# [eV]
	EB	= 0.01 ,	1.15	# [eV]
  *
  * ED follows the Fermi-Derivative distribution, and you need to specify its
  * average and standard deviation:
	ED	= 1.46 ,	0.44	# [eV]
  *
  * dED: additional barrier energy for k42
	dED	= 0.0000e+00	# [eV]
  *
  * r follows the uniform distribution between 0 and 1, and C represents a
  * fraction of samples allowed to undergo the transition k24 and k42:
	C	= 0.12	# [1]
  *
  * Following quantities have separate electron and hole values:
	Xsec	= 1.0800e-15 ,	1.2400e-14	# [cm^2]
	Vth	= 1.5000e+07 ,	1.2000e+07	# [cm/s]
	Fc	= -1.0000e+00 ,	2.8300e+06	# [V/cm]
	Rho	= 2 ,	2	# [1]
  *
  * References:
  * [1] T. Grasser, B. Kaczer, W. Goes, T. Aichinger, P. Hehenerger,
  *     and M. Nelhiebel, A Two-Stage Model for Negative Bias
  *     Temperature Instability, IRPS 2009, pp. 33-44.
  * [2] W. Goes, T. Grasser, M. Karner, and B. Kaczer, A Model for
  *     Switching Traps in Amorphous Oxides, SISPAD 2009, pp. 159-162.
}


SHEDistribution {
  * rho: mass density of crystal
  * epsilon: Relative Permittivity of the semiconductor
  * eps_ins: Relative Permittivity of the insulator
	rho	= 2.329	# [g/cm^3]
	epsilon	= 11.7	# [1]
	eps_ins	= 2.15	# [1]
  * Following quantities have separate electron and hole values
  *   m_s: Semiconductor conductivity effective mass,
  *   m_dos: Semiconductor DOS effective mass,
  *   alpha: Non-parabolicity factor
  *   g: Band degeneracy
  *   A: Prefactor of the gate current density
  *   m_ins: Insulator effective mass
  *   E_barrier: Height of barrier between semiconductor and insulator
  *   Lins: Mean free path in the insulator
  *   Lsem: Mean free path in the high energy limit (used for relaxation time approximation)
  *   tau0: Relaxation time in the low energy limit (used for relaxation time approximation)
  *   mumax: Phonon-limited mobility at 300 K that will be used to
  *   adjust acoustic phonon scattering rate when AdjustACPhononScattering
  *   option is turned on. By default, AdjustACPhononScattering option
  *   is turned off
  *   dac, vsl, and cl are for inelastic intravalley acoustic phonon scattering model
  *   Dac_cl: Acoustic deformation potential/sound velocity for elastic acoustic phonon scattering model
  *   Dop: Deformation potential for optical phonons
  *   HbarOmega: Optical phonon energy
  *   swv0: Offset of the square wave vector for impurity scattering
  *   alloy_potential: Alloy scattering potential
  *   When MobilityScattering is turned-on,
  *   an additional elastic surface roughness scattering process is introduced where
  *   the input parameter is the correlation length of the roughness lsr
  *   Two different formulas are available for the Impact ionization model
  *   which is chosen by ii_formula
  *   ii_formula = 1
  *   ii_rate(E) = ii_rate1*((E - ii_energy1)/eV)^ii_exponent1 : ii_energy1 < E < ii_energy3
  *              = ii_rate2*((E - ii_energy2)/eV)^ii_exponent2 : ii_energy3 < E
  *
  *   ii_formula = 2
  *   ii_rate(E) = ii_rate1*Step(E - ii_energy1)*((E - ii_energy1)/eV)^ii_exponent1
  *              + ii_rate2*Step(E - ii_energy2)*((E - ii_energy2)/eV)^ii_exponent2
  *              + ii_rate3*Step(E - ii_energy3)*((E - ii_energy3)/eV)^ii_exponent3
  *   The impact ionization parameters for electrons are from
  *     C. Jungemann and B. Meinerzhagen,
  *     Hierarchical Device Simulation, The Monte-Carlo Perspective
  *   The impact ionization parameters for holes are from
  *     T. Kunikiyo, et al.,
  *     Journal of Applied Physics, vol. 79, pp. 7718-7725
  *
	m_s	= 0.26 ,	0.26	# [m0]
	m_dos	= 0.328 ,	0.689	# [m0]
	alpha	= 0.5 ,	0.669	# [1/eV]
	g	= 6 ,	1	# [1]
	A	= 1 ,	1	# [1]
	m_ins	= 0.5 ,	0.77	# [m0]
	E_barrier	= 3.1 ,	4.73	# [eV]
	Lins	= 2.0000e-07 ,	2.0000e-07	# [cm]
	Lsem	= 5.0000e-06 ,	1.0000e-06	# [cm]
	tau0	= 1.0000e-12 ,	1.0000e-12	# [s]
	mumax	= 1.4300e+03 ,	4.8000e+02	# [cm^2*V^-1*s^-1]
	dac	= 7.73 ,	5.03	# [eV]
	vsl	= 9.0000e+05 ,	9.0000e+05	# [cm/s]
	cl	= 2.0000e-03 ,	2.0000e-03	# [cm^2/s]
	Dac_cl	= 1.0270e-05 ,	6.2900e-06	# [eV*s/cm]
	Dop	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[1][1]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[1][2]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[1][3]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[1][4]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[2][2]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[2][3]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[2][4]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[3][3]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[3][4]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	Dop[4][4]	= 1.2500e+09 ,	8.7000e+08	# [eV/cm]
	HbarOmega	= 0.06 ,	0.0633	# [eV]
	swv0	= 0.0000e+00 ,	0.0000e+00	# [cm^-2]
	alloy_potential	= 0.75 ,	0.7	# [eV]
	lsr	= 1.2000e-07 ,	1.2000e-07	# [cm]
	ii_formula	= 1 ,	1	# [1]
	ii_rate1	= 1.4900e+11 ,	0.0000e+00	# [1/s]
	ii_rate2	= 1.1300e+12 ,	1.1400e+12	# [1/s]
	ii_rate3	= 0.0000e+00 ,	0.0000e+00	# [1/s]
	ii_energy1	= 1.128 ,	1.128	# [eV]
	ii_energy2	= 1.572 ,	1.49	# [eV]
	ii_energy3	= 1.75 ,	1.49	# [eV]
	ii_exponent1	= 3 ,	0.0000e+00	# [1]
	ii_exponent2	= 2 ,	3.4	# [1]
	ii_exponent3	= 0.0000e+00 ,	0.0000e+00	# [1]
  * Following tables are defined in order to fit impurity scattering
  * for majority and minority doping from 10^15 /cm^3 to 10^20 /cm^3
  * with the row index i representing the doping 10^(15 + i/4) /cm^3
  * See, for example, C. Jungemann and B. Meinerzhagen,
  * Hierarchical Device Simulation, The Monte-Carlo Perspective
  * When AdjustImpurityScattering option is turned on, these parameters
  * are neglected.
  *    efit(i) = majority minority : Electron fitting parameters
  *    hfit(i) = majority minority : Hole fitting parameters
	 efit( 0)	=	1.20698	 2.63089
	 efit( 1)	=	1.26585	 2.61522
	 efit( 2)	=	1.35031	 2.62123
	 efit( 3)	=	1.45972	 2.64571
	 efit( 4)	=	1.59727	 2.68504
	 efit( 5)	=	1.7681	 2.73218
	 efit( 6)	=	1.97625	 2.7758
	 efit( 7)	=	2.22278	 2.80091
	 efit( 8)	=	2.50474	 2.79066
	 efit( 9)	=	2.81348	 2.72938
	 efit(10)	=	3.13088	 2.60729
	 efit(11)	=	3.4262	 2.42644
	 efit(12)	=	3.66329	 2.2049
	 efit(13)	=	3.8209	 1.9745
	 efit(14)	=	3.91451	 1.77291
	 efit(15)	=	4.00744	 1.63637
	 efit(16)	=	4.2118	 1.5994
	 efit(17)	=	4.69302	 1.70363
	 efit(18)	=	5.69842	 2.01596
	 efit(19)	=	7.63117	 2.65859
	 efit(20)	=	11.1923	 3.85825
	 hfit( 0)	=	2.36872	 3.84998
	 hfit( 1)	=	2.47647	 3.82989
	 hfit( 2)	=	2.65631	 3.8773
	 hfit( 3)	=	2.91784	 3.98847
	 hfit( 4)	=	3.28127	 4.16424
	 hfit( 5)	=	3.77842	 4.40187
	 hfit( 6)	=	4.44356	 4.68485
	 hfit( 7)	=	5.2981	 4.97515
	 hfit( 8)	=	6.33175	 5.21189
	 hfit( 9)	=	7.48564	 5.32107
	 hfit(10)	=	8.64257	 5.23752
	 hfit(11)	=	9.62681	 4.932
	 hfit(12)	=	10.228	 4.42987
	 hfit(13)	=	10.2758	 3.80695
	 hfit(14)	=	9.74236	 3.16136
	 hfit(15)	=	8.78324	 2.57856
	 hfit(16)	=	7.66672	 2.11166
	 hfit(17)	=	6.65698	 1.78292
	 hfit(18)	=	5.94642	 1.59808
	 hfit(19)	=	5.66599	 1.56334
	 hfit(20)	=	5.94556	 1.70207
}

AlphaParticle
{ * Generation by an alpha particle with energy E:
  * G = 1/sqrt(2 pi s^2) exp( -1/2 ((t-tm)/s)^2) * 
  *      scale exp[-1/2 ( (v^2+w^2)/wt^2 )] * 
  *       { c1 exp[alpha u] + c2 exp[ -1/2 ( (u-alpha1)/alpha2 )^2 ] }
  * if u<alpha1+alpha3; G=0 else.
  * with alpha1 = a0 + a1 E + a2 E^2, c1 = exp[alpha*(alpha1[10MeV]-alpha1[E])]
  * scale from generated e-h pairs =  E/Ep
	wt	= 1.0000e-05	# [cm]
	c2	= 1.4	# [1]
	alpha	= 90	# [1/cm]
	a0	= -1.0330e-04	# [cm]
	a1	= 2.7000e-10	# [cm/eV]
	a2	= 4.3300e-17	# [cm/eV^2]
	alpha2	= 5.5000e-04	# [cm]
	alpha3	= 2.0000e-04	# [cm]
	Ep	= 3.6	# [eV]
	s	= 2.0000e-12	# [s]
}


**************************  Generation by a Heavy Ion  **************************************
* The temporal distribution is a Gaussian Function                                          *
* The radial spatial distrbution can be a exponential, a gaussian function or give by table *
* The spatial distribution along the path is coming from a table                            *
* G = LET(l)*R(r)*T(t)                                                                      *
* LET(l) = a1 + a2*l + a3 exp(a4*l) + k'*[c1*(c2 + c3*l)^(c4) + Lf(l)]                      *
* with Lf(l) = { Lf1, Lf2, Lf3, ...}                                                        *
* "Lfi" are the Lf values for each length "lengthi"                                     *
* if Radial_Exponential_Distribution;                                                       *
*         R(r) = exp[-(r/wt)]                                                               *
*       case 3D (unit pC/um) : k' = k / (2*pi*wt^2)                                         *
*       case 2D (unit pC/um) : k' = k / (2*e*wt)                                            *
*          if unit = Pairs/cm^3 => k' = k                                                   *
* if Radial_Gaussian_Distribution;                                                          *
*         R(r)= exp[-(r/wt)^2]                                                              *
*       case 3D (unit pC/um) : k' = k / (pi*wt^2)                                           *
*       case 2D (unit pC/um) : k' = k / (e*wt*sqrt(pi))                                     *
*          if unit = Pairs/cm^3 => k' = k                                                   *
* with wt(l) = { wt1,  wt2,  wt3 ...}                                                       *
* "wti" are the wt values for each length "lengthi"                                     *
* e = 1 um                                                                                  *
* See the manual for more details.                                                          *
HeavyIon 
{
	s_hi	= 2.0000e-12	# [s]
	a_1	= 0.0000e+00	# [carriers/cm^3]
	a_2	= 0.0000e+00	# [carriers/cm^3/cm]
	a_3	= 0.0000e+00	# [carriers/cm^3]
	a_4	= 0.0000e+00	# [1/um]
	k_hi	= 1	# [1]
	c_1	= 0.0000e+00	# [carriers/cm^3 or pC/um]
	c_2	= 0.0000e+00	# [1]
	c_3	= 1	# [1/cm]
	c_4	= 0.0000e+00	# [1]
}

DirectTunnelling
{ * eps_ins:   insulator dielectricity,
  * E_F_M:     metal Fermi energy,
  * m_M:       metal effective mass,
  * m_ins:     insulator effective mass,
  * E_i:       energy nodes for pseudo barrier,
  * m_s:       semiconductor effective mass,
  * m_dos:     semiconductor DOS effective mass,
  * E_barrier: height of barrier between semiconductor and oxide,
  * See the manual for more details.
	eps_ins	= 2.13	# [1]
	E_F_M	= 11.7	# [eV]
	m_M	= 1	# [m0]
	m_ins	= 0.5 ,	0.77	# [m0]
	E0	= 0.0000e+00 ,	0.0000e+00	# [eV]
	E1	= 0.0000e+00 ,	0.0000e+00	# [eV]
	E2	= 0.0000e+00 ,	0.0000e+00	# [eV]
	m_s	= 0.19 ,	0.16	# [m0]
	m_dos	= 0.32 ,	0.0000e+00	# [m0]
	E_barrier	= 3.15 ,	4.73	# [eV]
}

RadiativeRecombination * coefficients:
{ * R_Radiative = C * (T/Tpar)^alpha * (n p - ni_eff^2)
  * C    
  * alpha 
	C	= 0.0000e+00	# [cm^3/s]
	alpha	= 0.0000e+00	# []
}

LuckyModel
{ * Ig = J*p1*p2*p3/eLsemR - Electron gate current density,
  *      p1 = 0.25*(Eeff*eLsem/B)*exp (-B/Eeff/eLsem),
  *           B = eBar0-eBL12*Eox^1/2-eBL23*Eox^2/3+Vox,
  *      p2 = exp (-y/eLsem),
  *      p3 = exp (-x0/eLins),
  * where eBar0 is zero field Barrier height for electrons,
  *       eBL12 is Barrier Lowering coefficient due to the image potetial,
  *       eBL23 is Barrier Lowering coefficient due to the tunneling,
  *       eLsem is the mean free path in semiconductor,
  *       eLsemR is the redirection mean free path in semiconductor,
  *       eLins is the mean free path in insulator.
	eBar0	= 3.1	# [eV]
	eBL12	= 2.6000e-04	# [(V*cm)^1/2]
	eBL23	= 3.0000e-05	# [(V*cm^2)^1/3]
	eLsem	= 8.9000e-07	# [cm]
	eLsemR	= 6.2000e-06	# [cm]
	eLins	= 3.2000e-07	# [cm]
  * the same for holes
	hBar0	= 4.7	# [eV]
	hBL12	= 2.6000e-04	# [(V*cm)^1/2]
	hBL23	= 3.0000e-05	# [(V*cm^2)^1/3]
	hLsem	= 1.0000e-07	# [cm]
	hLsemR	= 6.2000e-06	# [cm]
	hLins	= 3.2000e-07	# [cm]
	eps_ins	= 3.1	# [1]
	Prepel	= 1	# [1]
	Pvertical	= 1	# [1]
	Ptotal	= 0.0000e+00	# [1]
  * See the manual for more details.
}

FiegnaModel
{ * Ig = eA*n(x)*p1*p2 - Electron gate current density,
  *      p1 = INTEGRAL[E^1.5*exp(-eChi*E^3/Eeff^1.5)dE] from B to +Infinity,
  *           B = eBar0-eBL12*Eox^1/2-eBL23*Eox^2/3+Vox,
  *      p2 = exp (-x0/eLins),
  * where eBar0 is zero field Barrier height for electrons,
  *       eBL12 is Barrier Lowering coefficient due to the image potetial,
  *       eBL23 is Barrier Lowering coefficient due to the tunneling,
  *       eChi is a constant of the high-energy distribution function,
  *       eA is a fitting constant of Fiegna's model,
  *       eLins is the mean free path in insulator.
	eBar0	= 3.1	# [eV]
	eBL12	= 2.6000e-04	# [(V*cm)^1/2]
	eBL23	= 1.5000e-05	# [(V*cm^2)^1/3]
	eChi	= 1.3000e+08	# [(V/cm)^1.5/eV^1.5]
	eA	= 4.8700e+04	# [cm/s/eV^2.5]
	eLins	= 3.2000e-07	# [cm]
  * the same for holes
	hBar0	= 4.7	# [eV]
	hBL12	= 2.6000e-04	# [(V*cm)^1/2]
	hBL23	= 1.5000e-05	# [(V*cm^2)^1/3]
	hChi	= 1.3000e+08	# [(V/cm)^1.5/eV^1.5]
	hA	= 4.8700e+04	# [cm/s/eV^2.5]
	hLins	= 3.2000e-07	# [cm]
	eps_ins	= 3.1	# [1]
	Prepel	= 1	# [1]
	Ptotal	= 0.0000e+00	# [1]
  * See the manual for more details.
}

FowlerModel
{ * Ig = A*Eox*Eox*exp(-B/Eox) - Fowler-Nordheim gate current density,
  *      For writing: A = Aw, B = Bw,
  *      For erasing: A = Ae, B = Be, Ielectron = Gm * Ig, Ihole = (Gm-1) * Ig,
  * where A, B are physical Fowler-Nordheim constants,
  *       Gm is a multiplication factor for erasing regime.
	Aw	= 1.2300e-06	# [A/V^2]
	Bw	= 2.3700e+08	# [V/cm]
	Ae	= 1.8700e-07	# [A/V^2]
	Be	= 1.8800e+08	# [V/cm]
	Gm	= 1	# [1]
  * See the manual for more details.
}

VanDortQMModel
{ * dEg = Fit*(13/9)*(epsSi/(4kT))^1/3*(En-EcritQC)^2/3 - QM bandgap shift at inversion surafce,
  * F(d) = 2*exp(-(d/dRef)^2)/(1+exp(-2*(d/dRef)^2)) - interface distance function,
  * where En - magnitude of electric field normal to interface,
  *       d - distance from interface,
  *       Fit=eFit - vanDort's fitting parameter for electrons,
  *       Fit=hFit - vanDort's fitting parameter for holes,
  *       EcritQC=eEcritQC - fitting parameter - critical normal 
  *            electric  field for conduction band correction,
  *       EcritQC=hEcritQC - fitting parameter - critical normal 
  *            electric field for valence band correction,
  *       dRef - reference distance from interface.
	eFit	= 2.4000e-08	# [eV*cm]
	hFit	= 1.8000e-08	# [eV*cm]
	eEcritQC	= 1.0000e+05	# [V/cm]
	hEcritQC	= 1.0000e+05	# [V/cm]
	dRef	= 2.5000e-06	# [cm]
  * See the manual for more details.
}

MLDAQMModel
{ * eLambda:  electron thermal wavelength at T=300K
  * hLambda:  hole thermal wavelength at T=300K
	eLambda	= 2.3500e-07	# [cm]
	hLambda	= 2.5000e-07	# [cm]
	ekpDOSfactor	= 1	# [1]
	hkpDOSfactor	= 0.4	# [1]
}

Hallscattering
{ ************************** Magnetic Field: ************************
  * mu_n(B) = rn * mu_n;  mu_p(B) = rp * mu_p
  *******************************************************************
	rn	= 1.15	# [1]
	rp	= -7.0000e-01	# [1]
}

MonopolarGRNoise
{
 *--------------------------------------------------------------------*
 *      K = |J_n|^2/n * (4 e_alpha e_tau)/(1 + omega^2 e_tau^2)       *
 *--------------------------------------------------------------------*
 * with J_n electron current density, n electron density.               *
 * Corresponding expression for holes                                 *
 *--------------------------------------------------------------------*
	e_alpha	= 1	# [1]
	h_alpha	= 1	# [1]
	e_tau	= 1.0000e-07	# [s]
	h_tau	= 1.0000e-07	# [s]
}

FlickerGRNoise
{
 *--------------------------------------------------------------------*
 *      K = |J_n|^2/n * (2 e_alpha_H)/(pi f ln(e_tau1/e_tau0))        *
 *            * ( arctan(omega e_tau1) - arctan (omega e_tau0) )      *
 *--------------------------------------------------------------------*
 * with J_n electron current density, n electron density,             *
 *   f frequency, omega = 2 pi f .                                    *
 * Corresponding expression for holes                                 *
 *--------------------------------------------------------------------*
	e_alpha_H	= 2.0000e-03	# [1]
	h_alpha_H	= 2.0000e-03	# [1]
	e_tau0	= 1.0000e-06	# [s]
	h_tau0	= 1.0000e-06	# [s]
	e_tau1	= 3.0000e-04	# [s]
	h_tau1	= 3.0000e-04	# [s]
}

BarrierLowering
{ * dB = a1 * ( (E/E0)^p1 - (Eeq/E0)^p1_eq ) + 
  *      a2 * ( (E/E0)^p2 - (Eeq/E0)^p2_eq ), 
  * where E is the electric field [V/cm], 
  *       Eeq is the electric field at equilibrium (zero bias), 
  *       E0 = 1 V/cm. 
	a1	= 2.6000e-04	# [eV]
	p1	= 0.5	# [1]
	p1_eq	= 0.5	# [1]
	a2	= 0.0000e+00	# [eV]
	p2	= 1	# [1]
	p2_eq	= 1	# [1]
	eta	= 1	# [1]
  * or 
  * dB_e = aa1_e * (Abs(E_norm)/E0)^pp1_e + aa2_e * (Abs(E_norm)/E0)^pp2_e 
  * dB_h = aa1_h * (Abs(E_norm)/E0)^pp1_h + aa2_h * (Abs(E_norm)/E0)^pp2_h 
  * where E_norm is the normal electric field [V/cm]. 
	aa1	= 2.6000e-04 ,	2.6000e-04	# [eV]
	pp1	= 0.5 ,	0.5	# [1]
	aa2	= 0.0000e+00 ,	0.0000e+00	# [eV]
	pp2	= 1 ,	1	# [1]
}

Traps
{ 
  *     G is degeneracy factor 
	G	= 1 ,	1	# [1]
	Xsec	= 1.0000e-15 ,	1.0000e-15	# [cm^2]
	a1	= 0.0000e+00 ,	0.0000e+00	# [1]
	p1	= 1 ,	1	# [1]
	a2	= 0.0000e+00 ,	0.0000e+00	# [1]
	p2	= 1 ,	1	# [1]
	p0	= 1 ,	1	# [1]

  *     VthFormula=1: Vth(T) = Vth*(T/300)^1/2 
  *     VthFormula=2: Vth(T) = (3*k*T/m_300)^1/2, 
  *                            m_300 is DOS mass calculated at T=300 
	VthFormula	= 1 ,	1	# [1]
	Vth	= 2.0420e+07 ,	1.5626e+07	# [cm/s]
	Jcoef	= 0.0000e+00 ,	0.0000e+00	# [1]

  *     Tunneling to traps is determined by the interaction volume
  *     TrapVolume, the Huang-Rhys factor, and the Phonon energy.
	TrapVolume	= 0.0000e+00	# [um^3]
	HuangRhys	= 0.0000e+00	# [1]
	PhononEnergy	= 0.0000e+00	# [eV]
	alpha	= 1	# [1]

  *     T2T parameters
	T2T_Rcutoff	= 3	# [cm]
	T2T_Wopt	= 3	# [eV]
	T2T_WT	= 1.5	# [eV]
	T2T_m	= 0.5	# [1]


  *     Constant emission rate term
	ConstEmissionRate	= 0.0000e+00 ,	0.0000e+00	# [1/s]

}

RSSAbsorption
{ * K. Rajkanan, R. Singh, and J. Shewchun, 
  * Absorption Coefficient of Silicon for Solar Cell Calculations 
  * Solid-State Electronics 1979 Vol 22. pp793-795 
	Egone0	= 1.1557	# [eV]
	Egtwo0	= 2.5	# [eV]
	Egd0	= 3.2	# [eV]
	Ep1	= 0.01827	# [eV]
	Ep2	= 0.05773	# [eV]
	C1	= 5.5	# [1]
	C2	= 4	# [1]
	A1	= 3.2310e+02	# [cm^-1 eV-2]
	A2	= 7.2370e+03	# [cm^-1 eV-2]
	Ad	= 1.0520e+06	# [cm^-1 eV-2]
	RssBeta	= 7.0210e-04	# [eV/K]
	RssGamma	= 1.1080e+03	# [K]
}

Absorption
{ * Formula = 1:
  * A = A1*exp((phE-E1)/E2),     for phE < E1 
  *   = A1 + A2*((phE-E1)/E2)^P, for phE >= E1 
  * Formula = 2:
  * A = A0*exp((phE-phE0)*ST),              for phE < phE0 
  *   = AT*(2*ST*(phE-E0-(LN-0.5)/ST))^0.5, for phE >= phE0 
  * where 
  *      phE is a photon energy, 
  *      LN = log(AT/A0), 
  *      ST = S/(T+T0), T is a temperature, 
  *      phE0 = E0 + LN/ST. 

	Formula	= 1	# [1]
  * Formula = 1:
	A1	= 1.0000e+04	# [cm-1]
	A2	= 100	# [cm-1]
	E1	= 1.12	# [eV]
	E2	= 0.025	# [eV]
	P	= 0.5	# [1]
}

MultiValley
{ * Arbitrary number of electron and hole valleys can be defined. 
  * Electron density is written as: n=Nc*sum{d_i*F1/2((Ef-Ec-dEc_i)/kT)}, 
  * where dEc_i is energy shift, d_i is DOS factor (defined by valley masses 
  * and degeneracy) of valley i. To specify one valley the energy shift 
  * in respect to band edge, degeneracy, non parabolicity, effective masses, 
  * and valley orientation should be defined. The interface quantization mass
  * (for MLDA model) will be compute automatically (using valley inverse mass 
  * tensor and interface orientation). If the quantization mass is specified, 
  * then it'll be independent of the interface orientation.
	eValley"Delta1"(1,0.0000e+00,0.0000e+00)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	eValley"Delta2"(0.0000e+00,1,0.0000e+00)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	eValley"Delta3"(0.0000e+00,0.0000e+00,1)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	hValley"LH"(m=0.16 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(m=0.49 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
}

LatticeParameters
{ * Crystal system, elasticity, and deformation potential are defined.
  * X and Y vectors define the simulation coordinate system relative to the
  * crystal orientation system. Also there is an option to represent the crystal
  * system relative to the simulation one. In this case a keyword CrystalAxis 
  * has to be in this section and X and Y vectors will represent [100] and [010]
  * axis of the crystal system in the simulation one.
  * Additional notes: 1 Pa = 10 dyn/cm^2; tensile stress/strain is positive. 
  *  
  * S[i][j] - elasticity modulus; i,j = 1,2,...6 and j>=i.
  * CrystalSystem is symmetry, used ONLY to define the elasticity matrics.
  *   Cubic (CrystalSystem=0): S[1][1],S[1][2],S[4][4]
  *   Hexagonal (CrystalSystem=1): S[1][1],S[1][2],S[1][3],S[3][3],S[4][4]
  * 
	X	= (1, 0.0000e+00, 0.0000e+00) #[1]
	Y	= (0.0000e+00, 1, 0.0000e+00) #[1]
	S[1][1]	= 0.77	# [1e-12 cm^2/din]
	S[1][2]	= -2.1000e-01	# [1e-12 cm^2/din]
	S[4][4]	= 1.25	# [1e-12 cm^2/din]
	CrystalSystem	= 0	# [1]

  * Deformation potentials of 2 k.p model for electron delta-valleys 
	xis	= 7	# [eV]
	dbs	= 0.53	# [eV]
	xiu	= 9.16	# [eV]
	xid	= 0.77	# [eV]
	Mkp	= 1.2	# [1]

  * Deformation potentials of 6 k.p model for hole bands
	adp	= 2.1	# [eV]
	bdp	= -2.3300e+00	# [eV]
	ddp	= -4.7500e+00	# [eV]
	dso	= 0.044	# [eV]

  * Luttinger parameters
	gamma_1	= 4.27	# [1]
	gamma_2	= 0.315	# [1]
	gamma_3	= 1.4576	# [1]

  * Deformation potentials and energy (in reference to delta-valley) for L-valleys 
	xiu_l	= 11.5	# [eV]
	xid_l	= -6.5800e+00	# [eV]
	e_l	= 1.1	# [eV]

  * Deformation potentials and energy (in reference to delta-valley) for Gamma-valley 
	xid_gamma	= -7.0000e+00	# [eV]
	e_gamma	= 2.3	# [eV]
}

StressMobility
{ * Stress-induced electron channel mobility model.
  * The model is based on 2 band k.p theory for electron bands and 
  * intervalley/intravelly scattering model with acoustic and optical phonons.
	Ephonon	= 0.06	# [eV]
	beta	= 1.22	# [1]
	beta_mlda	= (1.5, 1.5, 1.5) #[1]
	Nref	= 3.0000e+19	# [cm^-3]
	alpha	= 0.65	# [1]
	Dop	= 1.2500e+09	# [eV/cm]
	Dac_cl	= 1.0270e-05	# [eVs/cm]
  * 
  * Stress-induced change of delta2 electron mass proposed by TU Vienna.
  * The model is based on 2 band k.p theory for electron bands,
  * k.p parameters of the model are defined in LatticeParameters section. 
  * me_l0 and me_t0 are unstressed longitudinal and transverse effective masses:
	me_l0	= 0.914	# [1]
	me_t0	= 0.196	# [1]
  * 
  * Relaxed effective masses of electrons in L-valleys:
	me_l0_l	= 1.69	# [1]
	me_t0_l	= 0.13	# [1]
  * 
  * Relaxed effective mass of electrons in Gamma-valley:
	me0_gamma	= 0.4	# [1]
  * 
  * Stress-induced hole channel mobility model.
  * The model is based on 6 band k.p hole bands and MLDA channel quantization,
  * k.p parameters of the model are defined in LatticeParameters section. 
	Ephonon_h	= 0.0612	# [eV]
	Dop_h	= 7.4700e+08	# [eV/cm]
	Dac_cl_h	= 7.5100e-06	# [eVs/cm]
	beta_h	= 1.0000e+10	# [1]
	beta_mlda_h	= (6.5, 1.2, 2.5) #[1]
	Nref_h	= 3.0000e+19	# [cm^-3]
	alpha_h	= 0.85	# [1]
  * 
  * Stress-induced hole mobility model is proposed by Intel:
  * the hole band structure in 100 plane is described by two ellipsoids directed in 
  * 110 and -110 directions, the multiplication factor of hole mobility in 110 direction
  * is the following:
  *             fh_110 = (f_110/mh_l0+f_'110/mh_t'110)/(0.5/mh_l0+0.5/mh_t0),
  * where:
  *   f_110 = 1/(1+exp(delta/kT), f_'110 = 1/(1+exp(-delta/kT) - occupation of
  *           the ellipsoids if just two (ne) considered in the hole band
  *   mh_l0 is the hole longitudinal mass in the ellipsoid at no stress
  *   mh_t0 is the hole transverse mass in the ellipsoid at no stress
  *   delta is stress-induced energy split between the ellipsoids
  * 
  *   delta = d1*s
  *   mh_t110 = mh_t0/(1-st1*s+st2*s^2+bt1*b+bt2*b^2)
  *   mh_t'110 = mh_t0/(1+st1*s+st2*s^2+bt1*b+bt2*b^2)
  *      (s is shear and b is biaxial components of the stress)
  * 
  * Modification of the Intel model:
  *   1) considered three 100 plans (6 ellipsoids)
  *   2) ne is number of ellipsoids in the occupation functions fh*
  *   3) considered mass in 100 direction: mh_t100 = mh_t0/(1+btt*b)
	mh_l0	= 0.48	# [1]
	mh_t0	= 0.15	# [1]
	d1	= -6.0000e-11	# [eV/Pa]
	st1	= -9.4426e-10	# [1/Pa]
	st2	= 4.3066e-19	# [1/Pa^2]
	bt1	= -1.0086e-10	# [1/Pa]
	bt2	= 6.5886e-21	# [1/Pa^2]
	btt	= 1.2000e-10	# [1/Pa]
	ne	= 2	# [1]
}

Piezoresistance
{ * The piezoresistance Tensor and Factor models compute FirstOrder or SecondOrder
  * changes to mobility based on the piezoresistance effect.

  * The FirstOrder model uses the following set of piezoresistance coefficients.
  * According to Kanda's model the piezoresistance coefficients are split between
  * a constant part and a part that can vary with doping:
	p11var 	= -1.0260e-09 ,	1.5000e-11	# [1/Pa]
	p12var 	= 5.3400e-10 ,	1.5000e-11	# [1/Pa]
	p44var 	= -1.3600e-10 ,	1.1000e-09	# [1/Pa]
	p11con 	= 0.0000e+00 ,	5.1000e-11	# [1/Pa]
	p12con 	= 0.0000e+00 ,	-2.6000e-11	# [1/Pa]
	p44con 	= 0.0000e+00 ,	2.8000e-10	# [1/Pa]

  * The SecondOrder model uses the following set of piezoresistance coefficients.
  * Note that the SecondOrder model uses its own set of 1st order coefficients and
  * that no splitting between constant and variable parts is used:
	p11 	= -1.1000e-09 ,	0.0000e+00	# [1/Pa]
	p12 	= 4.5000e-10 ,	2.0000e-11	# [1/Pa]
	p44 	= 2.5000e-10 ,	1.1900e-09	# [1/Pa]
	p111	= 6.6000e-19 ,	-4.5000e-19	# [1/Pa^2]
	p112	= -5.5000e-20 ,	2.8000e-19	# [1/Pa^2]
	p122	= -2.2000e-20 ,	-2.5000e-19	# [1/Pa^2]
	p123	= 8.8000e-19 ,	2.0000e-20	# [1/Pa^2]
	p144	= 1.0000e-20 ,	-3.3000e-19	# [1/Pa^2]
	p166	= -6.9000e-19 ,	6.6000e-19	# [1/Pa^2]
	p661	= 6.0000e-21 ,	-3.1000e-19	# [1/Pa^2]
	p456	= 2.0000e-20 ,	-3.0000e-19	# [1/Pa^2]
	p441	= 2.0000e-20 ,	0.0000e+00	# [1/Pa^2]

  * The stress dependent mobility enhancement limits set lower and upper limits
  * for the mobility enhancement factor calculated with any of the stress
  * dependent mobility models. The lower limit is used to prevent negative
  * mobility. The upper limit is used to prevent an unrealistic enhancement.
	MinStressFactor 	= 1.0000e-05 ,	1.0000e-05	# [1]
	MaxStressFactor 	= 10 ,	10	# [1]
}


}

Material = "SiliconCarbide" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 9.66	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 9.66	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 3.11	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.11	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 4.55	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 4.55	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Ionization
{ 
	E_As_0  	= 0.1	# [eV]
	alpha_As	= 3.1000e-08	# [eV cm]
	g_As    	= 2	# [1]
	Xsec_As	= 1.0000e-12	# [cm^2]

	E_P_0   	= 0.1	# [eV]
	alpha_P 	= 3.1000e-08	# [eV cm]
	g_P     	= 2	# [1]
	Xsec_P     	= 1.0000e-12	# [cm^2]

	E_Sb_0  	= 0.1	# [eV]
	alpha_Sb	= 3.1000e-08	# [eV cm]
	g_Sb    	= 2	# [1]
	Xsec_Sb    	= 1.0000e-12	# [cm^2]

	E_B_0   	= 0.2	# [eV]
	alpha_B 	= 3.1000e-08	# [eV cm]
	g_B     	= 4	# [1]
	Xsec_B     	= 1.0000e-12	# [cm^2]

	E_Al_0   	= 0.2	# [eV]
	alpha_Al 	= 3.1000e-08	# [eV cm]
	g_Al     	= 4	# [1]
	Xsec_Al     	= 1.0000e-12	# [cm^2]

	E_In_0  	= 0.2	# [eV]
	alpha_In	= 3.1000e-08	# [eV cm]
	g_In    	= 4	# [1]
	Xsec_In    	= 1.0000e-12	# [cm^2]

	E_N_0	= 0.1	# [eV]
	alpha_N 	= 3.1000e-08	# [eV cm]
	g_N	= 2	# [1]
	Xsec_N	= 1.0000e-12	# [cm^2]

	E_NDopant_0	= 0.1	# [eV]
	alpha_NDopant 	= 3.1000e-08	# [eV cm]
	g_NDopant	= 2	# [1]
	Xsec_NDopant	= 1.0000e-12	# [cm^2]

	E_PDopant_0	= 0.2	# [eV]
	alpha_PDopant 	= 3.1000e-08	# [eV cm]
	g_PDopant	= 4	# [1]
	Xsec_PDopant	= 1.0000e-12	# [cm^2]

	NdCrit  	= 1.0000e+22	# [cm-3]
	NaCrit  	= 1.0000e+22	# [cm-3]
}

Bandgap
{ * Eg = Eg0 + dEg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * dEg0(<bgn_model_name>) is a band gap correction term.  It is used together with
  * an appropriate BGN model, if this BGN model is chosen in Physics section
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Chi0	= 4.05	# [eV]
	Bgn2Chi	= 0.5	# [1]
	Eg0	= 3.1	# [eV]
	dEg0(Bennett)	= 0.0000e+00	# [eV]
	dEg0(Slotboom)	= 0.0000e+00	# [eV]
	dEg0(OldSlotboom)	= 0.0000e+00	# [eV]
	dEg0(delAlamo)	= 0.0000e+00	# [eV]
	alpha	= 3.3000e-04	# [eV K^-1]
	beta	= 0.0000e+00	# [K]
	alpha2	= 0.0000e+00	# [eV K^-1]
	beta2	= 0.0000e+00	# [K]
	EgMin	= -1.0000e+01	# [eV]
	dEgMin	= 0.0000e+00	# [eV]
	Tpar	= 0.0000e+00	# [K]
}


OldSlotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
	Ebgn	= 9.0000e-03	# [eV]
	Nref	= 1.0000e+17	# [cm^(-3)]
	C	= 0.5	# [1]
}


Slotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
	Ebgn	= 6.9200e-03	# [eV]
	Nref	= 1.3000e+17	# [cm^(-3)]
	C	= 0.5	# [1]
}

delAlamo
{ * deltaEg = dEg0 + Ebgn  ln(N/Nref) 
  * dEg0 is defined in BandGap section 
	Ebgn	= 0.0187	# [eV]
	Nref	= 7.0000e+17	# [cm^(-3)]
}

Bennett
{ * deltaEg = dEg0 + Ebgn (ln(N/Nref))^2
  * dEg0 is defined in BandGap section 
	Ebgn	= 6.8400e-03	# [eV]
	Nref	= 3.1620e+18	# [cm^(-3)]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
	a	= 0.0625	# [1]
	ml	= 1.5	# [1]
	mm	= 0.0000e+00	# [1]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
	a	= 1	# [1]
	b	= 0	# [K^-1]
	c	= 0	# [K^-2]
	d	= 0	# [K^-3]
	e	= 0	# [K^-4]
	f	= 0	# [K^-1]
	g	= 0	# [K^-2]
	h	= 0	# [K^-3]
	i	= 0	# [K^-4]
	mm	= 0	# [1]
}

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 3.8000e+02 ,	70	# [cm^2/(Vs)]
	Exponent	= 3 ,	3	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
	mumax	= 3.8000e+02 ,	70	# [cm^2/(Vs)]
	Exponent	= 3 ,	3	# [1]
	mutunnel	= 0.05 ,	0.05	# [cm^2/(Vs)]
}

DopingDependence:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 1 ,	1	# [1]
  * If formula=1, model suggested by Masetti et al. is used:
  * mu_dop = mumin1 exp(-Pc/N) + (mu_const - mumin2)/(1+(N/Cr)^alpha)
  *                             - mu1/(1+(Cs/N)^beta)
  * with mu_const from ConstantMobility
	mumin1	= 20 ,	5	# [cm^2/Vs]
	mumin2	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	mu1	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Pc	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	Cr	= 4.5000e+17 ,	1.0000e+19	# [cm^3]
	Cs	= 3.4300e+20 ,	6.1000e+20	# [cm^3]
	alpha	= 0.45 ,	0.5	# [1]
	beta	= 2 ,	2	# [1]
}

DopingDependence_aniso:
{
  * For doping dependent mobility model three formulas
  * can be used. Formula1 is based on Masetti et al. approximation.
  * Formula2 uses approximation, suggested by Arora.
	formula	= 1 ,	1	# [1]
  * If formula=1, model suggested by Masetti et al. is used:
  * mu_dop = mumin1 exp(-Pc/N) + (mu_const - mumin2)/(1+(N/Cr)^alpha)
  *                             - mu1/(1+(Cs/N)^beta)
  * with mu_const from ConstantMobility
	mumin1	= 20 ,	5	# [cm^2/Vs]
	mumin2	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	mu1	= 0.0000e+00 ,	0.0000e+00	# [cm^2/Vs]
	Pc	= 0.0000e+00 ,	0.0000e+00	# [cm^3]
	Cr	= 4.5000e+17 ,	1.0000e+19	# [cm^3]
	Cs	= 3.4300e+20 ,	6.1000e+20	# [cm^3]
	alpha	= 0.45 ,	0.5	# [1]
	beta	= 2 ,	2	# [1]
}

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 2.0000e+07 ,	2.0000e+07	# [1]
	vsatexp	= 0.5 ,	0.5	# [1]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
	beta0	= 2 ,	2	# [1]
	betaexp	= 0.0000e+00 ,	0.0000e+00	# [1]
	alpha	= 0.0000e+00 ,	0.0000e+00	# [1]

  * Smoothing parameter for HydroHighField Caughey-Thomas model:
  * if Tl < Tc < (1+K_dT)*Tl, then smoothing between low field mobility
  * and HydroHighField mobility is used.
	K_dT	= 0.2 ,	0.2	# [1]
  * Transferred-Electron Effect:
  * mu_highfield = (mu_lowfield+(vsat/E)*(E/E0_TrEf)^4)/(1+(E/E0_TrEf)^4)
	E0_TrEf	= 4.0000e+03 ,	4.0000e+03	# [1]
	Ksmooth_TrEf	= 1 ,	1	# [1]

 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
	vsat0	= 2.0000e+07 ,	2.0000e+07	# [1]
	vsatexp	= 0.5 ,	0.5	# [1]
}

PooleFrenkel
{ * TrapXsection = Xsec0*(1+Gpf) 
  * Gpf = (1+(a-1)*exp(a))/a^2-0.5 
  * where 
  *       a = (1/kT)*(q^3*F/pi/e0/epsPF)^0.5, 
  *       F is the electric field. 
	epsPF	= 9.66 ,	9.66	# [1]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 1.4686e+06 ,	5.5222e+06	# [1/cm]
	a(high)	= 1.4686e+06 ,	5.5222e+06	# [1/cm]
	b(low)	= 1.2075e+07 ,	1.2724e+07	# [V/cm]
	b(high)	= 1.2075e+07 ,	1.2724e+07	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 1.0000e+03 ,	1.0000e+03	# [eV]
	beta(low)	= 1.20307 ,	1.37797	# [1]
	beta(high)	= 1.20307 ,	1.37797	# [1]
	lambda	= 2.9900e-07 ,	3.2500e-07	# [cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
	a(low)	= 1.4686e+06 ,	5.5222e+06	# [1/cm]
	a(high)	= 1.4686e+06 ,	5.5222e+06	# [1/cm]
	b(low)	= 1.2075e+07 ,	1.2724e+07	# [V/cm]
	b(high)	= 1.2075e+07 ,	1.2724e+07	# [V/cm]
	E0	= 4.0000e+05 ,	4.0000e+05	# [V/cm]
	hbarOmega	= 1.0000e+03 ,	1.0000e+03	# [eV]
	beta(low)	= 1.20307 ,	1.37797	# [1]
	beta(high)	= 1.20307 ,	1.37797	# [1]
	lambda	= 2.9900e-07 ,	3.2500e-07	# [cm]
}

Hatakeyama * Impact ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = a gamma exp(-b gamma/F)
  *      gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
	a_0001	= 1.7600e+08 ,	3.4100e+08	# [1/cm]
	a_1120	= 2.1000e+07 ,	2.9600e+07	# [1/cm]
	b_0001	= 3.3000e+07 ,	2.5000e+07	# [V/cm]
	b_1120	= 1.7000e+07 ,	1.6000e+07	# [V/cm]
	hbarOmega	= 0.19 ,	0.19	# [eV]
	theta	= 1 ,	1	# [1]
}


}

Material = "SiliconGermanium" {
*  Mole dependent material: SiliconGermanium (x=0) = Silicon
*  Mole dependent material: SiliconGermanium (x=1) = Germanium

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 11.7	# [1]
	epsilon(1)	= 15.8	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 11.7	# [1]
	epsilon(1)	= 15.8	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	refractiveindex(0)	= 3.45	# [1]
	refractiveindex(1)	= 1	# [1]
	alpha(0)	= 2.0000e-04	# [1/K]
	alpha(1)	= 2.0000e-04	# [1/K]
	CarrDepCoeff(0)	= 1	# [1]
	CarrDepCoeff(1)	= 1	# [1]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0(0)	= 3.45	# [1]
	n_0(1)	= 1	# [1]
	k_0(0)	= 0.0000e+00	# [1]
	k_0(1)	= 0.0000e+00	# [1]
	Cn_lambda(0)	= 0.0000e+00	# [um^-1]
	Cn_lambda(1)	= 0.0000e+00	# [um^-1]
	Dn_lambda(0)	= 0.0000e+00	# [um^-2]
	Dn_lambda(1)	= 0.0000e+00	# [um^-2]
	Ck_lambda(0)	= 0.0000e+00	# [um^-1]
	Ck_lambda(1)	= 0.0000e+00	# [um^-1]
	Dk_lambda(0)	= 0.0000e+00	# [um^-2]
	Dk_lambda(1)	= 0.0000e+00	# [um^-2]
	Cn_temp(0)	= 2.0000e-04	# [K^-1]
	Cn_temp(1)	= 2.0000e-04	# [K^-1]
	Cn_carr(0)	= 1	# [1]
	Cn_carr(1)	= 1	# [1]
	Cn_gain(0)	= 0.0000e+00	# [1]
	Cn_gain(1)	= 0.0000e+00	# [1]
	Npar(0)	= 1.0000e+18	# [cm^-3]
	Npar(1)	= 1.0000e+18	# [cm^-3]
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	Ck_carr(0)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Ck_carr(1)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Gamma_k_carr(0)	= 1,	1	#[1]
	Gamma_k_carr(1)	= 1,	1	#[1]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	cv(0)	= 1.63	# [J/(Kcm^3)]
	cv(1)	= 1.67	# [J/(Kcm^3)]
	cv_b(0)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_b(1)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_c(0)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_c(1)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_d(0)	= 0.0000e+00	# [J/(K^4*cm^3)]
	cv_d(1)	= 0.0000e+00	# [J/(K^4*cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 0.6465	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 0.6	# [(K cm)/W]
	B(1/kappa(1))	= -2.0000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 0.6465	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 0.6	# [(K cm)/W]
	B(1/kappa(1))	= -2.0000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

Bandgap
{ * Eg = Eg0 + dEg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * dEg0(<bgn_model_name>) is a band gap correction term.  It is used together with
  * an appropriate BGN model, if this BGN model is chosen in Physics section
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	dEg0(Bennett)	= 0.0000e+00	# [eV]
	dEg0(Slotboom)	= -4.7950e-03	# [eV]
	dEg0(OldSlotboom)	= -1.5950e-02	# [eV]
	dEg0(delAlamo)	= -1.4070e-02	# [eV]
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter dEg0(OldSlotboom):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(OldSlotboom)(0)	= -1.5950e-02	# [eV]
	Xmax(1)	= 0.245	# [1]
	dEg0(OldSlotboom)(1)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(1))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	dEg0(OldSlotboom)(2)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(2))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	dEg0(OldSlotboom)(3)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(3))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	dEg0(OldSlotboom)(4)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(4))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	dEg0(OldSlotboom)(5)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(5))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	dEg0(OldSlotboom)(6)	= 0.0000e+00	# [eV]
	B(dEg0(OldSlotboom)(6))	= 0.0000e+00	# [eV]
	C(dEg0(OldSlotboom)(6))	= 0.0000e+00	# [eV]

	* parameter dEg0(Slotboom):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(Slotboom)(0)	= -4.7950e-03	# [eV]
	Xmax(1)	= 0.245	# [1]
	dEg0(Slotboom)(1)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(1))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	dEg0(Slotboom)(2)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(2))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	dEg0(Slotboom)(3)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(3))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	dEg0(Slotboom)(4)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(4))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	dEg0(Slotboom)(5)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(5))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	dEg0(Slotboom)(6)	= 0.0000e+00	# [eV]
	B(dEg0(Slotboom)(6))	= 0.0000e+00	# [eV]
	C(dEg0(Slotboom)(6))	= 0.0000e+00	# [eV]

	* parameter dEg0(delAlamo):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(delAlamo)(0)	= -1.4070e-02	# [eV]
	Xmax(1)	= 0.245	# [1]
	dEg0(delAlamo)(1)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(1))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	dEg0(delAlamo)(2)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(2))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	dEg0(delAlamo)(3)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(3))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	dEg0(delAlamo)(4)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(4))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	dEg0(delAlamo)(5)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(5))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	dEg0(delAlamo)(6)	= 0.0000e+00	# [eV]
	B(dEg0(delAlamo)(6))	= 0.0000e+00	# [eV]
	C(dEg0(delAlamo)(6))	= 0.0000e+00	# [eV]

	* parameter dEg0(Bennett):
	Xmax(0)	= 0.0000e+00	# [1]
	dEg0(Bennett)(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.245	# [1]
	dEg0(Bennett)(1)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(1))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	dEg0(Bennett)(2)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(2))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	dEg0(Bennett)(3)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(3))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	dEg0(Bennett)(4)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(4))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	dEg0(Bennett)(5)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(5))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	dEg0(Bennett)(6)	= 0.0000e+00	# [eV]
	B(dEg0(Bennett)(6))	= 0.0000e+00	# [eV]
	C(dEg0(Bennett)(6))	= 0.0000e+00	# [eV]

	* parameter Eg0:
	Xmax(0)	= 0.0000e+00	# [1]
	Eg0(0)	= 1.12416	# [eV]
	Xmax(1)	= 0.245	# [1]
	Eg0(1)	= 0.945	# [eV]
	B(Eg0(1))	= 0.0000e+00	# [eV]
	C(Eg0(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	Eg0(2)	= 0.87	# [eV]
	B(Eg0(2))	= 0.0000e+00	# [eV]
	C(Eg0(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	Eg0(3)	= 0.78	# [eV]
	B(Eg0(3))	= 0.0000e+00	# [eV]
	C(Eg0(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	Eg0(4)	= 0.72	# [eV]
	B(Eg0(4))	= 0.0000e+00	# [eV]
	C(Eg0(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	Eg0(5)	= 0.69	# [eV]
	B(Eg0(5))	= 0.0000e+00	# [eV]
	C(Eg0(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	Eg0(6)	= 0.67	# [eV]
	B(Eg0(6))	= 0.0000e+00	# [eV]
	C(Eg0(6))	= 0.0000e+00	# [eV]

	* parameter Bgn2Chi:
	Xmax(0)	= 0.0000e+00	# [1]
	Bgn2Chi(0)	= 0.5	# [1]
	Xmax(1)	= 0.245	# [1]
	Bgn2Chi(1)	= 0.5	# [1]
	B(Bgn2Chi(1))	= 0.0000e+00	# [1]
	C(Bgn2Chi(1))	= 0.0000e+00	# [1]
	Xmax(2)	= 0.35	# [1]
	Bgn2Chi(2)	= 0.5	# [1]
	B(Bgn2Chi(2))	= 0.0000e+00	# [1]
	C(Bgn2Chi(2))	= 0.0000e+00	# [1]
	Xmax(3)	= 0.5	# [1]
	Bgn2Chi(3)	= 0.5	# [1]
	B(Bgn2Chi(3))	= 0.0000e+00	# [1]
	C(Bgn2Chi(3))	= 0.0000e+00	# [1]
	Xmax(4)	= 0.6	# [1]
	Bgn2Chi(4)	= 0.5	# [1]
	B(Bgn2Chi(4))	= 0.0000e+00	# [1]
	C(Bgn2Chi(4))	= 0.0000e+00	# [1]
	Xmax(5)	= 0.735	# [1]
	Bgn2Chi(5)	= 0.5	# [1]
	B(Bgn2Chi(5))	= 0.0000e+00	# [1]
	C(Bgn2Chi(5))	= 0.0000e+00	# [1]
	Xmax(6)	= 1	# [1]
	Bgn2Chi(6)	= 0.5	# [1]
	B(Bgn2Chi(6))	= 0.0000e+00	# [1]
	C(Bgn2Chi(6))	= 0.0000e+00	# [1]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha(0)	= 4.7300e-04	# [eV/K]
	Xmax(1)	= 0.245	# [1]
	alpha(1)	= 4.7398e-04	# [eV/K]
	B(alpha(1))	= 0.0000e+00	# [eV/K]
	C(alpha(1))	= 0.0000e+00	# [eV/K]
	Xmax(2)	= 0.35	# [1]
	alpha(2)	= 4.7440e-04	# [eV/K]
	B(alpha(2))	= 0.0000e+00	# [eV/K]
	C(alpha(2))	= 0.0000e+00	# [eV/K]
	Xmax(3)	= 0.5	# [1]
	alpha(3)	= 4.7500e-04	# [eV/K]
	B(alpha(3))	= 0.0000e+00	# [eV/K]
	C(alpha(3))	= 0.0000e+00	# [eV/K]
	Xmax(4)	= 0.6	# [1]
	alpha(4)	= 4.7540e-04	# [eV/K]
	B(alpha(4))	= 0.0000e+00	# [eV/K]
	C(alpha(4))	= 0.0000e+00	# [eV/K]
	Xmax(5)	= 0.735	# [1]
	alpha(5)	= 4.7594e-04	# [eV/K]
	B(alpha(5))	= 0.0000e+00	# [eV/K]
	C(alpha(5))	= 0.0000e+00	# [eV/K]
	Xmax(6)	= 1	# [1]
	alpha(6)	= 4.7700e-04	# [eV/K]
	B(alpha(6))	= 0.0000e+00	# [eV/K]
	C(alpha(6))	= 0.0000e+00	# [eV/K]

	* parameter alpha2:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha2(0)	= 0.0000e+00	# [eV/K]
	Xmax(1)	= 0.245	# [1]
	alpha2(1)	= 0.0000e+00	# [eV/K]
	B(alpha2(1))	= 0.0000e+00	# [eV/K]
	C(alpha2(1))	= 0.0000e+00	# [eV/K]
	Xmax(2)	= 0.35	# [1]
	alpha2(2)	= 0.0000e+00	# [eV/K]
	B(alpha2(2))	= 0.0000e+00	# [eV/K]
	C(alpha2(2))	= 0.0000e+00	# [eV/K]
	Xmax(3)	= 0.5	# [1]
	alpha2(3)	= 0.0000e+00	# [eV/K]
	B(alpha2(3))	= 0.0000e+00	# [eV/K]
	C(alpha2(3))	= 0.0000e+00	# [eV/K]
	Xmax(4)	= 0.6	# [1]
	alpha2(4)	= 0.0000e+00	# [eV/K]
	B(alpha2(4))	= 0.0000e+00	# [eV/K]
	C(alpha2(4))	= 0.0000e+00	# [eV/K]
	Xmax(5)	= 0.735	# [1]
	alpha2(5)	= 0.0000e+00	# [eV/K]
	B(alpha2(5))	= 0.0000e+00	# [eV/K]
	C(alpha2(5))	= 0.0000e+00	# [eV/K]
	Xmax(6)	= 1	# [1]
	alpha2(6)	= 0.0000e+00	# [eV/K]
	B(alpha2(6))	= 0.0000e+00	# [eV/K]
	C(alpha2(6))	= 0.0000e+00	# [eV/K]

	* parameter beta:
	Xmax(0)	= 0.0000e+00	# [1]
	beta(0)	= 6.3600e+02	# [K]
	Xmax(1)	= 0.245	# [1]
	beta(1)	= 5.3775e+02	# [K]
	B(beta(1))	= 0.0000e+00	# [K]
	C(beta(1))	= 0.0000e+00	# [K]
	Xmax(2)	= 0.35	# [1]
	beta(2)	= 4.9565e+02	# [K]
	B(beta(2))	= 0.0000e+00	# [K]
	C(beta(2))	= 0.0000e+00	# [K]
	Xmax(3)	= 0.5	# [1]
	beta(3)	= 4.3550e+02	# [K]
	B(beta(3))	= 0.0000e+00	# [K]
	C(beta(3))	= 0.0000e+00	# [K]
	Xmax(4)	= 0.6	# [1]
	beta(4)	= 3.9540e+02	# [K]
	B(beta(4))	= 0.0000e+00	# [K]
	C(beta(4))	= 0.0000e+00	# [K]
	Xmax(5)	= 0.735	# [1]
	beta(5)	= 3.4126e+02	# [K]
	B(beta(5))	= 0.0000e+00	# [K]
	C(beta(5))	= 0.0000e+00	# [K]
	Xmax(6)	= 1	# [1]
	beta(6)	= 2.3500e+02	# [K]
	B(beta(6))	= 0.0000e+00	# [K]
	C(beta(6))	= 0.0000e+00	# [K]

	* parameter beta2:
	Xmax(0)	= 0.0000e+00	# [1]
	beta2(0)	= 0.0000e+00	# [K]
	Xmax(1)	= 0.245	# [1]
	beta2(1)	= 0.0000e+00	# [K]
	B(beta2(1))	= 0.0000e+00	# [K]
	C(beta2(1))	= 0.0000e+00	# [K]
	Xmax(2)	= 0.35	# [1]
	beta2(2)	= 0.0000e+00	# [K]
	B(beta2(2))	= 0.0000e+00	# [K]
	C(beta2(2))	= 0.0000e+00	# [K]
	Xmax(3)	= 0.5	# [1]
	beta2(3)	= 0.0000e+00	# [K]
	B(beta2(3))	= 0.0000e+00	# [K]
	C(beta2(3))	= 0.0000e+00	# [K]
	Xmax(4)	= 0.6	# [1]
	beta2(4)	= 0.0000e+00	# [K]
	B(beta2(4))	= 0.0000e+00	# [K]
	C(beta2(4))	= 0.0000e+00	# [K]
	Xmax(5)	= 0.735	# [1]
	beta2(5)	= 0.0000e+00	# [K]
	B(beta2(5))	= 0.0000e+00	# [K]
	C(beta2(5))	= 0.0000e+00	# [K]
	Xmax(6)	= 1	# [1]
	beta2(6)	= 0.0000e+00	# [K]
	B(beta2(6))	= 0.0000e+00	# [K]
	C(beta2(6))	= 0.0000e+00	# [K]

	* parameter Chi0:
	Xmax(0)	= 0.0000e+00	# [1]
	Chi0(0)	= 4.07274	# [eV]
	Xmax(1)	= 0.245	# [1]
	Chi0(1)	= 4.05492	# [eV]
	B(Chi0(1))	= 0.0000e+00	# [eV]
	C(Chi0(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	Chi0(2)	= 4.04728	# [eV]
	B(Chi0(2))	= 0.0000e+00	# [eV]
	C(Chi0(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	Chi0(3)	= 4.03637	# [eV]
	B(Chi0(3))	= 0.0000e+00	# [eV]
	C(Chi0(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	Chi0(4)	= 4.0291	# [eV]
	B(Chi0(4))	= 0.0000e+00	# [eV]
	C(Chi0(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	Chi0(5)	= 4.01928	# [eV]
	B(Chi0(5))	= 0.0000e+00	# [eV]
	C(Chi0(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	Chi0(6)	= 4	# [eV]
	B(Chi0(6))	= 0.0000e+00	# [eV]
	C(Chi0(6))	= 0.0000e+00	# [eV]

	* parameter WorkFunction:
	Xmax(0)	= 0.0000e+00	# [1]
	WorkFunction(0)	= 4.25	# [eV]
	Xmax(1)	= 0.245	# [1]
	WorkFunction(1)	= 4.25	# [eV]
	B(WorkFunction(1))	= 0.0000e+00	# [eV]
	C(WorkFunction(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	WorkFunction(2)	= 4.25	# [eV]
	B(WorkFunction(2))	= 0.0000e+00	# [eV]
	C(WorkFunction(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	WorkFunction(3)	= 4.25	# [eV]
	B(WorkFunction(3))	= 0.0000e+00	# [eV]
	C(WorkFunction(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	WorkFunction(4)	= 4.25	# [eV]
	B(WorkFunction(4))	= 0.0000e+00	# [eV]
	C(WorkFunction(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	WorkFunction(5)	= 4.25	# [eV]
	B(WorkFunction(5))	= 0.0000e+00	# [eV]
	C(WorkFunction(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	WorkFunction(6)	= 4.25	# [eV]
	B(WorkFunction(6))	= 0.0000e+00	# [eV]
	C(WorkFunction(6))	= 0.0000e+00	# [eV]

	* parameter FermiEnergy:
	Xmax(0)	= 0.0000e+00	# [1]
	FermiEnergy(0)	= 11.7	# [eV]
	Xmax(1)	= 0.245	# [1]
	FermiEnergy(1)	= 11.7	# [eV]
	B(FermiEnergy(1))	= 0.0000e+00	# [eV]
	C(FermiEnergy(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	FermiEnergy(2)	= 11.7	# [eV]
	B(FermiEnergy(2))	= 0.0000e+00	# [eV]
	C(FermiEnergy(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	FermiEnergy(3)	= 11.7	# [eV]
	B(FermiEnergy(3))	= 0.0000e+00	# [eV]
	C(FermiEnergy(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	FermiEnergy(4)	= 11.7	# [eV]
	B(FermiEnergy(4))	= 0.0000e+00	# [eV]
	C(FermiEnergy(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	FermiEnergy(5)	= 11.7	# [eV]
	B(FermiEnergy(5))	= 0.0000e+00	# [eV]
	C(FermiEnergy(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	FermiEnergy(6)	= 11.7	# [eV]
	B(FermiEnergy(6))	= 0.0000e+00	# [eV]
	C(FermiEnergy(6))	= 0.0000e+00	# [eV]

	* parameter EgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	EgMin(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.245	# [1]
	EgMin(1)	= 0.0000e+00	# [eV]
	B(EgMin(1))	= 0.0000e+00	# [eV]
	C(EgMin(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	EgMin(2)	= 0.0000e+00	# [eV]
	B(EgMin(2))	= 0.0000e+00	# [eV]
	C(EgMin(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	EgMin(3)	= 0.0000e+00	# [eV]
	B(EgMin(3))	= 0.0000e+00	# [eV]
	C(EgMin(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	EgMin(4)	= 0.0000e+00	# [eV]
	B(EgMin(4))	= 0.0000e+00	# [eV]
	C(EgMin(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	EgMin(5)	= 0.0000e+00	# [eV]
	B(EgMin(5))	= 0.0000e+00	# [eV]
	C(EgMin(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	EgMin(6)	= 0.0000e+00	# [eV]
	B(EgMin(6))	= 0.0000e+00	# [eV]
	C(EgMin(6))	= 0.0000e+00	# [eV]

	* parameter dEgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	dEgMin(0)	= 0.01	# [eV]
	Xmax(1)	= 0.245	# [1]
	dEgMin(1)	= 0.01	# [eV]
	B(dEgMin(1))	= 0.0000e+00	# [eV]
	C(dEgMin(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 0.35	# [1]
	dEgMin(2)	= 0.01	# [eV]
	B(dEgMin(2))	= 0.0000e+00	# [eV]
	C(dEgMin(2))	= 0.0000e+00	# [eV]
	Xmax(3)	= 0.5	# [1]
	dEgMin(3)	= 0.01	# [eV]
	B(dEgMin(3))	= 0.0000e+00	# [eV]
	C(dEgMin(3))	= 0.0000e+00	# [eV]
	Xmax(4)	= 0.6	# [1]
	dEgMin(4)	= 0.01	# [eV]
	B(dEgMin(4))	= 0.0000e+00	# [eV]
	C(dEgMin(4))	= 0.0000e+00	# [eV]
	Xmax(5)	= 0.735	# [1]
	dEgMin(5)	= 0.01	# [eV]
	B(dEgMin(5))	= 0.0000e+00	# [eV]
	C(dEgMin(5))	= 0.0000e+00	# [eV]
	Xmax(6)	= 1	# [1]
	dEgMin(6)	= 0.01	# [eV]
	B(dEgMin(6))	= 0.0000e+00	# [eV]
	C(dEgMin(6))	= 0.0000e+00	# [eV]

}


OldSlotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Ebgn(0)	= 9.0000e-03	# [eV]
	Ebgn(1)	= 9.0000e-03	# [eV]
	Nref(0)	= 1.0000e+17	# [cm^-3]
	Nref(1)	= 1.0000e+17	# [cm^-3]
	C(0)	= 0.5	# [1]
	C(1)	= 0.5	# [1]
}


Slotboom
{ * deltaEg = dEg0 + Ebgn ( ln(N/Nref) + [ (ln(N/Nref))^2 + C]^1/2 )
  * dEg0 is defined in BandGap section 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Ebgn(0)	= 6.9200e-03	# [eV]
	Ebgn(1)	= 6.9200e-03	# [eV]
	Nref(0)	= 1.3000e+17	# [cm^-3]
	Nref(1)	= 1.3000e+17	# [cm^-3]
	C(0)	= 0.5	# [1]
	C(1)	= 0.5	# [1]
}

delAlamo
{ * deltaEg = dEg0 + Ebgn  ln(N/Nref) 
  * dEg0 is defined in BandGap section 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Ebgn(0)	= 0.0187	# [eV]
	Ebgn(1)	= 0.0187	# [eV]
	Nref(0)	= 7.0000e+17	# [cm^-3]
	Nref(1)	= 7.0000e+17	# [cm^-3]
}

Bennett
{ * deltaEg = dEg0 + Ebgn (ln(N/Nref))^2
  * dEg0 is defined in BandGap section 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Ebgn(0)	= 6.8400e-03	# [eV]
	Ebgn(1)	= 6.8400e-03	# [eV]
	Nref(0)	= 3.1620e+18	# [cm^-3]
	Nref(1)	= 3.1620e+18	# [cm^-3]
}

JainRoulston
{ * deltaEg = A_i N^(1/3) + B_i N^(1/4) + C_i N^(1/2) + D_i N^(1/2)
  * where i is n for n-type or p for p-type
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A_n(0)	= 0.0000e+00	# [eV cm]
	A_n(1)	= 0.0000e+00	# [eV cm]
	B_n(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_n(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	A_p(0)	= 0.0000e+00	# [eV cm]
	A_p(1)	= 0.0000e+00	# [eV cm]
	B_p(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_p(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
}


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * me/m0 = [ (6 * mt)^2 *  ml ]^(1/3) + mm
  * mt = a[Eg(0)/Eg(T)] 
  * Nc(T) = 2(2pi*kB/h_Planck^2*me*T)^3/2 = 2.5094e19 ((me/m0)*(T/300))^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.0000e+00	# [1]
	a(1)	= 0.0000e+00	# [1]
	ml(0)	= 0.0000e+00	# [1]
	ml(1)	= 0.0000e+00	# [1]
	mm(0)	= 1.09066	# [1]
	mm(1)	= 0.55	# [1]
	Nc300(0)	= 2.8900e+19	# [cm-3]
	Nc300(1)	= 2.8900e+19	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 1	# [1]
  * Formula1:
  * mh =  m0*{[(a+bT+cT^2+dT^3+eT^4)/(1+fT+gT^2+hT^3+iT^4)]^(2/3) + mm}
  * Nv(T) = 2(2pi*kB/h_Planck^2*mh*T)^3/2 = 2.5094e19 ((mh/m0)*(T/300))^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.0000e+00	# [1]
	a(1)	= 0.0000e+00	# [1]
	b(0)	= 0.0000e+00	# [K^-1]
	b(1)	= 0.0000e+00	# [K^-1]
	c(0)	= 0.0000e+00	# [K^-2]
	c(1)	= 0.0000e+00	# [K^-2]
	d(0)	= 0.0000e+00	# [K^-3]
	d(1)	= 0.0000e+00	# [K^-3]
	e(0)	= 0.0000e+00	# [K^-4]
	e(1)	= 0.0000e+00	# [K^-4]
	f(0)	= 0.0000e+00	# [K^-1]
	f(1)	= 0.0000e+00	# [K^-1]
	g(0)	= 0.0000e+00	# [K^-2]
	g(1)	= 0.0000e+00	# [K^-2]
	h(0)	= 0.0000e+00	# [K^-3]
	h(1)	= 0.0000e+00	# [K^-3]
	i(0)	= 0.0000e+00	# [K^-4]
	i(1)	= 0.0000e+00	# [K^-4]
	mm(0)	= 1.15247	# [1]
	mm(1)	= 0.38	# [1]
	Nv300(0)	= 3.1400e+19	# [cm-3]
	Nv300(1)	= 3.1400e+19	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 1 ,	1	# [1]
  * Formula(hole) 1 parameters:
	A	= 4.22	# [1]
	B	= 0.6084	# [1]
	C	= 23.058	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
}


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 2.5,	2.2	#[1]
	Exponent(1)	= 1.6,	2.3	#[1]
	mumax(0)	= 1.4170e+03,	4.7050e+02	#[cm^2/(Vs)]
	mumax(1)	= 3.9000e+03,	1.9000e+03	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 2.5,	2.2	#[1]
	Exponent(1)	= 1.6,	2.3	#[1]
	mumax(0)	= 1.4170e+03,	4.7050e+02	#[cm^2/(Vs)]
	mumax(1)	= 3.9000e+03,	1.9000e+03	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 1.109,	1.213	#[1]
	beta0(1)	= 1.109,	1.213	#[1]
	betaexp(0)	= 0.66,	0.17	#[1]
	betaexp(1)	= 0.66,	0.17	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0700e+07,	8.3700e+06	#[cm/s]
	vsat0(1)	= 7.4300e+06,	7.4300e+06	#[cm/s]
	vsatexp(0)	= 0.87,	0.52	#[1]
	vsatexp(1)	= 0.87,	0.52	#[1]
	A_vsat(0)	= 1.0700e+07,	1.0700e+07	#[cm/s]
	A_vsat(1)	= 7.4300e+06,	7.4300e+06	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 1 ,	1	# [1]
 * Formula1 for saturation velocity:
 *            vsat = vsat0 (T/T0)^(-Vsatexp)
 * (Parameter Vsat_Formula has to be not equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 1.109,	1.213	#[1]
	beta0(1)	= 1.109,	1.213	#[1]
	betaexp(0)	= 0.66,	0.17	#[1]
	betaexp(1)	= 0.66,	0.17	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0700e+07,	8.3700e+06	#[cm/s]
	vsat0(1)	= 7.4300e+06,	7.4300e+06	#[cm/s]
	vsatexp(0)	= 0.87,	0.52	#[1]
	vsatexp(1)	= 0.87,	0.52	#[1]
	A_vsat(0)	= 1.0700e+07,	1.0700e+07	#[cm/s]
	A_vsat(1)	= 7.4300e+06,	7.4300e+06	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	a(low)(0)	= 7.0300e+05,	1.5820e+06	#[1/cm]
	a(low)(1)	= 8.5500e+06,	2.8000e+06	#[1/cm]
	a(high)(0)	= 7.0300e+05,	6.7100e+05	#[1/cm]
	a(high)(1)	= 8.5500e+06,	2.8000e+06	#[1/cm]
	b(low)(0)	= 1.2310e+06,	2.0360e+06	#[V/cm]
	b(low)(1)	= 1.4200e+06,	1.0000e+06	#[V/cm]
	b(high)(0)	= 1.2310e+06,	1.6930e+06	#[V/cm]
	b(high)(1)	= 1.4200e+06,	1.0000e+06	#[V/cm]
	E0(0)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	E0(1)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	hbarOmega(0)	= 0.063,	0.063	#[eV]
	hbarOmega(1)	= 0.037,	0.037	#[eV]
	beta(low)(0)	= 0.678925,	0.815009	#[1]
	beta(low)(1)	= 1.39057,	0.979274	#[1]
	beta(high)(0)	= 0.678925,	0.677706	#[1]
	beta(high)(1)	= 1.39057,	0.979274	#[1]
	lambda(0)	= 6.2000e-07,	4.5000e-07	#[cm]
	lambda(1)	= 6.5000e-07,	6.5000e-07	#[cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	a(low)(0)	= 7.0300e+05,	1.5820e+06	#[1/cm]
	a(low)(1)	= 8.5500e+06,	2.8000e+06	#[1/cm]
	a(high)(0)	= 7.0300e+05,	6.7100e+05	#[1/cm]
	a(high)(1)	= 8.5500e+06,	2.8000e+06	#[1/cm]
	b(low)(0)	= 1.2310e+06,	2.0360e+06	#[V/cm]
	b(low)(1)	= 1.4200e+06,	1.0000e+06	#[V/cm]
	b(high)(0)	= 1.2310e+06,	1.6930e+06	#[V/cm]
	b(high)(1)	= 1.4200e+06,	1.0000e+06	#[V/cm]
	E0(0)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	E0(1)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	hbarOmega(0)	= 0.063,	0.063	#[eV]
	hbarOmega(1)	= 0.037,	0.037	#[eV]
	beta(low)(0)	= 0.678925,	0.815009	#[1]
	beta(low)(1)	= 1.39057,	0.979274	#[1]
	beta(high)(0)	= 0.678925,	0.677706	#[1]
	beta(high)(1)	= 1.39057,	0.979274	#[1]
	lambda(0)	= 6.2000e-07,	4.5000e-07	#[cm]
	lambda(1)	= 6.5000e-07,	6.5000e-07	#[cm]
}

Band2BandTunneling 
{ * See Sentaurus Device manual `Band-To-Band Tunneling' 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A(0)	= 8.9770e+20	# [1/cm/sec/V^2]
	A(1)	= 8.9770e+20	# [1/cm/sec/V^2]
	B(0)	= 2.1466e+07	# [V/cm/eV^1.5]
	B(1)	= 2.1466e+07	# [V/cm/eV^1.5]
	hbarOmega(0)	= 0.0186	# [eV]
	hbarOmega(1)	= 0.0186	# [eV]

  * Traditional models for the following keywords in input file:
  * Band2Band(E1)  : A1*E*exp(-B1/E)
  * Band2Band(E1_5): A1_5*E^1.5*exp(-B1_5/E)
  * Band2Band(E2)  : A2*E^2*exp(-B2/E)
	A1(0)	= 1.1000e+27	# [1/cm^2/sec/V]
	A1(1)	= 1.1000e+27	# [1/cm^2/sec/V]
	B1(0)	= 2.1300e+07	# [V/cm]
	B1(1)	= 2.1300e+07	# [V/cm]
	A1_5(0)	= 1.9000e+24	# [1/cm^1.5/sec/V^1.5]
	A1_5(1)	= 1.9000e+24	# [1/cm^1.5/sec/V^1.5]
	B1_5(0)	= 2.1900e+07	# [V/cm]
	B1_5(1)	= 2.1900e+07	# [V/cm]
	A2(0)	= 3.5000e+21	# [1/cm/sec/V^2]
	A2(1)	= 3.5000e+21	# [1/cm/sec/V^2]
	B2(0)	= 2.2500e+07	# [V/cm]
	B2(1)	= 2.2500e+07	# [V/cm]

  * Hurkx model for the following keywords in input file:
  * Band2Band(Hurkx)  : -Agen*D*(E/E0)^Pgen*exp(-Bgen*(Eg/Eg300)^1.5/E) if D < 0
  *                     -Arec*D*(E/E0)^Prec*exp(-Brec*(Eg/Eg300)^1.5/E) if D > 0
  *                     D = (n*p-ni^2)/(n+ni)/(p+ni)*(1-|alpha|)+alpha, E0 = 1 V/cm
  *                     So, if alpha = 0, it's original Hurkx model,
  *                         if alpha = -1, it's only generation,
  *                         if alpha = +1, it's only recombination.
	Agen(0)	= 3.5000e+21	# [1/cm^3/sec]
	Agen(1)	= 3.5000e+21	# [1/cm^3/sec]
	Bgen(0)	= 2.2500e+07	# [V/cm]
	Bgen(1)	= 2.2500e+07	# [V/cm]
	Pgen(0)	= 2	# [1]
	Pgen(1)	= 2	# [1]
	Arec(0)	= 3.5000e+21	# [1/cm^3/sec]
	Arec(1)	= 3.5000e+21	# [1/cm^3/sec]
	Brec(0)	= 2.2500e+07	# [V/cm]
	Brec(1)	= 2.2500e+07	# [V/cm]
	Prec(0)	= 2	# [1]
	Prec(1)	= 2	# [1]
	alpha	= 0.0000e+00	# [1]

  * nonlocal B2B models for the following keywords in command file:
  * Band2Band(Model=NonlocalPath) : Nonlocal B2B tunneling with transition process using the tunneling path
  * For the nonlocal B2B process:
  * Apath : Prefactor Ad or Ap in the uniform field limit for the direct or indirect tunneling
  * Bpath : Exponent  Bd or Bp in the uniform field limit for the direct or indirect tunneling
  * Cpath : Factor g*Dop^2/rho for indirect tunneling
  * Dpath : The conduction band offset D
  * Ppath : The phonon energy P
  *         Note that the indirect tunneling process is assumed if P>0, and the direct tunneling process is assumed if P=0
  * Rpath : The ratio mv/mc. If Rpathi=0, it is automatically determined by
  *         mv/mc = (1 + 2*mr)/(1 - 2*mr)
  *         where mr=mc*mv/(mc+mv) is the reduced mass
  * g     : Degeneracy factor
  * m_c   : Effective mass in the conduction band
  * m_v   : Effective mass in the valence band
  * In the uniform field limit, the generation rate can be expressed by
  * G = A * (F/F0)^2   * Exp(-B/F) for   direct tunneling
  *   = A * (F/F0)^2.5 * Exp(-B/F) for indirect tunneling
  * where
  * Ad = g * mr^0.5 * (qF0)^2 / (36 * pi * h_bar^2 *E_T^0.5)
  * Ap = g *(mc*mv)^1.5 * (1+2*N) * (qF0)^2.5 * Dop^2 / (2^7.75 * pi^2.5 * h_bar^2.5 * mr^1.25 * E_T^1.75 * rho * P)
  * Bd = pi    * mr^0.5 * E_T^1.5 / (2 * h_bar * q)
  * Bp = 2^2.5 * mr^0.5 * E_T^1.5 / (3 * h_bar * q)
  * F0 = 1 V/cm, qF0 = 1 eV/cm, E_T = E_G + D
  * For the paramter set (APath, Bpath, Dpath, Ppath, Rpath), the microscopic parameters such as mr, mc, and mv for the nonlocal B2B model are extracted internally.   * For the parameter set (Cpath, g, m_c, m_v), the microscopic parameters are used directly for the tunneling rate computation.
	Apath(0)	= 4.0000e+14	# [1/cm^3/sec]
	Apath(1)	= 9.1000e+16	# [1/cm^3/sec]
	Bpath(0)	= 1.9000e+07	# [V/cm]
	Bpath(1)	= 4.9000e+06	# [V/cm]
	Cpath(0)	= 0.0000e+00	# [J^2*cm/kg]
	Cpath(1)	= 0.0000e+00	# [J^2*cm/kg]
	Dpath(0)	= 0.0000e+00	# [eV]
	Dpath(1)	= 0.0000e+00	# [eV]
	Ppath(0)	= 0.037	# [eV]
	Ppath(1)	= 0.037	# [eV]
	Rpath(0)	= 0.0000e+00	# [1]
	Rpath(1)	= 0.0000e+00	# [1]
	m_c(0)	= 0.0000e+00	# [m0]
	m_c(1)	= 0.0000e+00	# [m0]
	m_v(0)	= 0.0000e+00	# [m0]
	m_v(1)	= 0.0000e+00	# [m0]
	degeneracy	= 0.0000e+00	# [1]
	QuantumPotentialFactor	= 0.0000e+00 ,	0.0000e+00	# [1]
	MaxTunnelLength	= 1.0000e-05	# [cm]

  * min length to interfaces (for traditional & Hurkx models):
	dDist	= 0.0000e+00	# [cm]
  * min potential difference on length dPot/E (for traditional & Hurkx models):
	dPot	= 0.0000e+00	# [V]
  * numeric smoothing
	MinField	= 0.0000e+00	# [V/cm]
	MinGradQF	= 0.0000e+00	# [eV/cm]
	DenCorRef	= 0.0000e+00 ,	0.0000e+00	# [cm^-3]
}


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

DirectTunnelling
{ * eps_ins:   insulator dielectricity,
  * E_F_M:     metal Fermi energy,
  * m_M:       metal effective mass,
  * m_ins:     insulator effective mass,
  * E_i:       energy nodes for pseudo barrier,
  * m_s:       semiconductor effective mass,
  * m_dos:     semiconductor DOS effective mass,
  * E_barrier: height of barrier between semiconductor and oxide,
  * See the manual for more details.
	eps_ins	= 2.13	# [1]
	E_F_M	= 11.7	# [eV]
	m_M	= 1	# [m0]
	m_ins	= 0.5 ,	0.77	# [m0]
	E0	= 0.0000e+00 ,	0.0000e+00	# [eV]
	E1	= 0.0000e+00 ,	0.0000e+00	# [eV]
	E2	= 0.0000e+00 ,	0.0000e+00	# [eV]
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	m_s(0)	= 0.19,	0.16	#[m0]
	m_s(1)	= 0.19,	0.16	#[m0]
	m_dos(0)	= 0.32,	0.0000e+00	#[m0]
	m_dos(1)	= 0.32,	0.0000e+00	#[m0]
	E_barrier(0)	= 3.15,	4.73	#[eV]
	E_barrier(1)	= 3.15,	4.73	#[eV]
}


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

MLDAQMModel
{ * eLambda:  electron thermal wavelength at T=300K
  * hLambda:  hole thermal wavelength at T=300K
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	eLambda(0)	= 2.3500e-07	# [cm]
	eLambda(1)	= 2.3500e-07	# [cm]
	hLambda(0)	= 2.5000e-07	# [cm]
	hLambda(1)	= 2.5000e-07	# [cm]
	ekpDOSfactor(0)	= 1	# [1]
	ekpDOSfactor(1)	= 1	# [1]
	hkpDOSfactor(0)	= 0.4	# [1]
	hkpDOSfactor(1)	= 0.4	# [1]
}

MultiValley
{ * Arbitrary number of electron and hole valleys can be defined. 
  * Electron density is written as: n=Nc*sum{d_i*F1/2((Ef-Ec-dEc_i)/kT)}, 
  * where dEc_i is energy shift, d_i is DOS factor (defined by valley masses 
  * and degeneracy) of valley i. To specify one valley the energy shift 
  * in respect to band edge, degeneracy, non parabolicity, effective masses, 
  * and valley orientation should be defined. The interface quantization mass
  * (for MLDA model) will be compute automatically (using valley inverse mass 
  * tensor and interface orientation). If the quantization mass is specified, 
  * then it'll be independent of the interface orientation.
	eValley"Delta1"(1,0.0000e+00,0.0000e+00)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	eValley"Delta2"(0.0000e+00,1,0.0000e+00)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	eValley"Delta3"(0.0000e+00,0.0000e+00,1)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	eValley"L1"(1,1,1)(ml=1.69 mt=0.13 energy=1.1 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L2"(-1.0000e+00,1,1)(ml=1.69 mt=0.13 energy=1.1 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L3"(1,-1.0000e+00,1)(ml=1.69 mt=0.13 energy=1.1 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L4"(1,1,-1.0000e+00)(ml=1.69 mt=0.13 energy=1.1 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	hValley"LH"(m=0.16 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(m=0.49 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	Xmax(0) = 0.0
	Xmax(1) = 0.85
	eValley"Delta1"(1)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	eValley"Delta2"(1)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	eValley"Delta3"(1)(ml=0.914 mt=0.196 energy=0.0000e+00 alpha=0.5 degeneracy=2 xiu=9.16 xid=0.77) 
	eValley"L1"(1)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L2"(1)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L3"(1)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L4"(1)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	hValley"LH"(1)(m=0.061 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(1)(m=0.31 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	Xmax(2) = 1
	eValley"Delta1"(2)(ml=0.915 mt=0.201 energy=0.19 alpha=0.5 degeneracy=2 xiu=9.42 xid=-5.4000e-01) 
	eValley"Delta2"(2)(ml=0.915 mt=0.201 energy=0.19 alpha=0.5 degeneracy=2 xiu=9.42 xid=-5.4000e-01) 
	eValley"Delta3"(2)(ml=0.915 mt=0.201 energy=0.19 alpha=0.5 degeneracy=2 xiu=9.42 xid=-5.4000e-01) 
	eValley"L1"(2)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L2"(2)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L3"(2)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	eValley"L4"(2)(ml=1.768 mt=0.0967 energy=0.0000e+00 alpha=0.5 degeneracy=1 xiu=11.5 xid=-6.5800e+00) 
	hValley"LH"(2)(m=0.044 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(2)(m=0.28 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
}

LatticeParameters
{ * Crystal system, elasticity, and deformation potential are defined.
  * X and Y vectors define the simulation coordinate system relative to the
  * crystal orientation system. Also there is an option to represent the crystal
  * system relative to the simulation one. In this case a keyword CrystalAxis 
  * has to be in this section and X and Y vectors will represent [100] and [010]
  * axis of the crystal system in the simulation one.
  * Additional notes: 1 Pa = 10 dyn/cm^2; tensile stress/strain is positive. 
  *  
  * S[i][j] - elasticity modulus; i,j = 1,2,...6 and j>=i.
  * CrystalSystem is symmetry, used ONLY to define the elasticity matrics.
  *   Cubic (CrystalSystem=0): S[1][1],S[1][2],S[4][4]
  *   Hexagonal (CrystalSystem=1): S[1][1],S[1][2],S[1][3],S[3][3],S[4][4]
  * 
	X	= (1, 0.0000e+00, 0.0000e+00) #[1]
	Y	= (0.0000e+00, 1, 0.0000e+00) #[1]
	S[1][1]	= 0.77	# [1e-12 cm^2/din]
	S[1][2]	= -2.1000e-01	# [1e-12 cm^2/din]
	S[4][4]	= 1.25	# [1e-12 cm^2/din]
	CrystalSystem	= 0	# [1]

  * Deformation potentials of 2 k.p model for electron delta-valleys 
	xis	= 7	# [eV]
	dbs	= 0.53	# [eV]
	xiu	= 9.16	# [eV]
	xid	= 0.77	# [eV]
	Mkp	= 1.2	# [1]

  * Deformation potentials of 6 k.p model for hole bands
	adp	= 2.1	# [eV]
	bdp	= -2.3300e+00	# [eV]
	ddp	= -4.7500e+00	# [eV]
	dso	= 0.044	# [eV]

  * Luttinger parameters
	gamma_1	= 4.27	# [1]
	gamma_2	= 0.315	# [1]
	gamma_3	= 1.4576	# [1]

  * Deformation potentials and energy (in reference to delta-valley) for L-valleys 
	xiu_l	= 11.5	# [eV]
	xid_l	= -6.5800e+00	# [eV]
	e_l	= 1.1	# [eV]

  * Deformation potentials and energy (in reference to delta-valley) for Gamma-valley 
	xid_gamma	= -7.0000e+00	# [eV]
	e_gamma	= 2.3	# [eV]
  * 
    Xmax(0) = 0.0 
    Xmax(1) = 1.0 
  * 
	S[1][1](1)	= 0.97	# [1e-12 cm^2/din]
	S[1][2](1)	= -2.5000e-01	# [1e-12 cm^2/din]
	S[4][4](1)	= 1.48	# [1e-12 cm^2/din]
  * 
	xis(1)	= 8.07	# [eV]
	dbs(1)	= 0.9	# [eV]
	xiu(1)	= 9.42	# [eV]
	xid(1)	= -5.9000e-01	# [eV]
	Mkp(1)	= 1	# [1]

  * 
	adp(1)	= 2	# [eV]
	bdp(1)	= -2.1600e+00	# [eV]
	ddp(1)	= -6.0600e+00	# [eV]
	dso(1)	= 0.289	# [eV]

  * 
	gamma_1(1)	= 9.56	# [1]
	gamma_2(1)	= 2.77	# [1]
	gamma_3(1)	= 3.91	# [1]

  * 
	xiu_l(1)	= 11.5	# [eV]
	xid_l(1)	= -6.5800e+00	# [eV]
	e_l(1)	= -1.9000e-01	# [eV]

  * 
	xid_gamma(1)	= -7.0000e+00	# [eV]
	e_gamma(1)	= -4.0000e-02	# [eV]
}


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Germanium) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

StressMobility
{ * Stress-induced electron channel mobility model.
  * The model is based on 2 band k.p theory for electron bands and 
  * intervalley/intravelly scattering model with acoustic and optical phonons.
	Ephonon	= 0.06	# [eV]
	beta	= 1.22	# [1]
	beta_mlda	= (1.5, 1.5, 1.5) #[1]
	Nref	= 3.0000e+19	# [cm^-3]
	alpha	= 0.65	# [1]
	Dop	= 1.2500e+09	# [eV/cm]
	Dac_cl	= 1.0270e-05	# [eVs/cm]
  * 
  * Stress-induced change of delta2 electron mass proposed by TU Vienna.
  * The model is based on 2 band k.p theory for electron bands,
  * k.p parameters of the model are defined in LatticeParameters section. 
  * me_l0 and me_t0 are unstressed longitudinal and transverse effective masses:
	me_l0	= 0.914	# [1]
	me_t0	= 0.196	# [1]
  * 
  * Relaxed effective masses of electrons in L-valleys:
	me_l0_l	= 1.69	# [1]
	me_t0_l	= 0.13	# [1]
  * 
  * Relaxed effective mass of electrons in Gamma-valley:
	me0_gamma	= 0.4	# [1]
  * 
  * Stress-induced hole channel mobility model.
  * The model is based on 6 band k.p hole bands and MLDA channel quantization,
  * k.p parameters of the model are defined in LatticeParameters section. 
	Ephonon_h	= 0.0612	# [eV]
	Dop_h	= 7.4700e+08	# [eV/cm]
	Dac_cl_h	= 7.5100e-06	# [eVs/cm]
	beta_h	= 1.0000e+10	# [1]
	beta_mlda_h	= (6.5, 1.2, 2.5) #[1]
	Nref_h	= 3.0000e+19	# [cm^-3]
	alpha_h	= 0.85	# [1]
  * 
  * Stress-induced hole mobility model is proposed by Intel:
  * the hole band structure in 100 plane is described by two ellipsoids directed in 
  * 110 and -110 directions, the multiplication factor of hole mobility in 110 direction
  * is the following:
  *             fh_110 = (f_110/mh_l0+f_'110/mh_t'110)/(0.5/mh_l0+0.5/mh_t0),
  * where:
  *   f_110 = 1/(1+exp(delta/kT), f_'110 = 1/(1+exp(-delta/kT) - occupation of
  *           the ellipsoids if just two (ne) considered in the hole band
  *   mh_l0 is the hole longitudinal mass in the ellipsoid at no stress
  *   mh_t0 is the hole transverse mass in the ellipsoid at no stress
  *   delta is stress-induced energy split between the ellipsoids
  * 
  *   delta = d1*s
  *   mh_t110 = mh_t0/(1-st1*s+st2*s^2+bt1*b+bt2*b^2)
  *   mh_t'110 = mh_t0/(1+st1*s+st2*s^2+bt1*b+bt2*b^2)
  *      (s is shear and b is biaxial components of the stress)
  * 
  * Modification of the Intel model:
  *   1) considered three 100 plans (6 ellipsoids)
  *   2) ne is number of ellipsoids in the occupation functions fh*
  *   3) considered mass in 100 direction: mh_t100 = mh_t0/(1+btt*b)
	mh_l0	= 0.48	# [1]
	mh_t0	= 0.15	# [1]
	d1	= -6.0000e-11	# [eV/Pa]
	st1	= -9.4426e-10	# [1/Pa]
	st2	= 4.3066e-19	# [1/Pa^2]
	bt1	= -1.0086e-10	# [1/Pa]
	bt2	= 6.5886e-21	# [1/Pa^2]
	btt	= 1.2000e-10	# [1/Pa]
	ne	= 2	# [1]
  * 
    Xmax(0) = 0.0 
    Xmax(1) = 1.0 
  * 
	me_l0(1)	= 0.915	# [1]
	me_t0(1)	= 0.201	# [1]
	me_l0_l(1)	= 1.768	# [1]
	me_t0_l(1)	= 0.0967	# [1]
  * 
	me0_gamma(1)	= 0.05	# [1]
  * 
	Ephonon(1)	= 0.03	# [eV]
	beta(1)	= 1.22	# [1]
	beta_mlda(1)	= (1.5, 1.2, 1.5) #[1]
	Nref(1)	= 3.0000e+19	# [cm^-3]
	alpha(1)	= 0.65	# [1]
	Dop(1)	= 1.2000e+09	# [eV/cm]
	Dac_cl(1)	= 1.6700e-05	# [eVs/cm]
  * 
	Ephonon_h(1)	= 0.037	# [eV]
	Dop_h(1)	= 6.0600e+08	# [eV/cm]
	Dac_cl_h(1)	= 9.9600e-06	# [eVs/cm]
	beta_h(1)	= 1.0000e+10	# [1]
	beta_mlda_h(1)	= (3, 0.75, 2.5) #[1]
	Nref_h(1)	= 3.0000e+19	# [cm^-3]
	alpha_h(1)	= 0.85	# [1]
}


}

Material = "Silver" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 0.0000e+00	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.0506	0.906	0.522;
          0.0539	0.98	0.614;
          0.0551	1.029	0.624;
          0.0576	1.104	0.584;
          0.059	1.109	0.561;
          0.062	1.098	0.548;
          0.0653	1.096	0.565;
          0.0729	1.121	0.635;
          0.0775	1.167	0.676;
          0.08	1.202	0.691;
          0.0855	1.281	0.679;
          0.0918	1.322	0.628;
          0.0992	1.315	0.588;
          0.1025	1.308	0.581;
          0.1051	1.304	0.578;
          0.1107	1.293	0.566;
          0.1137	1.28	0.56;
          0.117	1.265	0.56;
          0.1204	1.252	0.564;
          0.124	1.241	0.568;
          0.1278	1.229	0.566;
          0.1348	1.182	0.55;
          0.1378	1.149	0.552;
          0.1409	1.112	0.563;
          0.1442	1.073	0.581;
          0.1476	1.032	0.61;
          0.1512	0.993	0.653;
          0.155	0.962	0.706;
          0.159	0.94	0.77;
          0.1631	0.935	0.832;
          0.1675	0.936	0.892;
          0.1722	0.942	0.951;
          0.1771	0.953	1.01;
          0.1823	0.969	1.07;
          0.1879	0.995	1.13;
          0.1937	1.028	1.18;
          0.1968	1.048	1.21;
          0.2	1.072	1.24;
          0.2033	1.098	1.26;
          0.2066	1.125	1.27;
          0.2138	1.173	1.29;
          0.2214	1.208	1.3;
          0.2296	1.238	1.31;
          0.2384	1.265	1.33;
          0.248	1.298	1.35;
          0.253	1.32	1.35;
          0.2583	1.343	1.35;
          0.2638	1.372	1.35;
          0.2695	1.404	1.33;
          0.2755	1.441	1.31;
          0.2818	1.476	1.26;
          0.2883	1.502	1.19;
          0.2952	1.519	1.08;
          0.2988	1.522	0.992;
          0.3024	1.496	0.882;
          0.3061	1.432	0.766;
          0.31	1.323	0.647;
          0.3115	1.246	0.586;
          0.3139	1.149	0.54;
          0.3155	1.044	0.514;
          0.3179	0.932	0.504;
          0.3195	0.815	0.526;
          0.322	0.708	0.565;
          0.3237	0.616	0.609;
          0.3263	0.526	0.663;
          0.3306	0.371	0.813;
          0.3324	0.321	0.902;
          0.3351	0.294	0.986;
          0.3397	0.259	1.12;
          0.3444	0.238	1.24;
          0.3542	0.209	1.44;
          0.3647	0.2	1.61;
          0.3757	0.198	1.67;
          0.3875	0.192	1.81;
          0.4	0.173	1.95;
          0.4133	0.173	2.11;
          0.4275	0.16	2.26;
          0.4428	0.157	2.4;
          0.4592	0.144	2.56;
          0.4769	0.132	2.72;
          0.4959	0.13	2.88;
          0.5166	0.13	3.07;
          0.5391	0.129	3.25;
          0.5636	0.12	3.45;
          0.5904	0.121	3.66;
          0.6199	0.131	3.88;
          0.6526	0.14	4.15;
          0.6888	0.14	4.44;
          0.7293	0.148	4.74;
          0.7749	0.143	5.09;
          0.8266	0.145	5.5;
          0.8856	0.163	5.95;
          0.9537	0.198	6.43;
          1.033	0.226	6.99;
          1.127	0.251	7.67;
          1.24	0.329	8.49;
          1.265	0.37	7.78;
          1.291	0.38	7.92;
          1.305	0.38	7.95;
          1.319	0.392	8.06;
          1.348	0.401	8.21;
          1.378	0.411	8.37;
          1.409	0.421	8.37;
          1.459	0.44	8.8;
          1.512	0.455	9.08;
          1.55	0.469	9.32;
          1.59	0.485	9.57;
          1.631	0.501	9.84;
          1.675	0.519	10.1;
          1.722	0.537	10.4;
          1.771	0.557	10.7;
          1.823	0.578	11.1;
          1.879	0.6	11.4;
          1.937	0.624	11.8;
          2	0.65	12.2;
          2.066	0.668	12.6;
          2.138	0.729	13;
          2.214	0.774	13.5;
          2.296	0.823	14;
          2.384	0.878	14.5;
          2.48	0.939	15.1;
          2.583	1.007	15.7;
          2.695	1.083	16.4;
          2.818	1.168	17.1;
          2.952	1.265	17.9;
          3.1	1.387	18.8;
          3.263	1.536	19.8;
          3.444	1.71	20.9;
          3.647	1.915	22.1;
          3.875	2.16	23.5;
          4.133	2.446	25.1;
          4.428	2.786	26.9;
          4.769	3.202	29;
          5.166	3.732	31.3;
          5.636	4.425	34;
          6.199	5.355	37;
          6.526	5.96	38.6;
          6.888	6.67	40.4;
          7.293	7.461	42.5;
          7.749	8.376	44.8;
          8.266	9.441	47.1;
          8.856	10.69	49.4;
          9.537	12.21	52.2;
          9.919	13.11	53.7;
          10	13.2	54;
          10.001	13.2	54;
          10.002	13.2	54;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 2.44	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 4.18	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 4.18	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 5.1	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 1.5100e-06	# [ohm*cm]
	TempCoef	= 4.1000e-03	# [1/K]
}


}

Material = "Solder60_40" {

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
	epsilon	= 0.0000e+00	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
	refractiveindex	= 0.0000e+00	# [1]
	alpha	= 2.0000e-04	# [1/K]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
	cv	= 1.57	# [J/(K cm^3)]
	cv_b	= 0.0000e+00	# [J/(K^2 cm^3)]
	cv_c	= 0.0000e+00	# [J/(K^3 cm^3)]
	cv_d	= 0.0000e+00	# [J/(K^4 cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.36	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.36	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


}

Material = "StrainedSilicon" {
*  Mole dependent material: StrainedSilicon (x=0) = Silicon
*  Mole dependent material: StrainedSilicon (x=1) = Silicon

*  Epsilon{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Epsilon_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  refractiveindex{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 3.45	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 3.7100e-18 ,	3.3300e-18	# [cm^2]
	Gamma_k_carr	= 3 ,	3	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


*  LatticeHeatCapacity{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Kappa_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnergyRelaxationTime{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bandgap{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  FreeCarrierAbsorption{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BandstructureParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QWstrain{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  eDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  hDOSMass{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SchroedingerParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ConstantMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  HighFieldDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(Silicon) + (1-x) * P(Silicon)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}

Material = "Tantalum" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 1.2600e-05	# [ohm*cm]
	TempCoef	= 3.5000e-03	# [1/K]
}


}

Material = "TiN" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.192	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.192	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 4.66	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 1.1000e-05	# [ohm*cm]
	TempCoef	= 4.2000e-03	# [1/K]
}


}

Material = "TiSi2" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


Kappa
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.25	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 1:
  * kappa() = kappa + kappa_b * T + kappa_c * T^2 
	kappa	= 0.25	# [W/(K cm)]
	kappa_b	= 0.0000e+00	# [W/(K^2 cm)]
	kappa_c	= 0.0000e+00	# [W/(K^3 cm)]
}

Bandgap
{ * For conductors Band Gap is zero and the following parameters are used:
	WorkFunction	= 4.36	# [eV]
	FermiEnergy	= 11.7	# [eV]
  * for backward compatibility Chi0 could be used to define the work function.
}

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 1.8000e-05	# [ohm*cm]
	TempCoef	= 3.3400e-03	# [1/K]
}


}

Material = "Titanium" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }

Resistivity
{ * Resist(T) = Resist0 * ( 1 + TempCoef * ( T - 273 ) )
	Resist0	= 5.0000e-05	# [ohm*cm]
	TempCoef	= 3.8000e-03	# [1/K]
}


}

Material = "Tungsten" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 1
        TableInterpolation = PositiveSpline, PositiveSpline
        NumericalTable ( 
          0.02638	0.7741	0.195;
          0.02695	0.762	0.205;
          0.02818	0.746	0.245;
          0.02883	0.744	0.274;
          0.02952	0.756	0.304;
          0.03024	0.778	0.319;
          0.031	0.797	0.328;
          0.03179	0.814	0.33;
          0.03263	0.826	0.33;
          0.03351	0.837	0.328;
          0.03444	0.846	0.32;
          0.03542	0.848	0.306;
          0.03594	0.844	0.298;
          0.03647	0.838	0.291;
          0.03701	0.829	0.285;
          0.03757	0.816	0.278;
          0.03815	0.797	0.286;
          0.03875	0.791	0.295;
          0.03936	0.788	0.294;
          0.04	0.778	0.293;
          0.04065	0.765	0.292;
          0.04133	0.75	0.295;
          0.04168	0.742	0.296;
          0.04203	0.733	0.297;
          0.04239	0.724	0.298;
          0.04275	0.712	0.301;
          0.04313	0.7	0.306;
          0.0435	0.69	0.31;
          0.04389	0.679	0.318;
          0.04428	0.671	0.322;
          0.04468	0.656	0.328;
          0.04509	0.643	0.336;
          0.0455	0.631	0.346;
          0.04592	0.619	0.357;
          0.04626	0.61	0.365;
          0.04661	0.6	0.375;
          0.04696	0.591	0.383;
          0.04732	0.58	0.394;
          0.04769	0.571	0.404;
          0.04806	0.56	0.415;
          0.04843	0.548	0.429;
          0.04881	0.537	0.444;
          0.0492	0.528	0.461;
          0.04959	0.521	0.476;
          0.04999	0.511	0.494;
          0.0504	0.503	0.513;
          0.05081	0.497	0.534;
          0.05123	0.491	0.554;
          0.05166	0.487	0.575;
          0.05209	0.483	0.598;
          0.05254	0.484	0.621;
          0.05299	0.486	0.643;
          0.05344	0.49	0.663;
          0.05391	0.494	0.679;
          0.05438	0.494	0.695;
          0.05486	0.493	0.712;
          0.05535	0.492	0.73;
          0.05585	0.491	0.751;
          0.05636	0.491	0.773;
          0.05687	0.492	0.796;
          0.0574	0.496	0.819;
          0.05794	0.499	0.842;
          0.05848	0.503	0.866;
          0.05904	0.508	0.892;
          0.05961	0.517	0.918;
          0.06019	0.525	0.943;
          0.06078	0.537	0.969;
          0.06138	0.549	0.994;
          0.06199	0.563	1.02;
          0.06262	0.579	1.05;
          0.06326	0.599	1.07;
          0.06391	0.621	1.09;
          0.06458	0.642	1.11;
          0.06526	0.665	1.13;
          0.06595	0.688	1.15;
          0.06666	0.712	1.16;
          0.06738	0.738	1.18;
          0.06812	0.766	1.19;
          0.06888	0.796	1.2;
          0.06965	0.822	1.2;
          0.07045	0.847	1.21;
          0.07126	0.874	1.21;
          0.07208	0.9	1.2;
          0.07293	0.922	1.2;
          0.0738	0.944	1.19;
          0.07469	0.959	1.18;
          0.0756	0.973	1.17;
          0.07653	0.98	1.15;
          0.07749	0.981	1.14;
          0.07847	0.976	1.13;
          0.07948	0.966	1.12;
          0.08051	0.951	1.12;
          0.08157	0.933	1.13;
          0.08266	0.917	1.14;
          0.08377	0.904	1.17;
          0.08492	0.9	1.2;
          0.0861	0.901	1.23;
          0.08731	0.906	1.25;
          0.08856	0.913	1.28;
          0.08984	0.923	1.32;
          0.09117	0.941	1.35;
          0.09253	0.962	1.37;
          0.09393	0.984	1.4;
          0.09537	1.01	1.42;
          0.09686	1.04	1.44;
          0.0984	1.07	1.46;
          0.09999	1.1	1.47;
          0.1016	1.13	1.48;
          0.1033	1.16	1.48;
          0.1042	1.18	1.48;
          0.1051	1.2	1.48;
          0.106	1.21	1.48;
          0.1069	1.22	1.48;
          0.1078	1.24	1.47;
          0.1088	1.25	1.46;
          0.1097	1.26	1.45;
          0.1107	1.27	1.44;
          0.1117	1.28	1.43;
          0.1127	1.28	1.42;
          0.1137	1.29	1.41;
          0.1148	1.29	1.39;
          0.1159	1.28	1.38;
          0.117	1.28	1.36;
          0.1181	1.26	1.34;
          0.1192	1.24	1.33;
          0.1204	1.22	1.33;
          0.1216	1.19	1.33;
          0.1228	1.16	1.33;
          0.124	1.13	1.34;
          0.1252	1.11	1.36;
          0.1265	1.09	1.38;
          0.1278	1.07	1.41;
          0.1291	1.05	1.44;
          0.1305	1.04	1.47;
          0.1319	1.03	1.5;
          0.1333	1.03	1.52;
          0.1348	1.02	1.55;
          0.1362	1.02	1.57;
          0.1378	1.01	1.6;
          0.1393	1.02	1.63;
          0.1409	1.01	1.65;
          0.1425	0.999	1.67;
          0.1442	0.986	1.7;
          0.1459	0.973	1.73;
          0.1476	0.956	1.76;
          0.1494	0.943	1.81;
          0.1512	0.935	1.86;
          0.1531	0.935	1.91;
          0.155	0.937	1.95;
          0.1569	0.932	2;
          0.159	0.93	2.06;
          0.161	0.937	2.12;
          0.1631	0.95	2.18;
          0.1653	0.964	2.24;
          0.1675	0.979	2.29;
          0.1698	0.993	2.36;
          0.1722	1.01	2.43;
          0.1746	1.04	2.49;
          0.1771	1.06	2.56;
          0.1797	1.09	2.63;
          0.1823	1.12	2.7;
          0.1851	1.16	2.78;
          0.1879	1.21	2.87;
          0.1907	1.26	2.95;
          0.1937	1.31	3.04;
          0.1968	1.38	3.14;
          0.2	1.47	3.24;
          0.2033	1.58	3.33;
          0.2066	1.7	3.42;
          0.2101	1.83	3.52;
          0.2138	2	3.61;
          0.2175	2.2	3.67;
          0.2214	2.43	3.7;
          0.2254	2.68	3.68;
          0.2296	2.92	3.58;
          0.2339	3.11	3.43;
          0.2384	3.27	3.27;
          0.2431	3.38	3.05;
          0.248	3.4	2.85;
          0.253	3.37	2.68;
          0.2583	3.33	2.57;
          0.2638	3.29	2.48;
          0.2695	3.24	2.41;
          0.2755	3.19	2.35;
          0.2818	3.13	2.32;
          0.2883	3.07	2.31;
          0.2952	3.01	2.33;
          0.3024	2.97	2.37;
          0.31	2.95	2.43;
          0.3139	2.95	2.46;
          0.3179	2.96	2.5;
          0.322	2.98	2.53;
          0.3263	2.99	2.56;
          0.3306	3.02	2.6;
          0.3351	3.05	2.62;
          0.3397	3.09	2.65;
          0.3444	3.13	2.67;
          0.3493	3.18	2.69;
          0.3542	3.24	2.7;
          0.3594	3.32	2.7;
          0.3647	3.39	2.66;
          0.3701	3.43	2.6;
          0.3757	3.45	2.55;
          0.3815	3.45	2.49;
          0.3875	3.43	2.45;
          0.3936	3.41	2.43;
          0.4	3.39	2.41;
          0.4065	3.37	2.42;
          0.4133	3.35	2.42;
          0.4203	3.33	2.43;
          0.4275	3.32	2.45;
          0.435	3.31	2.47;
          0.4428	3.3	2.49;
          0.4509	3.31	2.53;
          0.4592	3.31	2.55;
          0.4679	3.32	2.59;
          0.4769	3.34	2.62;
          0.4862	3.35	2.64;
          0.4959	3.38	2.68;
          0.5061	3.42	2.71;
          0.5166	3.45	2.72;
          0.5276	3.48	2.72;
          0.5391	3.5	2.72;
          0.551	3.5	2.73;
          0.5636	3.49	2.75;
          0.5767	3.51	2.81;
          0.5904	3.54	2.84;
          0.6048	3.57	2.86;
          0.6199	3.6	2.89;
          0.6358	3.65	2.92;
          0.6526	3.7	2.94;
          0.6702	3.76	2.95;
          0.6888	3.82	2.91;
          0.7085	3.85	2.86;
          0.7293	3.84	2.78;
          0.7514	3.78	2.72;
          0.7749	3.67	2.68;
          0.7999	3.56	2.73;
          0.8266	3.48	2.79;
          0.8551	3.38	2.85;
          0.8856	3.29	2.96;
          0.9184	3.2	3.07;
          0.9537	3.12	3.24;
          0.9919	3.05	3.39;
          1.033	3	3.64;
          1.078	3.02	3.83;
          1.127	3.05	4.04;
          1.181	3.11	4.19;
          1.24	3.14	4.32;
          1.265	3.15	4.36;
          1.291	3.15	4.41;
          1.319	3.15	4.43;
          1.348	3.14	4.45;
          1.378	3.11	4.44;
          1.409	3.05	4.42;
          1.425	3	4.39;
          1.442	2.92	4.37;
          1.459	2.8	4.33;
          1.476	2.62	4.37;
          1.494	2.47	4.47;
          1.512	2.36	4.61;
          1.55	2.22	4.85;
          1.59	2.12	5.05;
          1.63	1.97	5.27;
          1.675	1.83	5.52;
          1.722	1.7	5.81;
          1.771	1.59	6.13;
          1.823	1.52	6.45;
          1.879	1.45	6.78;
          1.937	1.36	7.14;
          2	1.28	7.52;
          2.066	1.21	7.96;
          2.138	1.18	8.44;
          2.214	1.2	8.94;
          2.296	1.23	9.45;
          2.384	1.3	9.98;
          2.48	1.4	10.5;
          2.583	1.54	11.1;
          2.695	1.69	11.6;
          2.818	1.82	12.1;
          2.952	1.92	12.6;
          3.1	1.94	13.2;
          3.263	1.86	13.9;
          3.444	1.82	14.7;
          3.647	1.21	15.7;
          3.875	1.72	16.9;
          4.133	1.83	18.3;
          4.959	2.56	22.4;
          6.199	3.87	28.3;
          6.888	4.72	31.5;
          7.749	5.92	35.3;
          8.856	7.58	40.2;
          10.33	10.1	46.4;
          12.4	14.1	54.7;
          13.78	17	60;
          15.5	20.9	66.3;
          17.71	26.5	73.8;
          20.66	34.5	82.9;
          24.8	46.5	93.7;
        ) 
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}

Material = "TungstenSilicide" {

ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0	= 1	# [1]
	k_0	= 0.0000e+00	# [1]
	Cn_lambda	= 0.0000e+00	# [um^-1]
	Dn_lambda	= 0.0000e+00	# [um^-2]
	Ck_lambda	= 0.0000e+00	# [um^-1]
	Dk_lambda	= 0.0000e+00	# [um^-2]
	Cn_temp	= 2.0000e-04	# [K^-1]
	Cn_carr	= 1	# [1]
	Ck_carr	= 0.0000e+00 ,	0.0000e+00	# [cm^2]
	Gamma_k_carr	= 1 ,	1	# [1]
	Cn_gain	= 0.0000e+00	# [1]
	Npar	= 1.0000e+18	# [cm^-3]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


}
