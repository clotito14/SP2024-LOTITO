\documentclass{article}
%% PACKAGES %%

\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage{braket}
\usepackage{listings}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{sourcecodepro}
\usepackage{multirow}

%%%%%%%%%%%%%%

\graphicspath{{./images}}
\setlength\parindent{0pt}       % globally supress indentation

%% LISTINGS CONFIG %%

\definecolor{purple2}{RGB}{153,0,153} % there's actually no standard purple
\definecolor{green2}{RGB}{0,153,0} % a darker green

\lstset{
  language=Verilog,                   % the language
  basicstyle=\normalsize\ttfamily,   % size of the fonts for the code
  frame = single,
  % Color settings to match IDLE style
  keywordstyle=\color{orange},       % core keywords
  keywordstyle={[2]\color{purple2}}, % built-ins
  stringstyle=\color{green2},%
  showstringspaces=false,
  commentstyle=\color{red},%
  upquote=true,                      % requires textcomp
  numbers=left,
  breaklines=true,
}

% Title Stuff
\title{\vspace{-3cm} ROM Squarer and Square Rooter Circuits \\ {\normalsize \textit{Verilog Lab 5}}}
\author{Chase A. Lotito, \textit{SIUC Undergraduate}}
\date{}

\begin{document}

\pagestyle{fancy}

% attempt to make nice header
\fancyhead{}
\fancyhead[CH]{\normalsize{LOTITO - SIUC ECE - ECE426 LAB 5}}

\maketitle % Makes the title

\section*{Section A: Squaring Circuit}

The following Verilog code implements a read-only memory (ROM) block that stores data for the squares of numbers; specifically, the squares for unsigned numbers 0 to 15, and signed numbers -8 to +7.

\begin{lstlisting}
/*
    Chase Lotito - SIUC
    ECE426 - Lab 5 - Design of Memory in Verilog
    Section A: ROM Squaring Circuit
        -> square unsigned 0-15
        -> square signed -8-7
*/

module rom_a (n, sign, square);

// I/O
input [3:0] n;             // signed number
input sign;                // bit (1 = signed) (0 = unsigned)
output reg [7:0] square;   // answer = n**2

// procedural block to compute squares as inputs come in
always @ (n or sign)
begin
    if (sign == 1'b0)
    begin
        case (n)           // UNSIGNED
            0 :square <= 0;
            1 :square <= 1;
            2 :square <= 4;
            3 :square <= 9;
            4 :square <= 16;
            5 :square <= 25;
            6 :square <= 36;
            7 :square <= 49;
            8 :square <= 64;
            9 :square <= 81;
            10 :square <= 100;
            11 :square <= 121;
            12 :square <= 144;
            13 :square <= 169;
            14 :square <= 196;
            15 :square <= 225;
            default: square <= 1'bx; // invalid input
        endcase
    end
    else
    begin
        case(n)             // SIGNED
            0 :square <= 0;
            1 :square <= 1;
            2 :square <= 4;
            3 :square <= 9;
            4 :square <= 16;
            5 :square <= 25;
            6 :square <= 36;
            7 :square <= 49;
            8 :square <= 64; // -8 x -8
            9 :square <= 49;
            10 :square <= 36;
            11 :square <= 25;
            12 :square <= 16;
            13 :square <= 9;
            14 :square <= 4;
            15 :square <= 1;
            default: square <= 1'bx; // invalid input
        endcase
    end
end

endmodule
\end{lstlisting}

To simulate the functionality of this ROM block, I sent in binary values 0000 to 1111 twice, where one iteration has the sign-bit set to 0 (unsigned) and then the sign-bit set to 1 (signed).

\begin{lstlisting}
/*
    chase lotito
    lab 5 section a
    rom squarer testbench
*/

`include "./rom_a.v"
`timescale 1us / 1us

module rom_a_tb();

// GTKWAVE (waveform simulator)
initial begin : GTKWAVE
    $dumpfile("rom_a.vcd");
    $dumpvars(0, rom_a_tb);
end

// I/O
reg [3:0] n;             // signed number
reg sign;                // bit (1 = signed) (0 = unsigned)
wire [7:0] square;   // answer = n**2

// Initialize the Squarer ROM
rom_a U1 (
    .n(n), .sign(sign), .square(square)
);

// Send 4-bit numbers 0000 -> 1111
initial begin : stimulus

    // begin sim with unsigned numbers
    sign = 0;

    // n = 0000 -> 1111
    for(integer i = 0; i < 16; i = i + 1)
        #10 n = i;

    #10 n = 0;      // reset n
    sign = 1;   // flip to signed
    #20;        // small delay til next loop

    // n = 0000 -> 1111
    for(integer i = 0; i < 16; i = i + 1)
        #10 n = i;

    #10 $finish;
end


endmodule
\end{lstlisting}

This gave the following waveforms in GTKWAVE:

\begin{figure}[!ht] 
    \centering
    \includegraphics*[width = 15.1cm]{rom_a_waves.png}
    \caption{Squarer Circuit Output Waveforms}
    \label{fig:squarerWaves}
\end{figure}    

\section*{Section B: Square Rooting Circuit}

The following Verilog code implements a read-only memory (ROM) block that stores data for the square roots of 0 to 15 (unsigned). Since we cannot set a register directly to a decimal with a non-integer value, we will set the register to a concatenated version containing the integer part and the decimal part, then use a continuous assignment to extract that information after the ROM has been accessed. Ultimately, we will be able to get square roots to 3 decimal precision.

\begin{lstlisting}
/*
    Chase Lotito - SIUC
    ECE426 - Lab 5 - Design of Memory in Verilog
    Section B: ROM Square Root Circuit
        -> sq_root root unsigned 0-15
            -> provide 3 decimals
*/

module rom_b (n, sq_root);

// I/O
input [3:0] n;               // unsigned number
output reg [11:0] sq_root;   // answer = n**1/2

wire [1:0] sq_root_int;      // integer part of sq_root
wire [9:0] sq_root_dp;       // decimal part of sq_root

// procedural block to compute roots as inputs come in
always @ (n)
begin
    case (n)
        0 :sq_root <= 0;
        1 :sq_root <= {2'd1, 10'd0};
        2 :sq_root <= {2'd1, 10'd414};
        3 :sq_root <= {2'd1, 10'd732};
        4 :sq_root <= {2'd2, 10'd0};
        5 :sq_root <= {2'd2, 10'd236};
        6 :sq_root <= {2'd2, 10'd450};
        7 :sq_root <= {2'd2, 10'd646};
        8 :sq_root <= {2'd2, 10'd828};
        9 :sq_root <= {2'd3, 10'd0};
        10 :sq_root <= {2'd3, 10'd162};
        11 :sq_root <= {2'd3, 10'd317};
        12 :sq_root <= {2'd3, 10'd464};
        13 :sq_root <= {2'd3, 10'd606};
        14 :sq_root <= {2'd3, 10'd742};
        15 :sq_root <= {2'd3, 10'd873};
        default: sq_root <= 12'd0; // reset by default
    endcase
end

// continuous assignments for int and decimal parts
assign sq_root_int = sq_root [11:10];
assign sq_root_dp = sq_root [9:0];

endmodule
\end{lstlisting}

To simulate the functionality of this ROM block, I sent in binary values 0000 to 1111 into the circuit to see the values we get out.

\begin{lstlisting}
/*
    chase lotito
    lab 5 section b
    rom square root testbench
*/

`include "./rom_b.v"
`timescale 1us / 1us

module rom_b_tb();

// GTKWAVE (waveform simulator)
initial begin : GTKWAVE
    $dumpfile("rom_b.vcd");
    $dumpvars(0, rom_b_tb);
end

// I/O
reg [3:0] n;             // signed number
wire [11:0] sq_root;     // square root of n

// Initialize the Squarer ROM
rom_b U1 (
    .n(n), .sq_root(sq_root)
);

// Send 4-bit numbers 0000 -> 1111
initial begin : stimulus

    // n = 0000 -> 1111
    for(integer i = 0; i < 16; i = i + 1)
        #10 n = i;

    #10 $finish;
end


endmodule
\end{lstlisting}

This gave the following waveforms in GTKWAVE:

\begin{figure}[!ht] 
    \centering
    \includegraphics*[width = 15.1cm]{rom_b_waves.png}
    \caption{Square Rooter Circuit Output Waveforms}
    \label{fig:squareRooterWaves}
\end{figure}    

\end{document}
